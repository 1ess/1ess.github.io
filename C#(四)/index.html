<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title> · A Sort Of A Blog</title><meta name="description" content="这一篇，我们讲讲 C# 中关于继承的相关知识。
继承
通过继承我们可以定义新的派生类(derived class)，来对基类(base class)进行扩展。派生类的成员包括: 

本身声明的成员
基类的成员

注意: 派生类不能删除它所继承的任何成员。
要声明一个派生类，需要在类名后跟一个冒号，然"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="https://cdn.jsdelivr.net/gh/1ess/cdn/h4cker/favicon-32x32.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">0x7c00</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">张冬冬的博客</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首頁</a></li><li><a href="/archives">歸檔</a></li><li class="soc"><a href="https://github.com/1ess" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://1ess.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a></a></p><p class="post-meta"><span class="date meta-item">發佈於&nbsp;2021-07-14</span></p><p class="post-abstract"><p>这一篇，我们讲讲 C# 中关于继承的相关知识。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr>
<p>通过继承我们可以定义新的派生类(derived class)，来对基类(base class)进行扩展。<br>派生类的成员包括: </p>
<ul>
<li>本身声明的成员</li>
<li>基类的成员</li>
</ul>
<p>注意: 派生类不能删除它所继承的任何成员。</p>
<p>要声明一个派生类，需要在类名后跟一个冒号，然后跟基类名。与 Objective-C 的继承声明相同。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>     <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>继承的成员可以被访问，就像他们是派生类本身声明的一样: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;base class field&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Base class -- Method1:    &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field2 = <span class="hljs-string">&quot;derived class&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Derived class -- Method2:    &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        OtherClass oc = <span class="hljs-keyword">new</span> OtherClass();<br><br>        oc.Method1(oc.Field1);<br>        oc.Method1(oc.Field2);        <br>        oc.Method2(oc.Field1);<br>        oc.Method2(oc.Field2);        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了 object，所有的类都是派生类，object 是唯一的非派生类，他是继承层次结构的基础。<br>没有基类声明的类隐式直接派生自 object 类。<br>C# 中的继承是单继承，与 Objective-C、JavaScript 一样。<br>通常我们称一个类为派生类时，我们是说他直接派生自某个类而不是 object。</p>
<h3 id="屏蔽基类成员"><a href="#屏蔽基类成员" class="headerlink" title="屏蔽基类成员"></a>屏蔽基类成员</h3><p>我们虽然不能删除基类的任何成员，但是我们可以使用与基类名相同名称的成员来屏蔽基类成员。<br>在派生类屏蔽基类成员的要点如下: </p>
<ul>
<li>要屏蔽一个数据成员，需要声明一个新的相同类型的同名成员</li>
<li>要屏蔽一个函数成员，需要在派生类中声明带有相同签名的函数成员</li>
<li>要然编译器知道我们故意屏蔽基类成员，需要使用 new 修饰符。否则屏蔽成员会报警告</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;SomeClass Field1&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;SomeClass.Method1: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;OtherClass Field1&quot;</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;OtherClass.Method1: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        OtherClass oc = <span class="hljs-keyword">new</span> OtherClass();<br>        oc.Method1(oc.Field1);  <span class="hljs-comment">//OtherClass.Method1: OtherClass Field1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基类访问"><a href="#基类访问" class="headerlink" title="基类访问"></a>基类访问</h3><p>如果要在派生类中需要访问被屏蔽的成员，可以使用基类访问表达式来访问隐藏的成员。<br>基类访问表达式由关键字 base 后跟点操作符加要访问的成员: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>, <span class="hljs-keyword">base</span>.Field1);<br></code></pre></td></tr></table></figure>

<p>如果程序需要经常使用这个特性，可能需要重新设计了。</p>
<h3 id="使用基类的引用"><a href="#使用基类的引用" class="headerlink" title="使用基类的引用"></a>使用基类的引用</h3><p>派生类的引用指向整个类结构，包括基类部分。<br>如果有一个派生类引用，我们就可以获取对象基类部分的引用(使用类型转换): </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is base class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is derived class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        DerivedClass dc = <span class="hljs-keyword">new</span> DerivedClass();<br>        BaseClass bc = (BaseClass)dc;<br>        dc.Print();  <span class="hljs-comment">// derived class print</span><br>        bc.Print();  <span class="hljs-comment">// base class print</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过类型转换而来的”基类”，不能”看”到派生类的部分。</p>
<h3 id="虚方法和覆写方法"><a href="#虚方法和覆写方法" class="headerlink" title="虚方法和覆写方法"></a>虚方法和覆写方法</h3><p>虚方法可以使基类的引用访问”提升”至派生类，只需满足如下条件: </p>
<ul>
<li>派生类的方法和基类的方法的签名和返回值都一致</li>
<li>基类方法使用 virtual 标注</li>
<li>派生类方法使用 override 标注</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is base class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is derived class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        DerivedClass dc = <span class="hljs-keyword">new</span> DerivedClass();<br>        BaseClass bc = (BaseClass)dc;<br>        dc.Print();  <span class="hljs-comment">// derived class print</span><br>        bc.Print();  <span class="hljs-comment">// derived class print</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于 virtual 和 override 修饰符的重要信息如下: </p>
<ul>
<li>覆写和被覆写的方法必须具有相同的访问性</li>
<li>不能覆写 static 方法和非虚方法</li>
<li>方法、属性、索引器和事件可以被声明为 virtual 和 override</li>
</ul>
<p>覆写方法可以在继承的任何层次出现，方法的调用会沿着派生层次一直追溯到标记为 override 的最高派生类。</p>
<p>注意: Objective-C 没有虚方法的概念，Objective-C 中所有的方法都是虚方法: </p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Animal</span>: <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-keyword">void</span>)sing;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Animal</span></span><br>- (<span class="hljs-keyword">void</span>)sing &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;animal sing&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Dog</span>: <span class="hljs-title">Animal</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Dog</span></span><br>- (<span class="hljs-keyword">void</span>)sing &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;dog sing&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)main &#123;<br>    Dog *dog = [[Dog alloc] init];<br>    Animal *animal = dog;<br>    [dog sing];  <span class="hljs-comment">//&quot;dog sing&quot;</span><br>    [animal sing]; <span class="hljs-comment">//&quot;dog sing&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>虚方法是面向对象中多态的基础，多态性又叫动态绑定、推迟绑定或运行期绑定。是允许你将父对象设置成为一个或更多的它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</strong></p>
<h3 id="构造函数的执行"><a href="#构造函数的执行" class="headerlink" title="构造函数的执行"></a>构造函数的执行</h3><p>派生类对象有一部分就是基类对象: </p>
<ul>
<li>要创建对象的基类部分，需要隐式的调用基类的某个构造函数作为实例创建的一部分</li>
<li>每个类在执行自己的构造函数之前要执行基类的构造函数</li>
</ul>
<p><strong>默认情况，构造对象时，将调用基类的无参构造函数</strong>，如果希望派生类调用的是有参构造的话，就需要构造函数初始化语句。<br>有两种形式的构造函数初始化语句: </p>
<ul>
<li>使用 base 并指明使用哪一个基类的构造函数</li>
<li>使用 this 并指明使用哪一个当前类的构造函数</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> MyDerivedClass<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">string</span> s</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">base</span>(<span class="hljs-params">x, s</span>)</span> <br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，我们可以需要在构造函数中使用当前类的其他构造: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> a;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        a = <span class="hljs-number">10</span>;<br>        b = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">this</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        FirstName = firstName;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> lastName</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">this</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        LastName = lastName;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="类的访问修饰符"><a href="#类的访问修饰符" class="headerlink" title="类的访问修饰符"></a>类的访问修饰符</h3><p>类的可访问修饰符有两种: public 和 internal: </p>
<ul>
<li>标记为 public 的类可以被系统内任何程序集访问</li>
<li>标记为 internal 的类只能被该类所在的程序集访问</li>
</ul>
<p>注意: internal 是类的默认访问级别。</p>
<h3 id="成员的访问修饰符"><a href="#成员的访问修饰符" class="headerlink" title="成员的访问修饰符"></a>成员的访问修饰符</h3><p>成员的默认的访问级别是 private，并且成员不能比他的类有更高的可访问性。</p>
<ul>
<li>private 成员只能被他自己的类访问，不能被其他类访问，包括继承的类。但能被嵌套在他的类中的类访问</li>
<li>protected 成员访问级别与 private 一样，只是它允许派生自他的类访问该成员</li>
<li>internal 成员只对程序集内部可见</li>
<li>protected internal 成员对所有继承自他的类可以访问，也可以对他所在的程序集可访问(注意是并集而不是交集)</li>
</ul>
<h3 id="抽象成员和抽象类"><a href="#抽象成员和抽象类" class="headerlink" title="抽象成员和抽象类"></a>抽象成员和抽象类</h3><p>抽象成员是指被设计为被覆写的函数成员，有以下特征: </p>
<ul>
<li>必须是函数成员</li>
<li>必须是由 abstract 修饰符修饰</li>
<li>没有方法实现代码块</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span>;<br></code></pre></td></tr></table></figure>

<p>抽象成员只能在抽象类中声明，一共有 4 中类型的成员可以声明为抽象: </p>
<ul>
<li>方法</li>
<li>属性</li>
<li>事件</li>
<li>索引</li>
</ul>
<p>派生类重写抽象成员要是有 override 标记: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;override abstract method&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>抽象类就是被设计为被继承的类，抽象类只能作为其他类的基类: </p>
<ul>
<li>我们不能创建抽象类的实例</li>
<li>抽象类也使用 abstract 修饰符修饰</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyAbstractClass</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意: </p>
<ul>
<li>抽象类中可以有非抽象成员</li>
<li>抽象类可以派生自其他抽象类</li>
<li>任何派生自抽象类的类必须实现所有抽象成员，除非她本身也是派生类</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassB</span> : <span class="hljs-title">ClassA</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>密封类与抽象类相反，他不能被继承，使用 sealed 修饰。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySealedClass</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><ul>
<li>静态类中所有成员都是静态的</li>
<li>静态类被标记为 static</li>
<li>静态类是隐式密封的，也就是说，他不能被继承</li>
<li>它可以有一个静态构造函数，但不能有实例构造函数</li>
</ul>
<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>如果我们不能修改某个类的源文件，而希望给该类添加方法，可以使用扩展方法: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//必须是静态类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExtendMyClass</span><br>&#123;<br>    <span class="hljs-comment">//必须声明为 public 和 static 方法，参数传入要扩展的类的实例，并且前面加 this 关键字</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Avg</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> MyBaseClass bc</span>)</span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="C-命名约定"><a href="#C-命名约定" class="headerlink" title="C# 命名约定"></a>C# 命名约定</h3><ul>
<li>帕斯卡命名: 命名空间、类名、方法、属性和公共字段</li>
<li>驼峰命名: 私有变量和形参</li>
<li>下划线加驼峰: 私有和受保护字段</li>
</ul>
</p></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/C#(%E4%B8%89)/" title=""><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: </a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/C#(%E4%BA%94)/" title="">下一篇: &nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>