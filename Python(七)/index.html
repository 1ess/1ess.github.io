<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Python(七) · A Sort Of A Blog</title><meta name="description" content="本篇，我们说说 Python 中的函数式编程的基本概念。
高阶函数(Higher-order function)
map()Python 内建了 map() 函数。map() 函数接收两个参数，一个是函数，一个是 Iterable，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的 It"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="https://cdn.jsdelivr.net/gh/1ess/cdn/h4cker/favicon-32x32.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">0x7c00</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">张冬冬的博客</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首頁</a></li><li><a href="/archives">歸檔</a></li><li class="soc"><a href="https://github.com/1ess" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://1ess.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Python(七)</a></p><p class="post-meta"><span class="date meta-item">發佈於&nbsp;2019-04-13</span></p><p class="post-abstract"><p>本篇，我们说说 Python 中的函数式编程的基本概念。</p>
<h2 id="高阶函数-Higher-order-function"><a href="#高阶函数-Higher-order-function" class="headerlink" title="高阶函数(Higher-order function)"></a>高阶函数(Higher-order function)</h2><hr>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>Python 内建了 map() 函数。<br>map() 函数接收两个参数，一个是函数，一个是 Iterable，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的 Iterator 返回。由于结果是一个 Iterator，Iterator 是惰性序列，因此我们还可以通过 list() 函数让它把整个序列都计算出来并返回一个 list。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> x * x<br><br>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br><span class="hljs-built_in">list</span>(r)<br><span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]))<br><span class="hljs-comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span><br></code></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce 把一个函数作用在一个序列 [x1, x2, x3, …] 上，这个函数必须接收两个参数，reduce 把结果继续和序列的下一个元素做累积计算，效果就是: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x, y</span>):</span><br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char2num</span>(<span class="hljs-params">s</span>):</span><br>    digits = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-number">9</span>&#125;<br>    <span class="hljs-keyword">return</span> digits[s]<br><br>reduce(fn, <span class="hljs-built_in">map</span>(char2num, <span class="hljs-string">&#x27;13579&#x27;</span>))<br><span class="hljs-comment"># 13579</span><br></code></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>和 map() 类似，filter() 也接收一个函数和一个序列。和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_empty</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> s <span class="hljs-keyword">and</span> s.strip()<br><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(not_empty, [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;  &#x27;</span>]))<br><span class="hljs-comment"># [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></code></pre></td></tr></table></figure>

<p>与 map() 一样，filter() 函数返回的也是一个 Iterator，也就是一个惰性序列，所以要强迫 filter() 完成计算结果，需要用 list() 函数获得所有结果并返回 list。</p>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>之前我们说过，Python 内置的 sorted() 函数可以对 list 进行排序: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">21</span>])<br><span class="hljs-comment"># [-21, -12, 5, 9, 36]</span><br></code></pre></td></tr></table></figure>

<p>此外，sorted() 函数也是一个高阶函数，它还可以接收一个 key 函数来实现自定义的排序: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">21</span>], key=<span class="hljs-built_in">abs</span>)<br><span class="hljs-comment"># [5, 9, -12, -21, 36]</span><br></code></pre></td></tr></table></figure>

<p>key 指定的函数将作用于 list 的每一个元素上，并根据 key 函数返回的结果进行排序。</p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><hr>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lazy_sum</span>(<span class="hljs-params">*args</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span>():</span><br>        ax = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> args:<br>            ax = ax + n<br>        <span class="hljs-keyword">return</span> ax<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br><br>f = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br>f()<br><span class="hljs-comment"># 25</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们在函数 lazy_sum 中又定义了函数 sum，并且，内部函数 sum 可以引用外部函数 lazy_sum 的参数和局部变量，当 lazy_sum 返回函数 sum 时，相关参数和变量都保存在返回的函数中，这种结构被称为”闭包(Closure)”。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了才执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>():</span><br>    fs = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span><br>             <span class="hljs-keyword">return</span> i*i<br>        fs.append(f)<br>    <span class="hljs-keyword">return</span> fs<br><br>f1, f2, f3 = count()<br></code></pre></td></tr></table></figure>

<p>你可能认为调用 f1()，f2() 和 f3() 结果应该是 1，4，9，但实际结果是 9，9，9。<br>原因就在于返回的函数引用了变量 i，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量 i 已经变成了 3，因此最终结果为 9。返回闭包时牢记一点: 返回函数不要引用任何循环变量，或者后续会发生变化的变量。<br>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">j</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><br>            <span class="hljs-keyword">return</span> j*j<br>        <span class="hljs-keyword">return</span> g<br>    fs = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        fs.append(f(i)) <span class="hljs-comment"># f(i)立刻被执行，因此i的当前值被传入f()</span><br>    <span class="hljs-keyword">return</span> fs<br><br>f1, f2, f3 = count()<br>f1()<br><span class="hljs-comment"># 1</span><br>f2()<br><span class="hljs-comment"># 4</span><br>f3()<br><span class="hljs-comment"># 9</span><br></code></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><hr>
<p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。<br>以 map() 函数为例，计算 f(x)=x<sup>2</sup> 时，除了定义一个 f(x) 的函数外，还可以直接传入匿名函数: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x * x, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]))<br><span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></code></pre></td></tr></table></figure>

<p>关键字 lambda 表示匿名函数，冒号前面的 x 表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> x : x * x<br>f(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># 9</span><br></code></pre></td></tr></table></figure>

<p>同样，也可以把匿名函数作为返回值返回: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build</span>(<span class="hljs-params">x, y</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span>: x * x + y * y<br></code></pre></td></tr></table></figure>

<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><hr>
<p>在代码运行期间动态增加功能的方式，称之为”装饰器”(Decorator)。<br>本质上，decorator就是一个返回函数的高阶函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span>(<span class="hljs-params">func</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kw</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call %s():&#x27;</span> % func.__name__)<br>        <span class="hljs-keyword">return</span> func(*args, **kw)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-comment"># 借助 Python 的 @ 语法，把 decorator 置于函数的定义处</span><br><span class="hljs-meta">@log</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">now</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2019-2-12&#x27;</span>)<br><br><span class="hljs-comment"># 相当于执行了语句</span><br>now = log(now)<br></code></pre></td></tr></table></figure>

<p>如果 decorator 本身需要传入参数，那就需要编写一个返回 decorator 的高阶函数: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span>(<span class="hljs-params">text</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kw</span>):</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))<br>            <span class="hljs-keyword">return</span> func(*args, **kw)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><br><span class="hljs-meta">@log(<span class="hljs-params"><span class="hljs-string">&#x27;execute&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">now</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2019-2-12&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>和两层嵌套的 decorator 相比，3 层嵌套的效果是这样的: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">now = log(<span class="hljs-string">&#x27;execute&#x27;</span>)(now)<br></code></pre></td></tr></table></figure>

<p>Python 内置的 functools.wraps 用于还原函数的 __name__: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kw</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call %s():&#x27;</span> % func.__name__)<br>        <span class="hljs-keyword">return</span> func(*args, **kw)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span>(<span class="hljs-params">text</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kw</span>):</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))<br>            <span class="hljs-keyword">return</span> func(*args, **kw)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator   <br></code></pre></td></tr></table></figure>

<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><hr>
<p>Python 的 functools 模块提供了很多有用的功能，其中一个就是偏函数(Partial function)。<br>functools.partial 就是帮助我们创建一个偏函数的，简单总结 functools.partial 的作用就是，把一个函数的某些参数给固定住(也就是设置默认值)，返回一个新的函数，调用这个新函数会更简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br>int2 = functools.partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br>int2(<span class="hljs-string">&#x27;1000000&#x27;</span>)<br><span class="hljs-comment"># 64</span><br></code></pre></td></tr></table></figure></p></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/Python(%E5%85%AB)/" title="Python(八)"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: Python(八)</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/Python(%E5%85%AD)/" title="Python(六)">下一篇: Python(六)&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>