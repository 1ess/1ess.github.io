

<!DOCTYPE html>
<html lang="zh-tw" xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head>
    <title>Python(六) - A Sort Of A Blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Stephen Chang">
<meta name="description" content="本篇，我们说说 Python 中的面向对象高级编程的基本概念。
数据封装、继承和多态只是面向对象程序设计中最基础的 3 个概念。在 Python 中，面向...">
<meta name="keywords" content="">

<link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml">

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?61828830">

<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons"/>
</noscript>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="https://1ess.github.io">
                Home
            </a>
            
            <a class="a-block drawer-menu-item false" href="/archives">
                Archive
            </a>
            

            
            

            
            <a class="a-block drawer-menu-item" href="/atom.xml">
                RSS
            </a>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            A Sort Of A Blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">A Sort Of A Blog</div>
        <div class="single-column-header-subtitle">旧游无处不堪寻，无寻处，惟有少年心</div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            A Sort Of A Blog
        </div>
        <div class="nav-subtitle">
            旧游无处不堪寻，无寻处，惟有少年心
        </div>
    </a>

    <div class="nav-link-list">
        
        <a class="a-block no-tint nav-link-item false" href="/archives">
            Archive
        </a>
        

        
        

        
        <a class="a-block no-tint nav-link-item" href="/atom.xml">
            RSS
        </a>
        
    </div>

    
    <div class="nav-footer">
        &copy; 2022 <a href="https://1ess.github.io">A Sort Of A Blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>



<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper"
                 style="background-image: url('https://cdn.jsdelivr.net/gh/1ess/cdn/blogImg/Blog106.jpg')">
                <div class="post-title">
                    Python(六)
                    <div class="post-meta">
                        <time datetime="2019-04-12T00:00:00.000Z" itemprop="datePublished">
                            2019-04-12
                        </time>&nbsp;
                        
    
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <p>本篇，我们说说 Python 中的面向对象高级编程的基本概念。</p>
<p>数据封装、继承和多态只是面向对象程序设计中最基础的 3 个概念。在 Python 中，面向对象还有很多高级特性，允许我们写出非常强大的功能。本篇，我们会说说多重继承、定制类等概念。</p>
<h2 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h2><hr>
<p>正常情况下，当我们定义了一个 class，创建了一个 class 的实例后，我们可以给该实例绑定任何属性和方法: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 给实例绑定一个属性</span><br>p = Person()<br>p.name = <span class="hljs-string">&#x27;Michael&#x27;</span><br><span class="hljs-built_in">print</span>(p.name)<br><span class="hljs-comment"># Michael</span><br><br><span class="hljs-comment"># 给实例绑定一个方法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_age</span>(<span class="hljs-params">self, age</span>):</span> <span class="hljs-comment"># 定义一个函数作为实例方法</span><br>    self.age = age<br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MethodType<br>p.set_age = MethodType(set_age, p)<br>p.set_age(<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(p.age)<br><span class="hljs-comment"># 20</span><br></code></pre></td></tr></table></figure>

<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的，为了给所有实例都绑定方法，可以给 class 绑定方法: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_score</span>(<span class="hljs-params">self, score</span>):</span><br>    self.score = score<br>Person.set_score = set_score<br><span class="hljs-comment"># 所有实例均可调用</span><br>p1.set_score(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(p1.score)<br><span class="hljs-comment"># 100</span><br><br>p2.set_score(<span class="hljs-number">90</span>)<br><span class="hljs-built_in">print</span>(p2.score)<br><span class="hljs-comment"># 90</span><br></code></pre></td></tr></table></figure>

<p>为了达到限制的目的，Python 允许在定义 class 的时候，定义一个特殊的 __slots__ 变量，来限制该 class 实例能添加的属性: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>)<br><br>p = Person()<br>p.name = <span class="hljs-string">&#x27;Michael&#x27;</span><br>p.age = <span class="hljs-number">20</span><br>p.score = <span class="hljs-number">100</span> <span class="hljs-comment"># AttributeError</span><br></code></pre></td></tr></table></figure>

<p>试图绑定 __slots__ 元组中不存在的字段名，将得到 AttributeError 的错误。</p>
<p>注意: __slots__ 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</p>
<h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><hr>
<p>Python 内置的 @property 装饰器就是负责把一个方法变成属性调用: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._score<br><br><span class="hljs-meta">    @score.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">type</span>(value) == <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;score must be an integer!&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;score must between 0 ~ 100!&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self._score = value<br><br>p = Person()<br>p.score = <span class="hljs-number">200</span> <span class="hljs-comment"># score must between 0 ~ 100!</span><br>p.score = <span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-comment"># score must be an integer!</span><br>p.score = <span class="hljs-number">90</span><br><span class="hljs-built_in">print</span>(p.score)<br><span class="hljs-comment"># 90</span><br></code></pre></td></tr></table></figure>

<p>把一个 getter 方法变成属性，只需要加上 @property 就可以了，此时，@property 本身又创建了另一个装饰器 @score.setter，负责把一个 setter 方法变成属性赋值，还可以定义只读属性，只定义 getter 方法，不定义 setter 方法就是一个只读属性。</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><hr>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。<br>在设计类的继承关系时，通常，主线都是单一继承下来的，但是，如果需要”混入”额外的功能，通过多重继承就可以实现，这种设计通常称之为 MixIn。</p>
<p>Python 自带的很多库也使用了 MixIn。举个例子，Python 自带了 TCPServer 和 UDPServer 这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由 ForkingMixIn 和 ThreadingMixIn 提供。通过组合，我们就可以创造出合适的服务来。</p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><hr>
<p>看到类似 __slots__ 这种形如 __xxx__ 的变量或者函数名就要注意，这些在 Python 中是有特殊用途的。<br>__slots__ 我们已经知道怎么用了，__len__() 方法我们也知道是为了能让 class 作用于 len() 函数。<br>除此之外，Python 的 class 中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><p>__str__ 就相当于 Objective-C 中的 Description 方法或 C# 中的 toString() 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self._name = name<br><br><span class="hljs-built_in">print</span>(Person(<span class="hljs-string">&#x27;Michael&#x27;</span>))<br><span class="hljs-comment"># &lt;__main__.Person object at 0x000001644DFB28D0&gt;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self._name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Person object name is &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self._name)<br><br>    __repr__ = __str__<br><br><span class="hljs-built_in">print</span>(Person(<span class="hljs-string">&#x27;Michael&#x27;</span>))<br><span class="hljs-comment"># Person object name is Michael</span><br><br>Person(<span class="hljs-string">&#x27;Michael&#x27;</span>)<br><span class="hljs-comment"># Person object name is Michael</span><br></code></pre></td></tr></table></figure>

<h3 id="iter-和-next"><a href="#iter-和-next" class="headerlink" title="__iter__ 和 __next__"></a>__iter__ 和 __next__</h3><p>果一个类想被用于 for … in 循环，类似 list 或 tuple，就必须实现一个 __iter__() 方法，该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 __next__() 方法拿到循环的下一个值，直到遇到 StopIteration 错误时退出循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fib</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>            self.a = <span class="hljs-number">0</span><br>            self.b = <span class="hljs-number">1</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>            <span class="hljs-keyword">return</span> self<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span><br>            self.a, self.b = self.b, self.a + self.b <span class="hljs-comment"># Pythonic</span><br>            <span class="hljs-keyword">if</span> self.a &gt; <span class="hljs-number">10000</span>:<br>                    <span class="hljs-keyword">raise</span> StopIteration()<br>            <span class="hljs-keyword">return</span> self.a<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> Fib():<br>    <span class="hljs-built_in">print</span>(n)<br>    <span class="hljs-comment"># 1</span><br>    <span class="hljs-comment"># 2</span><br>    <span class="hljs-comment"># 3</span><br>    <span class="hljs-comment"># 5</span><br>    <span class="hljs-comment"># 8</span><br>    <span class="hljs-comment"># 13</span><br>    <span class="hljs-comment"># 21</span><br>    <span class="hljs-comment"># 34</span><br>    <span class="hljs-comment"># 55</span><br>    <span class="hljs-comment"># 89</span><br>    <span class="hljs-comment"># 144</span><br>    <span class="hljs-comment"># 233</span><br>    <span class="hljs-comment"># 377</span><br>    <span class="hljs-comment"># 610</span><br>    <span class="hljs-comment"># 987</span><br>    <span class="hljs-comment"># 1597</span><br>    <span class="hljs-comment"># 2584</span><br>    <span class="hljs-comment"># 4181</span><br>    <span class="hljs-comment"># 6765</span><br></code></pre></td></tr></table></figure>

<h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a>__getitem__</h3><p>Fib 实例虽然能作用于 for 循环，看起来和 list 有点像，但是，把它当成 list 来使用还是不行，比如，取第 5 个元素: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Fib()[<span class="hljs-number">5</span>]<br><span class="hljs-comment"># TypeError: &#x27;Fib&#x27; object does not support indexing</span><br></code></pre></td></tr></table></figure>

<p>要表现得像 list 那样按照下标取出元素，需要实现 __getitem__() 方法: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fib</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">int</span>): <span class="hljs-comment"># n是索引</span><br>            a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                a, b = b, a + b<br>            <span class="hljs-keyword">return</span> a<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n, <span class="hljs-built_in">slice</span>): <span class="hljs-comment"># n是切片</span><br>            start = n.start<br>            stop = n.stop<br>            <span class="hljs-keyword">if</span> start <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                start = <span class="hljs-number">0</span><br>            a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>            L = []<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(stop):<br>                <span class="hljs-keyword">if</span> x &gt;= start:<br>                    L.append(a)<br>                a, b = b, a + b<br>            <span class="hljs-keyword">return</span> L<br></code></pre></td></tr></table></figure>

<h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h3><p>之前说过，当我们调用类的方法或属性时，如果不存在，就会报错。<br>Python 有一个机制，那就是写一个 __getattr__() 方法，动态返回一个属性: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.name = <span class="hljs-string">&#x27;Michael&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, attr</span>):</span><br>        <span class="hljs-keyword">if</span> attr==<span class="hljs-string">&#x27;score&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">99</span><br></code></pre></td></tr></table></figure>

<p>当调用不存在的属性时，比如 score，Python 解释器会试图调用 __getattr__(self, ‘score’) 来尝试获得属性，这样，我们就有机会返回 score 的值。</p>
<p>注意，只有在没有找到属性的情况下，才调用 __getattr__，已有的属性，比如 name，不会在 __getattr__ 中查找。</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><hr>
<p>Python 提供了 Enum 类来实现其它语言的枚举: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br>Month = Enum(<span class="hljs-string">&#x27;Month&#x27;</span>, (<span class="hljs-string">&#x27;Jan&#x27;</span>, <span class="hljs-string">&#x27;Feb&#x27;</span>, <span class="hljs-string">&#x27;Mar&#x27;</span>, <span class="hljs-string">&#x27;Apr&#x27;</span>, <span class="hljs-string">&#x27;May&#x27;</span>, <span class="hljs-string">&#x27;Jun&#x27;</span>, <span class="hljs-string">&#x27;Jul&#x27;</span>, <span class="hljs-string">&#x27;Aug&#x27;</span>, <span class="hljs-string">&#x27;Sep&#x27;</span>, <span class="hljs-string">&#x27;Oct&#x27;</span>, <span class="hljs-string">&#x27;Nov&#x27;</span>, <span class="hljs-string">&#x27;Dec&#x27;</span>))<br><br><span class="hljs-keyword">for</span> name, member <span class="hljs-keyword">in</span> Month.__members__.items():<br>    <span class="hljs-built_in">print</span>(name, <span class="hljs-string">&#x27;=&gt;&#x27;</span>, member, <span class="hljs-string">&#x27;,&#x27;</span>, member.value)<br>    <span class="hljs-comment"># value 属性则是自动赋给成员的 int 常量，默认从 1 开始计数。</span><br></code></pre></td></tr></table></figure>

<p>如果需要更精确地控制枚举类型，可以从 Enum 派生出自定义类: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum, unique<br><br><span class="hljs-meta">@unique</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weekday</span>(<span class="hljs-params">Enum</span>):</span><br>    Sun = <span class="hljs-number">0</span> <span class="hljs-comment"># Sun 的 value 被设定为 0</span><br>    Mon = <span class="hljs-number">1</span><br>    Tue = <span class="hljs-number">2</span><br>    Wed = <span class="hljs-number">3</span><br>    Thu = <span class="hljs-number">4</span><br>    Fri = <span class="hljs-number">5</span><br>    Sat = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>@unique 装饰器可以帮助我们检查保证没有重复值。<br>访问这些枚举类型可以有若干种方法: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Weekday.Tue)<br><span class="hljs-comment"># Weekday.Tue</span><br><span class="hljs-built_in">print</span>(Weekday[<span class="hljs-string">&#x27;Tue&#x27;</span>])<br><span class="hljs-comment"># Weekday.Tue</span><br><span class="hljs-built_in">print</span>(Weekday.Tue.value)<br><span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(Weekday(<span class="hljs-number">1</span>))<br><span class="hljs-comment"># Weekday.Mon</span><br></code></pre></td></tr></table></figure>
                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/Python(%E4%B8%83)/">
        Previous post<br>Python(七)
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/Python(%E4%BA%94)/">
        Next post<br>Python(五)
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    &copy; 2022 <a href="https://1ess.github.io">A Sort Of A Blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js"
        integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js"
        integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"
        integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js"
        integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?61547548"></script>



</body>
</html>
