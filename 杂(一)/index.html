<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>杂(一) · A Sort Of A Blog</title><meta name="description" content="这一篇，记录关于 .Net 和 .Net Core 的一些零碎的知识点，随时更新。
ASP.Net WebAPI 和 WebMVC 问题
跨域
针对 .NET Framework MVC 跨域，只需要在 web.config 中添加如下的内容即可: 

&amp;lt;system.webServer&amp;gt"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="https://cdn.jsdelivr.net/gh/1ess/cdn/h4cker/favicon-32x32.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">0x7c00</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">张冬冬的博客</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首頁</a></li><li><a href="/archives">歸檔</a></li><li class="soc"><a href="https://github.com/1ess" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://1ess.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>杂(一)</a></p><p class="post-meta"><span class="date meta-item">發佈於&nbsp;2018-10-11</span></p><p class="post-abstract"><p>这一篇，记录关于 .Net 和 .Net Core 的一些零碎的知识点，随时更新。</p>
<h2 id="ASP-Net-WebAPI-和-WebMVC-问题"><a href="#ASP-Net-WebAPI-和-WebMVC-问题" class="headerlink" title="ASP.Net WebAPI 和 WebMVC 问题"></a>ASP.Net WebAPI 和 WebMVC 问题</h2><hr>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li>针对 .NET Framework MVC 跨域，只需要在 web.config 中添加如下的内容即可: </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">system.webServer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">httpProtocol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">customHeaders</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;*&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GET, POST, PUT, DELETE, OPTIONS&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">customHeaders</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">httpProtocol</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">system.webServer</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>针对 .NET Framework Web API，除了上面这样的设置，还需要添加一个特殊的设计，就是为每个 APIController 添加一个 OPTIONS 方法，返回 null 即可: </li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Options</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// HTTP 200 response with empty body</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>针对 .Net Core 跨域，需要在 Startup.cs 文件的 ConfigureServices 方法中添加以下代码: </li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//允许某些源</span><br>services.AddCors(options =&gt; &#123;<br>    options.AddPolicy(<span class="hljs-string">&quot;AllowCors&quot;</span>, policy =&gt; &#123;<br>        <span class="hljs-comment">// 多个可以用 `,` 隔开</span><br>        policy.WithOrigins(<span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<span class="hljs-string">&quot;http://127.0.0.1&quot;</span>)<br>                  .AllowAnyHeader()<br>                  .AllowAnyMethod()<br>                  .AllowCredentials();<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>如果是所有方法都允许跨域，就在 Configure 方法中还需要添加以下代码: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">app.UseCors(<span class="hljs-string">&quot;AllowCors&quot;</span>);<span class="hljs-comment">//必须位于 UserMvc 之前 </span><br>app.UseMvc();<br></code></pre></td></tr></table></figure>

<p>如果是某些方法允许跨域，就在该 Controller 添加如下代码: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Cors;<br><br>[<span class="hljs-meta">EnableCors(<span class="hljs-meta-string">&quot;AllowCors&quot;</span>)</span>] <span class="hljs-comment">//可实现指定某个 controller 或者 action 跨域</span><br></code></pre></td></tr></table></figure>

<h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>对于 .Net Framework MVC: </p>
<ul>
<li>对于 Post 请求，不论是简单类型还是复杂类型，调用 API 时，都会在 Body 中提交数据，以 x-www-form-urlencoded 和 application/json 两种形式提交都可以在服务端获取到。简单类型直接作为 key，复杂类型属性作为 key</li>
<li>对于 Get 请求，不论是简单类型还是复杂类型，调用 API 时，都会在 Query 中提交数据。简单类型直接拼接，复杂类型属性拼接</li>
</ul>
<p>对于 .Net Core MVC: </p>
<ul>
<li>对于 Post 请求，不论基本类型还是复杂类型参数，调用 API 时，既可以在 Query 中提交参数，也可以使用 x-www-form-urlencoded 表单形式提交参数，在服务端都可以接收到。对于复杂类型，我们也可以指定[FromBody] attribute，使得该复杂类型可以以 application/json Json 形式提交</li>
<li>对于 Get 请求，参数只能是简单类型，默认只能在 Query 中提交参数。我们也不该在 Get 请求使用复杂类型放在 Body 中提交</li>
</ul>
<p>对于 .Net Framework API: </p>
<ul>
<li>对于 Post 请求: <ol>
<li>如果是简单类型参数，调用 API 时，默认是在 Query 中提交参数的，如果有[FromBody] attribute 修饰参数，则需要以 application/json 形式提交参数</li>
<li>如果是复杂类型参数，调用 API 时，既可以以 x-www-form-urlencoded 方式，又可以以 application/json 方式提交数据</li>
</ol>
</li>
<li>对于 Get 请求，参数只能是简单类型，默认只能在 Query 中提交参数</li>
</ul>
<p>对于 .Net Core API: </p>
<ul>
<li>对于 Post 请求: <ol>
<li>如果是简单类型参数，调用 API 时，默认是在 Query 中提交参数的，如果有[FromBody] attribute 修饰参数，则需要以 application/json 形式提交参数。如果有[FromForm] attribute 修饰参数，则需要以 x-www-form-urlencoded 形式提交参数</li>
<li>如果是复杂类型，调用 API 时，默认应该以 application/json 形式提交数据，与使用[FromBody] attribute 修饰符一致。可以使用[FromForm] attribute 修饰参数，指定以 x-www-form-urlencoded 形式提交数据</li>
</ol>
</li>
<li>对于 Get 请求，参数只能是简单类型，只能以 Query 方式提交数据</li>
</ul>
<h3 id="Json-输出"><a href="#Json-输出" class="headerlink" title="Json 输出"></a>Json 输出</h3><p>在 .Net Core WebAPI 默认是 JSON 输出，而 .Net Framework WebAPI 默认是 XML 输出。如果希望 Framework 以 JSON 格式返回，则需要在 WebApiConfig.cs 的 Register 方法添加如下代码: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">config.Formatters.Remove(config.Formatters.XmlFormatter);<br>config.Formatters.JsonFormatter.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;<br>config.Formatters.JsonFormatter.SerializerSettings.ContractResolver = <span class="hljs-keyword">new</span> DefaultContractResolver();<br></code></pre></td></tr></table></figure>

<p>虽然 .Net Core WebAPI 默认是 JSON 输出，但是返回的对象是驼峰命名，如果希望与实体属性对应，需要在 ConfigureServices 方法添加如下代码: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">services.AddMvc()<br>.AddJsonOptions(options =&gt;<br>&#123;<br>    <span class="hljs-keyword">if</span> (options.SerializerSettings.ContractResolver <span class="hljs-keyword">is</span> DefaultContractResolver resolver)<br>    &#123;<br>        resolver.NamingStrategy = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="IIS-部署"><a href="#IIS-部署" class="headerlink" title="IIS 部署"></a>IIS 部署</h3><p>虚拟主机(新建一个网站就是一个虚拟主机): 可以为不同网站绑定同一个 IP 和端口，然后根据主机头(IIS8 上面改称为主机名)的不同来访问不同的站点。<br>IIS 也支持虚拟目录: 一个站点的网页的存储位置目录是固定的，而且结构和物理保存网页的磁盘路径相同。<br>例如: 默认网页的存储位置是 C:\inetpub\wwwroot，当访问 localhost 即访问 C:\inetpub\wwwroot 目录下的 index.html 文件，如果访问 localhost/dir1/ 则访问的是 C:\inetpub\wwwroot\dir1\index.html，访问 localhost/dir2 一般情况下是访问默认目录中的 dir2 目录下的 index.html 文件，但是此处的 dir2 目录指向的是 D:\web\ 目录(甚至是其他的服务器上)，这就是虚拟目录。</p>
<h3 id="Net-Core-部署配置"><a href="#Net-Core-部署配置" class="headerlink" title=".Net Core 部署配置"></a>.Net Core 部署配置</h3><ol>
<li>首先安装 .Net Core SDK</li>
<li>然后安装  AspNetCoreModule 托管模块: DotNetCore.x.x.x-WindowsHosting.exe</li>
<li>然后重启服务器或使用管理员命令行，依次执行: </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net stop was /y  // Windows Activation Service (WAS)<br>net start w3svc  // 万维网发布服务(W3SVC)<br></code></pre></td></tr></table></figure>

<p>部署出现 502.5 错误，一般是 SDK 版本或者托管模块安装有问题。</p>
<h3 id="React，Vue-单页面应用刷新-404-问题"><a href="#React，Vue-单页面应用刷新-404-问题" class="headerlink" title="React，Vue 单页面应用刷新 404 问题"></a>React，Vue 单页面应用刷新 404 问题</h3><p>原因是单页面应用内容只有一个(一般是 index.html)。这个页面中引入的 js 框架会根据当前访问的 url 去路由到相应的子页面组件(可以理解为页面片段)进行逻辑处理和页面渲染。web 站中并没访问的这个页面资源，所以出现 404。<br>IIS 中可以使用 URL 重写方案解决该问题: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&lt;system.webServer&gt;<br>    &lt;rewrite&gt;<br>        &lt;rules&gt;<br>            &lt;rule name=<span class="hljs-string">&quot;React Router Refresh&quot;</span> patternSyntax=<span class="hljs-string">&quot;ECMAScript&quot;</span> stopProcessing=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>                    &lt;match url=<span class="hljs-string">&quot;.*&quot;</span> /&gt;<br>                    &lt;conditions&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTP_METHOD&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^GET$&quot;</span> /&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTP_ACCEPT&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^text/html&quot;</span> /&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;REQUEST_FILENAME&#125;&quot;</span> matchType=<span class="hljs-string">&quot;IsFile&quot;</span> negate=<span class="hljs-string">&quot;true&quot;</span> /&gt;<br>                    &lt;/conditions&gt;<br>                    &lt;action type=<span class="hljs-string">&quot;Rewrite&quot;</span> url=<span class="hljs-string">&quot;/index.html&quot;</span> /&gt;<br>                &lt;/rule&gt;<br>        &lt;/rules&gt;<br>    &lt;/rewrite&gt;<br>&lt;/system.webServer&gt;<br></code></pre></td></tr></table></figure>

<p>Nginx 中使用: </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">try_files</span> $uri /index.html;<br></code></pre></td></tr></table></figure>

<h3 id="Net-的垃圾回收机制"><a href="#Net-的垃圾回收机制" class="headerlink" title=".Net 的垃圾回收机制"></a>.Net 的垃圾回收机制</h3><p>触发时机: </p>
<ul>
<li>物理内存吃紧</li>
<li>分配在托管堆上的内存超出阈值</li>
<li>手动调用 GC.Collect() 方法</li>
</ul>
<h3 id="HTTPS-重定向"><a href="#HTTPS-重定向" class="headerlink" title="HTTPS 重定向"></a>HTTPS 重定向</h3><p>需要 IIS 安装 URL 重写模块。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&lt;system.webServer&gt;<br>    &lt;rewrite&gt;<br>        &lt;rules&gt;<br>            &lt;rule name=<span class="hljs-string">&quot;REDIRECT TO HTTPS&quot;</span> stopProcessing=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>                &lt;match url=<span class="hljs-string">&quot;(.*)&quot;</span> /&gt;<br>                &lt;conditions&gt;<br>                    &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTPS&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^OFF$&quot;</span> /&gt;<br>                &lt;/conditions&gt;<br>                &lt;action type=<span class="hljs-string">&quot;Redirect&quot;</span> url=<span class="hljs-string">&quot;https://&#123;HTTP_HOST&#125;/&#123;R:1&#125;&quot;</span> /&gt;<br>            &lt;/rule&gt;<br>        &lt;/rules&gt;<br>    &lt;/rewrite&gt;<br>&lt;/system.webServer&gt;<br></code></pre></td></tr></table></figure>

<p>Nginx 中使用: </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$server_name$request_uri;<br></code></pre></td></tr></table></figure>

<h3 id="API-版本控制"><a href="#API-版本控制" class="headerlink" title="API 版本控制"></a>API 版本控制</h3><h4 id="Media-Type-进行版本控制"><a href="#Media-Type-进行版本控制" class="headerlink" title="Media Type 进行版本控制"></a>Media Type 进行版本控制</h4><ol>
<li>引入官方 Microsoft.AspNet.WebApi.Versioning package</li>
<li>在 WebApiConfig 的 Register 方法中添加如下代码: </li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">config.AddApiVersioning(options =&gt;<br>&#123;<br>    options.ApiVersionReader = <span class="hljs-keyword">new</span> MediaTypeApiVersionReader();<br>    options.AssumeDefaultVersionWhenUnspecified = <span class="hljs-literal">true</span>;<br>    options.ApiVersionSelector = <span class="hljs-keyword">new</span> CurrentImplementationApiVersionSelector(options);<br>&#125;);<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>在类上使用 [ApiVersion(“1.0”)] Attribute</li>
</ol>
<p>调用 API 时，我们就在 Content-Type 或 Accept 中用 application/xxx;v=1.0 使用 1.0 版本的 API。</p>
<h4 id="URL-路径进行版本控制"><a href="#URL-路径进行版本控制" class="headerlink" title="URL 路径进行版本控制"></a>URL 路径进行版本控制</h4><p>API 版本控制的另一种常见方法是使用 URL 路径。</p>
<ol>
<li>引入官方 Microsoft.AspNet.WebApi.Versioning package</li>
<li>在 WebApiConfig 的 Register 方法中添加如下代码: </li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> constraintResolver = <span class="hljs-keyword">new</span> DefaultInlineConstraintResolver()<br>&#123;<br>    ConstraintMap =<br>    &#123;<br>        [<span class="hljs-meta"><span class="hljs-meta-string">&quot;apiVersion&quot;</span></span>] = <span class="hljs-keyword">typeof</span>(ApiVersionRouteConstraint)<br>    &#125;<br>&#125;;<br>configuration.MapHttpAttributeRoutes(constraintResolver);<br>configuration.AddApiVersioning();<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>在类上使用如下特性: </li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">ApiVersion( <span class="hljs-meta-string">&quot;2.0&quot;</span> )</span>]<br>[<span class="hljs-meta">Route( <span class="hljs-meta-string">&quot;api/v&#123;version:apiVersion&#125;/foo&quot;</span> )</span>]<br></code></pre></td></tr></table></figure>

<p>调用 API 时，请求 <a target="_blank" rel="noopener" href="https://localhost/api/v2/foo">https://localhost/api/v2/foo</a> 即可。</p>
<h3 id="AutoMapper-的使用"><a href="#AutoMapper-的使用" class="headerlink" title="AutoMapper 的使用"></a>AutoMapper 的使用</h3><ol>
<li>NuGet 安装 AutoMapper.Extensions.Microsoft.DependencyInjection 依赖</li>
<li>在 ConfigureServices 方法中 services.AddMvc() 之后添加 services.AddAutoMapper();</li>
<li>自定义类并继承自 Profile</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MappingProfile</span> : <span class="hljs-title">Profile</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MappingProfile</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//直接映射</span><br>        CreateMap&lt;Simple, SimpleDTO&gt;().ReverseMap();<br><br>        <span class="hljs-comment">//自定义对应属性映射</span><br>        CreateMap&lt;Simple, SimpleDTO&gt;().ForMember(dest =&gt; dest.属性,<br>            opts =&gt; opts.MapFrom(<br>                src =&gt; src.属性操作<br>            )).ReverseMap();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>在控制器类依赖注入 IMapper 对象</li>
<li>在适当位置调用 var dest = mapper.Map<DestType>(srcObject); 即可</li>
</ol>
<h3 id="Net-Core-依赖注入-Context-对象"><a href="#Net-Core-依赖注入-Context-对象" class="headerlink" title=".Net Core 依赖注入 Context 对象"></a>.Net Core 依赖注入 Context 对象</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">services.AddDbContext&lt;CustomContext&gt;(options =&gt;<br>&#123;<br>    options.UseSqlServer(Configuration.GetConnectionString(<span class="hljs-string">&quot;DefaultConnection&quot;</span>));<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="Net-Core-依赖注入配置文件"><a href="#Net-Core-依赖注入配置文件" class="headerlink" title=".Net Core 依赖注入配置文件"></a>.Net Core 依赖注入配置文件</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">services.Configure&lt;CustomSetting&gt;(Configuration.GetSection(<span class="hljs-keyword">nameof</span>(CustomSetting)));<br></code></pre></td></tr></table></figure>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><hr>
<h3 id="SQLServer-连接字符串写法"><a href="#SQLServer-连接字符串写法" class="headerlink" title="SQLServer 连接字符串写法"></a>SQLServer 连接字符串写法</h3><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;ConnectionStrings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;ConnectionString&quot;</span>: <span class="hljs-string">&quot;Persist Security Info=False;User ID=xxxxxx;Password=xxxxxx;Initial Catalog=[db name];Server=[ip or domain]&quot;</span><br>  &#125;<br></code></pre></td></tr></table></figure>

<p>其中: </p>
<ol>
<li>Persist Security Info=False 表示使用账户密码连接数据库</li>
<li>User ID 表示用户名</li>
<li>Password 表示密码</li>
<li>Initial Catalog 表示所连接的数据库</li>
<li>Server 表示数据库所在服务器，可以使用 IP 或域名</li>
</ol>
<h2 id="Visual-Studio-技巧"><a href="#Visual-Studio-技巧" class="headerlink" title="Visual Studio 技巧"></a>Visual Studio 技巧</h2><hr>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> (未实现)……</span><br><br><span class="hljs-comment">//UNDONE:(没有做完)……</span><br><br><span class="hljs-comment">//HACK：(修改)……</span><br></code></pre></td></tr></table></figure>

<p>之后，我们可以在 “视图-任务列表” 使其显示所有带有特殊注释的代码位置。</p>
<h3 id="选中代码块"><a href="#选中代码块" class="headerlink" title="选中代码块"></a>选中代码块</h3><p>我们使用 Alt + Shift + ] 可以直接选中光标所在代码的代码块。</p>
<h3 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h3><ol>
<li>Alt + 鼠标拖选</li>
<li>Ctrl + Alt + 鼠标点选</li>
</ol>
<h3 id="使用的-C-语言版本"><a href="#使用的-C-语言版本" class="headerlink" title="使用的 C# 语言版本"></a>使用的 C# 语言版本</h3><p>我们可以通过编辑 *.csproj 文件，在 PropertyGroup 内添加 LangVersion 元素，值为 latest 即可: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&lt;PropertyGroup&gt;<br>    ...<br>    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;<br>&lt;/PropertyGroup&gt;<br></code></pre></td></tr></table></figure></p></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/C%20Sharp(%E4%B8%80)/" title="C Sharp(一)"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: C Sharp(一)</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/React(%E4%B8%89)/" title="React(三)">下一篇: React(三)&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>