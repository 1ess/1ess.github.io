

<!DOCTYPE html>
<html lang="zh-tw" xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head>
    <title>杂(一) - A Sort Of A Blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Stephen Chang">
<meta name="description" content="这一篇，记录关于 .Net 和 .Net Core 的一些零碎的知识点，随时更新。
ASP.Net WebAPI 和 WebMVC 问题
跨域
针对 .N...">
<meta name="keywords" content="">

<link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml">

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?24582546">

<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons"/>
</noscript>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="https://1ess.github.io">
                Home
            </a>
            
            <a class="a-block drawer-menu-item false" href="/archives">
                Archive
            </a>
            

            
            

            
            <a class="a-block drawer-menu-item" href="/atom.xml">
                RSS
            </a>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            A Sort Of A Blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">A Sort Of A Blog</div>
        <div class="single-column-header-subtitle">旧游无处不堪寻，无寻处，惟有少年心</div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            A Sort Of A Blog
        </div>
        <div class="nav-subtitle">
            旧游无处不堪寻，无寻处，惟有少年心
        </div>
    </a>

    <div class="nav-link-list">
        
        <a class="a-block no-tint nav-link-item false" href="/archives">
            Archive
        </a>
        

        
        

        
        <a class="a-block no-tint nav-link-item" href="/atom.xml">
            RSS
        </a>
        
    </div>

    
    <div class="nav-footer">
        &copy; 2022 <a href="https://1ess.github.io">A Sort Of A Blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>



<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper"
                 style="background-image: url('https://cdn.jsdelivr.net/gh/1ess/cdn/blogImg/Blog46.jpg')">
                <div class="post-title">
                    杂(一)
                    <div class="post-meta">
                        <time datetime="2018-10-11T00:00:00.000Z" itemprop="datePublished">
                            2018-10-11
                        </time>&nbsp;
                        
    
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <p>这一篇，记录关于 .Net 和 .Net Core 的一些零碎的知识点，随时更新。</p>
<h2 id="ASP-Net-WebAPI-和-WebMVC-问题"><a href="#ASP-Net-WebAPI-和-WebMVC-问题" class="headerlink" title="ASP.Net WebAPI 和 WebMVC 问题"></a>ASP.Net WebAPI 和 WebMVC 问题</h2><hr>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li>针对 .NET Framework MVC 跨域，只需要在 web.config 中添加如下的内容即可: </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">system.webServer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">httpProtocol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">customHeaders</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;*&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GET, POST, PUT, DELETE, OPTIONS&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">customHeaders</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">httpProtocol</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">system.webServer</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>针对 .NET Framework Web API，除了上面这样的设置，还需要添加一个特殊的设计，就是为每个 APIController 添加一个 OPTIONS 方法，返回 null 即可: </li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Options</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// HTTP 200 response with empty body</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>针对 .Net Core 跨域，需要在 Startup.cs 文件的 ConfigureServices 方法中添加以下代码: </li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//允许某些源</span><br>services.AddCors(options =&gt; &#123;<br>    options.AddPolicy(<span class="hljs-string">&quot;AllowCors&quot;</span>, policy =&gt; &#123;<br>        <span class="hljs-comment">// 多个可以用 `,` 隔开</span><br>        policy.WithOrigins(<span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<span class="hljs-string">&quot;http://127.0.0.1&quot;</span>)<br>                  .AllowAnyHeader()<br>                  .AllowAnyMethod()<br>                  .AllowCredentials();<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>如果是所有方法都允许跨域，就在 Configure 方法中还需要添加以下代码: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">app.UseCors(<span class="hljs-string">&quot;AllowCors&quot;</span>);<span class="hljs-comment">//必须位于 UserMvc 之前 </span><br>app.UseMvc();<br></code></pre></td></tr></table></figure>

<p>如果是某些方法允许跨域，就在该 Controller 添加如下代码: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Cors;<br><br>[<span class="hljs-meta">EnableCors(<span class="hljs-meta-string">&quot;AllowCors&quot;</span>)</span>] <span class="hljs-comment">//可实现指定某个 controller 或者 action 跨域</span><br></code></pre></td></tr></table></figure>

<h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>对于 .Net Framework MVC: </p>
<ul>
<li>对于 Post 请求，不论是简单类型还是复杂类型，调用 API 时，都会在 Body 中提交数据，以 x-www-form-urlencoded 和 application/json 两种形式提交都可以在服务端获取到。简单类型直接作为 key，复杂类型属性作为 key</li>
<li>对于 Get 请求，不论是简单类型还是复杂类型，调用 API 时，都会在 Query 中提交数据。简单类型直接拼接，复杂类型属性拼接</li>
</ul>
<p>对于 .Net Core MVC: </p>
<ul>
<li>对于 Post 请求，不论基本类型还是复杂类型参数，调用 API 时，既可以在 Query 中提交参数，也可以使用 x-www-form-urlencoded 表单形式提交参数，在服务端都可以接收到。对于复杂类型，我们也可以指定[FromBody] attribute，使得该复杂类型可以以 application/json Json 形式提交</li>
<li>对于 Get 请求，参数只能是简单类型，默认只能在 Query 中提交参数。我们也不该在 Get 请求使用复杂类型放在 Body 中提交</li>
</ul>
<p>对于 .Net Framework API: </p>
<ul>
<li>对于 Post 请求: <ol>
<li>如果是简单类型参数，调用 API 时，默认是在 Query 中提交参数的，如果有[FromBody] attribute 修饰参数，则需要以 application/json 形式提交参数</li>
<li>如果是复杂类型参数，调用 API 时，既可以以 x-www-form-urlencoded 方式，又可以以 application/json 方式提交数据</li>
</ol>
</li>
<li>对于 Get 请求，参数只能是简单类型，默认只能在 Query 中提交参数</li>
</ul>
<p>对于 .Net Core API: </p>
<ul>
<li>对于 Post 请求: <ol>
<li>如果是简单类型参数，调用 API 时，默认是在 Query 中提交参数的，如果有[FromBody] attribute 修饰参数，则需要以 application/json 形式提交参数。如果有[FromForm] attribute 修饰参数，则需要以 x-www-form-urlencoded 形式提交参数</li>
<li>如果是复杂类型，调用 API 时，默认应该以 application/json 形式提交数据，与使用[FromBody] attribute 修饰符一致。可以使用[FromForm] attribute 修饰参数，指定以 x-www-form-urlencoded 形式提交数据</li>
</ol>
</li>
<li>对于 Get 请求，参数只能是简单类型，只能以 Query 方式提交数据</li>
</ul>
<h3 id="Json-输出"><a href="#Json-输出" class="headerlink" title="Json 输出"></a>Json 输出</h3><p>在 .Net Core WebAPI 默认是 JSON 输出，而 .Net Framework WebAPI 默认是 XML 输出。如果希望 Framework 以 JSON 格式返回，则需要在 WebApiConfig.cs 的 Register 方法添加如下代码: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">config.Formatters.Remove(config.Formatters.XmlFormatter);<br>config.Formatters.JsonFormatter.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;<br>config.Formatters.JsonFormatter.SerializerSettings.ContractResolver = <span class="hljs-keyword">new</span> DefaultContractResolver();<br></code></pre></td></tr></table></figure>

<p>虽然 .Net Core WebAPI 默认是 JSON 输出，但是返回的对象是驼峰命名，如果希望与实体属性对应，需要在 ConfigureServices 方法添加如下代码: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">services.AddMvc()<br>.AddJsonOptions(options =&gt;<br>&#123;<br>    <span class="hljs-keyword">if</span> (options.SerializerSettings.ContractResolver <span class="hljs-keyword">is</span> DefaultContractResolver resolver)<br>    &#123;<br>        resolver.NamingStrategy = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="IIS-部署"><a href="#IIS-部署" class="headerlink" title="IIS 部署"></a>IIS 部署</h3><p>虚拟主机(新建一个网站就是一个虚拟主机): 可以为不同网站绑定同一个 IP 和端口，然后根据主机头(IIS8 上面改称为主机名)的不同来访问不同的站点。<br>IIS 也支持虚拟目录: 一个站点的网页的存储位置目录是固定的，而且结构和物理保存网页的磁盘路径相同。<br>例如: 默认网页的存储位置是 C:\inetpub\wwwroot，当访问 localhost 即访问 C:\inetpub\wwwroot 目录下的 index.html 文件，如果访问 localhost/dir1/ 则访问的是 C:\inetpub\wwwroot\dir1\index.html，访问 localhost/dir2 一般情况下是访问默认目录中的 dir2 目录下的 index.html 文件，但是此处的 dir2 目录指向的是 D:\web\ 目录(甚至是其他的服务器上)，这就是虚拟目录。</p>
<h3 id="Net-Core-部署配置"><a href="#Net-Core-部署配置" class="headerlink" title=".Net Core 部署配置"></a>.Net Core 部署配置</h3><ol>
<li>首先安装 .Net Core SDK</li>
<li>然后安装  AspNetCoreModule 托管模块: DotNetCore.x.x.x-WindowsHosting.exe</li>
<li>然后重启服务器或使用管理员命令行，依次执行: </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net stop was /y  // Windows Activation Service (WAS)<br>net start w3svc  // 万维网发布服务(W3SVC)<br></code></pre></td></tr></table></figure>

<p>部署出现 502.5 错误，一般是 SDK 版本或者托管模块安装有问题。</p>
<h3 id="React，Vue-单页面应用刷新-404-问题"><a href="#React，Vue-单页面应用刷新-404-问题" class="headerlink" title="React，Vue 单页面应用刷新 404 问题"></a>React，Vue 单页面应用刷新 404 问题</h3><p>原因是单页面应用内容只有一个(一般是 index.html)。这个页面中引入的 js 框架会根据当前访问的 url 去路由到相应的子页面组件(可以理解为页面片段)进行逻辑处理和页面渲染。web 站中并没访问的这个页面资源，所以出现 404。<br>IIS 中可以使用 URL 重写方案解决该问题: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&lt;system.webServer&gt;<br>    &lt;rewrite&gt;<br>        &lt;rules&gt;<br>            &lt;rule name=<span class="hljs-string">&quot;React Router Refresh&quot;</span> patternSyntax=<span class="hljs-string">&quot;ECMAScript&quot;</span> stopProcessing=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>                    &lt;match url=<span class="hljs-string">&quot;.*&quot;</span> /&gt;<br>                    &lt;conditions&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTP_METHOD&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^GET$&quot;</span> /&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTP_ACCEPT&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^text/html&quot;</span> /&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;REQUEST_FILENAME&#125;&quot;</span> matchType=<span class="hljs-string">&quot;IsFile&quot;</span> negate=<span class="hljs-string">&quot;true&quot;</span> /&gt;<br>                    &lt;/conditions&gt;<br>                    &lt;action type=<span class="hljs-string">&quot;Rewrite&quot;</span> url=<span class="hljs-string">&quot;/index.html&quot;</span> /&gt;<br>                &lt;/rule&gt;<br>        &lt;/rules&gt;<br>    &lt;/rewrite&gt;<br>&lt;/system.webServer&gt;<br></code></pre></td></tr></table></figure>

<p>Nginx 中使用: </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">try_files</span> $uri /index.html;<br></code></pre></td></tr></table></figure>

<h3 id="Net-的垃圾回收机制"><a href="#Net-的垃圾回收机制" class="headerlink" title=".Net 的垃圾回收机制"></a>.Net 的垃圾回收机制</h3><p>触发时机: </p>
<ul>
<li>物理内存吃紧</li>
<li>分配在托管堆上的内存超出阈值</li>
<li>手动调用 GC.Collect() 方法</li>
</ul>
<h3 id="HTTPS-重定向"><a href="#HTTPS-重定向" class="headerlink" title="HTTPS 重定向"></a>HTTPS 重定向</h3><p>需要 IIS 安装 URL 重写模块。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&lt;system.webServer&gt;<br>    &lt;rewrite&gt;<br>        &lt;rules&gt;<br>            &lt;rule name=<span class="hljs-string">&quot;REDIRECT TO HTTPS&quot;</span> stopProcessing=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>                &lt;match url=<span class="hljs-string">&quot;(.*)&quot;</span> /&gt;<br>                &lt;conditions&gt;<br>                    &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTPS&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^OFF$&quot;</span> /&gt;<br>                &lt;/conditions&gt;<br>                &lt;action type=<span class="hljs-string">&quot;Redirect&quot;</span> url=<span class="hljs-string">&quot;https://&#123;HTTP_HOST&#125;/&#123;R:1&#125;&quot;</span> /&gt;<br>            &lt;/rule&gt;<br>        &lt;/rules&gt;<br>    &lt;/rewrite&gt;<br>&lt;/system.webServer&gt;<br></code></pre></td></tr></table></figure>

<p>Nginx 中使用: </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$server_name$request_uri;<br></code></pre></td></tr></table></figure>

<h3 id="API-版本控制"><a href="#API-版本控制" class="headerlink" title="API 版本控制"></a>API 版本控制</h3><h4 id="Media-Type-进行版本控制"><a href="#Media-Type-进行版本控制" class="headerlink" title="Media Type 进行版本控制"></a>Media Type 进行版本控制</h4><ol>
<li>引入官方 Microsoft.AspNet.WebApi.Versioning package</li>
<li>在 WebApiConfig 的 Register 方法中添加如下代码: </li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">config.AddApiVersioning(options =&gt;<br>&#123;<br>    options.ApiVersionReader = <span class="hljs-keyword">new</span> MediaTypeApiVersionReader();<br>    options.AssumeDefaultVersionWhenUnspecified = <span class="hljs-literal">true</span>;<br>    options.ApiVersionSelector = <span class="hljs-keyword">new</span> CurrentImplementationApiVersionSelector(options);<br>&#125;);<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>在类上使用 [ApiVersion(“1.0”)] Attribute</li>
</ol>
<p>调用 API 时，我们就在 Content-Type 或 Accept 中用 application/xxx;v=1.0 使用 1.0 版本的 API。</p>
<h4 id="URL-路径进行版本控制"><a href="#URL-路径进行版本控制" class="headerlink" title="URL 路径进行版本控制"></a>URL 路径进行版本控制</h4><p>API 版本控制的另一种常见方法是使用 URL 路径。</p>
<ol>
<li>引入官方 Microsoft.AspNet.WebApi.Versioning package</li>
<li>在 WebApiConfig 的 Register 方法中添加如下代码: </li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> constraintResolver = <span class="hljs-keyword">new</span> DefaultInlineConstraintResolver()<br>&#123;<br>    ConstraintMap =<br>    &#123;<br>        [<span class="hljs-meta"><span class="hljs-meta-string">&quot;apiVersion&quot;</span></span>] = <span class="hljs-keyword">typeof</span>(ApiVersionRouteConstraint)<br>    &#125;<br>&#125;;<br>configuration.MapHttpAttributeRoutes(constraintResolver);<br>configuration.AddApiVersioning();<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>在类上使用如下特性: </li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">ApiVersion( <span class="hljs-meta-string">&quot;2.0&quot;</span> )</span>]<br>[<span class="hljs-meta">Route( <span class="hljs-meta-string">&quot;api/v&#123;version:apiVersion&#125;/foo&quot;</span> )</span>]<br></code></pre></td></tr></table></figure>

<p>调用 API 时，请求 <a target="_blank" rel="noopener" href="https://localhost/api/v2/foo">https://localhost/api/v2/foo</a> 即可。</p>
<h3 id="AutoMapper-的使用"><a href="#AutoMapper-的使用" class="headerlink" title="AutoMapper 的使用"></a>AutoMapper 的使用</h3><ol>
<li>NuGet 安装 AutoMapper.Extensions.Microsoft.DependencyInjection 依赖</li>
<li>在 ConfigureServices 方法中 services.AddMvc() 之后添加 services.AddAutoMapper();</li>
<li>自定义类并继承自 Profile</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MappingProfile</span> : <span class="hljs-title">Profile</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MappingProfile</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//直接映射</span><br>        CreateMap&lt;Simple, SimpleDTO&gt;().ReverseMap();<br><br>        <span class="hljs-comment">//自定义对应属性映射</span><br>        CreateMap&lt;Simple, SimpleDTO&gt;().ForMember(dest =&gt; dest.属性,<br>            opts =&gt; opts.MapFrom(<br>                src =&gt; src.属性操作<br>            )).ReverseMap();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>在控制器类依赖注入 IMapper 对象</li>
<li>在适当位置调用 var dest = mapper.Map<DestType>(srcObject); 即可</li>
</ol>
<h3 id="Net-Core-依赖注入-Context-对象"><a href="#Net-Core-依赖注入-Context-对象" class="headerlink" title=".Net Core 依赖注入 Context 对象"></a>.Net Core 依赖注入 Context 对象</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">services.AddDbContext&lt;CustomContext&gt;(options =&gt;<br>&#123;<br>    options.UseSqlServer(Configuration.GetConnectionString(<span class="hljs-string">&quot;DefaultConnection&quot;</span>));<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="Net-Core-依赖注入配置文件"><a href="#Net-Core-依赖注入配置文件" class="headerlink" title=".Net Core 依赖注入配置文件"></a>.Net Core 依赖注入配置文件</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">services.Configure&lt;CustomSetting&gt;(Configuration.GetSection(<span class="hljs-keyword">nameof</span>(CustomSetting)));<br></code></pre></td></tr></table></figure>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><hr>
<h3 id="SQLServer-连接字符串写法"><a href="#SQLServer-连接字符串写法" class="headerlink" title="SQLServer 连接字符串写法"></a>SQLServer 连接字符串写法</h3><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;ConnectionStrings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;ConnectionString&quot;</span>: <span class="hljs-string">&quot;Persist Security Info=False;User ID=xxxxxx;Password=xxxxxx;Initial Catalog=[db name];Server=[ip or domain]&quot;</span><br>  &#125;<br></code></pre></td></tr></table></figure>

<p>其中: </p>
<ol>
<li>Persist Security Info=False 表示使用账户密码连接数据库</li>
<li>User ID 表示用户名</li>
<li>Password 表示密码</li>
<li>Initial Catalog 表示所连接的数据库</li>
<li>Server 表示数据库所在服务器，可以使用 IP 或域名</li>
</ol>
<h2 id="Visual-Studio-技巧"><a href="#Visual-Studio-技巧" class="headerlink" title="Visual Studio 技巧"></a>Visual Studio 技巧</h2><hr>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> (未实现)……</span><br><br><span class="hljs-comment">//UNDONE:(没有做完)……</span><br><br><span class="hljs-comment">//HACK：(修改)……</span><br></code></pre></td></tr></table></figure>

<p>之后，我们可以在 “视图-任务列表” 使其显示所有带有特殊注释的代码位置。</p>
<h3 id="选中代码块"><a href="#选中代码块" class="headerlink" title="选中代码块"></a>选中代码块</h3><p>我们使用 Alt + Shift + ] 可以直接选中光标所在代码的代码块。</p>
<h3 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h3><ol>
<li>Alt + 鼠标拖选</li>
<li>Ctrl + Alt + 鼠标点选</li>
</ol>
<h3 id="使用的-C-语言版本"><a href="#使用的-C-语言版本" class="headerlink" title="使用的 C# 语言版本"></a>使用的 C# 语言版本</h3><p>我们可以通过编辑 *.csproj 文件，在 PropertyGroup 内添加 LangVersion 元素，值为 latest 即可: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&lt;PropertyGroup&gt;<br>    ...<br>    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;<br>&lt;/PropertyGroup&gt;<br></code></pre></td></tr></table></figure>
                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/C%20Sharp(%E4%B8%80)/">
        Previous post<br>C Sharp(一)
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/React(%E4%B8%89)/">
        Next post<br>React(三)
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    &copy; 2022 <a href="https://1ess.github.io">A Sort Of A Blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js"
        integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js"
        integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"
        integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js"
        integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?92226826"></script>



</body>
</html>
