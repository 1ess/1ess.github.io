

<!DOCTYPE html>
<html lang="zh-tw" xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head>
    <title>C Sharp(四) - A Sort Of A Blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Stephen Chang">
<meta name="description" content="这一篇，我们讲讲 C# 中关于继承的相关知识。
继承
通过继承我们可以定义新的派生类(derived class)，来对基类(base class)进行扩...">
<meta name="keywords" content="">

<link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml">

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?96296552">

<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons"/>
</noscript>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="https://1ess.github.io">
                Home
            </a>
            
            <a class="a-block drawer-menu-item false" href="/archives">
                Archive
            </a>
            

            
            

            
            <a class="a-block drawer-menu-item" href="/atom.xml">
                RSS
            </a>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            A Sort Of A Blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">A Sort Of A Blog</div>
        <div class="single-column-header-subtitle">旧游无处不堪寻，无寻处，惟有少年心</div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            A Sort Of A Blog
        </div>
        <div class="nav-subtitle">
            旧游无处不堪寻，无寻处，惟有少年心
        </div>
    </a>

    <div class="nav-link-list">
        
        <a class="a-block no-tint nav-link-item false" href="/archives">
            Archive
        </a>
        

        
        

        
        <a class="a-block no-tint nav-link-item" href="/atom.xml">
            RSS
        </a>
        
    </div>

    
    <div class="nav-footer">
        &copy; 2022 <a href="https://1ess.github.io">A Sort Of A Blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>



<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper"
                 style="background-image: url('https://cdn.jsdelivr.net/gh/1ess/cdn/blogImg/Blog50.jpg')">
                <div class="post-title">
                    C Sharp(四)
                    <div class="post-meta">
                        <time datetime="2018-10-22T00:00:00.000Z" itemprop="datePublished">
                            2018-10-22
                        </time>&nbsp;
                        
    
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <p>这一篇，我们讲讲 C# 中关于继承的相关知识。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr>
<p>通过继承我们可以定义新的派生类(derived class)，来对基类(base class)进行扩展。<br>派生类的成员包括: </p>
<ul>
<li>本身声明的成员</li>
<li>基类的成员</li>
</ul>
<p>注意: 派生类不能删除它所继承的任何成员。</p>
<p>要声明一个派生类，需要在类名后跟一个冒号，然后跟基类名。与 Objective-C 的继承声明相同。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>     <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>继承的成员可以被访问，就像他们是派生类本身声明的一样: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;base class field&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Base class -- Method1:    &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field2 = <span class="hljs-string">&quot;derived class&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Derived class -- Method2:    &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        OtherClass oc = <span class="hljs-keyword">new</span> OtherClass();<br><br>        oc.Method1(oc.Field1);<br>        oc.Method1(oc.Field2);        <br>        oc.Method2(oc.Field1);<br>        oc.Method2(oc.Field2);        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了 object，所有的类都是派生类，object 是唯一的非派生类，他是继承层次结构的基础。<br>没有基类声明的类隐式直接派生自 object 类。<br>C# 中的继承是单继承，与 Objective-C、JavaScript 一样。<br>通常我们称一个类为派生类时，我们是说他直接派生自某个类而不是 object。</p>
<h3 id="屏蔽基类成员"><a href="#屏蔽基类成员" class="headerlink" title="屏蔽基类成员"></a>屏蔽基类成员</h3><p>我们虽然不能删除基类的任何成员，但是我们可以使用与基类名相同名称的成员来屏蔽基类成员。<br>在派生类屏蔽基类成员的要点如下: </p>
<ul>
<li>要屏蔽一个数据成员，需要声明一个新的相同类型的同名成员</li>
<li>要屏蔽一个函数成员，需要在派生类中声明带有相同签名的函数成员</li>
<li>要然编译器知道我们故意屏蔽基类成员，需要使用 new 修饰符。否则屏蔽成员会报警告</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;SomeClass Field1&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;SomeClass.Method1: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;OtherClass Field1&quot;</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;OtherClass.Method1: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        OtherClass oc = <span class="hljs-keyword">new</span> OtherClass();<br>        oc.Method1(oc.Field1);  <span class="hljs-comment">//OtherClass.Method1: OtherClass Field1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基类访问"><a href="#基类访问" class="headerlink" title="基类访问"></a>基类访问</h3><p>如果要在派生类中需要访问被屏蔽的成员，可以使用基类访问表达式来访问隐藏的成员。<br>基类访问表达式由关键字 base 后跟点操作符加要访问的成员: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>, <span class="hljs-keyword">base</span>.Field1);<br></code></pre></td></tr></table></figure>

<p>如果程序需要经常使用这个特性，可能需要重新设计了。</p>
<h3 id="使用基类的引用"><a href="#使用基类的引用" class="headerlink" title="使用基类的引用"></a>使用基类的引用</h3><p>派生类的引用指向整个类结构，包括基类部分。<br>如果有一个派生类引用，我们就可以获取对象基类部分的引用(使用类型转换): </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is base class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is derived class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        DerivedClass dc = <span class="hljs-keyword">new</span> DerivedClass();<br>        BaseClass bc = (BaseClass)dc;<br>        dc.Print();  <span class="hljs-comment">// derived class print</span><br>        bc.Print();  <span class="hljs-comment">// base class print</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过类型转换而来的”基类”，不能”看”到派生类的部分。</p>
<h3 id="虚方法和覆写方法"><a href="#虚方法和覆写方法" class="headerlink" title="虚方法和覆写方法"></a>虚方法和覆写方法</h3><p>虚方法可以使基类的引用访问”提升”至派生类，只需满足如下条件: </p>
<ul>
<li>派生类的方法和基类的方法的签名和返回值都一致</li>
<li>基类方法使用 virtual 标注</li>
<li>派生类方法使用 override 标注</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is base class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is derived class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        DerivedClass dc = <span class="hljs-keyword">new</span> DerivedClass();<br>        BaseClass bc = (BaseClass)dc;<br>        dc.Print();  <span class="hljs-comment">// derived class print</span><br>        bc.Print();  <span class="hljs-comment">// derived class print</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于 virtual 和 override 修饰符的重要信息如下: </p>
<ul>
<li>覆写和被覆写的方法必须具有相同的访问性</li>
<li>不能覆写 static 方法和非虚方法</li>
<li>方法、属性、索引器和事件可以被声明为 virtual 和 override</li>
</ul>
<p>覆写方法可以在继承的任何层次出现，方法的调用会沿着派生层次一直追溯到标记为 override 的最高派生类。</p>
<p>注意: Objective-C 没有虚方法的概念，Objective-C 中所有的方法都是虚方法: </p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Animal</span>: <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-keyword">void</span>)sing;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Animal</span></span><br>- (<span class="hljs-keyword">void</span>)sing &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;animal sing&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Dog</span>: <span class="hljs-title">Animal</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Dog</span></span><br>- (<span class="hljs-keyword">void</span>)sing &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;dog sing&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)main &#123;<br>    Dog *dog = [[Dog alloc] init];<br>    Animal *animal = dog;<br>    [dog sing];  <span class="hljs-comment">//&quot;dog sing&quot;</span><br>    [animal sing]; <span class="hljs-comment">//&quot;dog sing&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>虚方法是面向对象中多态的基础，多态性又叫动态绑定、推迟绑定或运行期绑定。是允许你将父对象设置成为一个或更多的它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</strong></p>
<h3 id="构造函数的执行"><a href="#构造函数的执行" class="headerlink" title="构造函数的执行"></a>构造函数的执行</h3><p>派生类对象有一部分就是基类对象: </p>
<ul>
<li>要创建对象的基类部分，需要隐式的调用基类的某个构造函数作为实例创建的一部分</li>
<li>每个类在执行自己的构造函数之前要执行基类的构造函数</li>
</ul>
<p><strong>默认情况，构造对象时，将调用基类的无参构造函数</strong>，如果希望派生类调用的是有参构造的话，就需要构造函数初始化语句。<br>有两种形式的构造函数初始化语句: </p>
<ul>
<li>使用 base 并指明使用哪一个基类的构造函数</li>
<li>使用 this 并指明使用哪一个当前类的构造函数</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> MyDerivedClass<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">string</span> s</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">base</span>(<span class="hljs-params">x, s</span>)</span> <br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，我们可以需要在构造函数中使用当前类的其他构造: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> a;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        a = <span class="hljs-number">10</span>;<br>        b = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">this</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        FirstName = firstName;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> lastName</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">this</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        LastName = lastName;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="类的访问修饰符"><a href="#类的访问修饰符" class="headerlink" title="类的访问修饰符"></a>类的访问修饰符</h3><p>类的可访问修饰符有两种: public 和 internal: </p>
<ul>
<li>标记为 public 的类可以被系统内任何程序集访问</li>
<li>标记为 internal 的类只能被该类所在的程序集访问</li>
</ul>
<p>注意: internal 是类的默认访问级别。</p>
<h3 id="成员的访问修饰符"><a href="#成员的访问修饰符" class="headerlink" title="成员的访问修饰符"></a>成员的访问修饰符</h3><p>成员的默认的访问级别是 private，并且成员不能比他的类有更高的可访问性。</p>
<ul>
<li>private 成员只能被他自己的类访问，不能被其他类访问，包括继承的类。但能被嵌套在他的类中的类访问</li>
<li>protected 成员访问级别与 private 一样，只是它允许派生自他的类访问该成员</li>
<li>internal 成员只对程序集内部可见</li>
<li>protected internal 成员对所有继承自他的类可以访问，也可以对他所在的程序集可访问(注意是并集而不是交集)</li>
</ul>
<h3 id="抽象成员和抽象类"><a href="#抽象成员和抽象类" class="headerlink" title="抽象成员和抽象类"></a>抽象成员和抽象类</h3><p>抽象成员是指被设计为被覆写的函数成员，有以下特征: </p>
<ul>
<li>必须是函数成员</li>
<li>必须是由 abstract 修饰符修饰</li>
<li>没有方法实现代码块</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span>;<br></code></pre></td></tr></table></figure>

<p>抽象成员只能在抽象类中声明，一共有 4 中类型的成员可以声明为抽象: </p>
<ul>
<li>方法</li>
<li>属性</li>
<li>事件</li>
<li>索引</li>
</ul>
<p>派生类重写抽象成员要是有 override 标记: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;override abstract method&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>抽象类就是被设计为被继承的类，抽象类只能作为其他类的基类: </p>
<ul>
<li>我们不能创建抽象类的实例</li>
<li>抽象类也使用 abstract 修饰符修饰</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyAbstractClass</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意: </p>
<ul>
<li>抽象类中可以有非抽象成员</li>
<li>抽象类可以派生自其他抽象类</li>
<li>任何派生自抽象类的类必须实现所有抽象成员，除非她本身也是派生类</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassB</span> : <span class="hljs-title">ClassA</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>密封类与抽象类相反，他不能被继承，使用 sealed 修饰。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySealedClass</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><ul>
<li>静态类中所有成员都是静态的</li>
<li>静态类被标记为 static</li>
<li>静态类是隐式密封的，也就是说，他不能被继承</li>
<li>它可以有一个静态构造函数，但不能有实例构造函数</li>
</ul>
<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>如果我们不能修改某个类的源文件，而希望给该类添加方法，可以使用扩展方法: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//必须是静态类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExtendMyClass</span><br>&#123;<br>    <span class="hljs-comment">//必须声明为 public 和 static 方法，参数传入要扩展的类的实例，并且前面加 this 关键字</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Avg</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> MyBaseClass bc</span>)</span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="C-命名约定"><a href="#C-命名约定" class="headerlink" title="C# 命名约定"></a>C# 命名约定</h3><ul>
<li>帕斯卡命名: 命名空间、类名、方法、属性和公共字段</li>
<li>驼峰命名: 私有变量和形参</li>
<li>下划线加驼峰: 私有和受保护字段</li>
</ul>

                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/C%20Sharp(%E4%BA%94)/">
        Previous post<br>C Sharp(五)
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/C%20Sharp(%E4%B8%89)/">
        Next post<br>C Sharp(三)
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    &copy; 2022 <a href="https://1ess.github.io">A Sort Of A Blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js"
        integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js"
        integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"
        integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js"
        integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?19507719"></script>



</body>
</html>
