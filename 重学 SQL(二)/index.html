<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>重学 SQL(二) · A Sort Of A Blog</title><meta name="description" content="上一篇，我们只介绍了一个表中数据的查询操作，本篇，我们将详细介绍如何进行多表查询以及多表查询的类型。
Inner Join目前为止，我们只是从单一 Table 中选取列，但在实际生产环境中，通常需要从多张 Table 中选取。
SELECT order_id, first_name, last_na"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="https://cdn.jsdelivr.net/gh/1ess/cdn/h4cker/favicon-32x32.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">0x7c00</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">张冬冬的博客</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首頁</a></li><li><a href="/archives">歸檔</a></li><li class="soc"><a href="https://github.com/1ess" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://1ess.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>重学 SQL(二)</a></p><p class="post-meta"><span class="date meta-item">發佈於&nbsp;2020-08-08</span></p><p class="post-abstract"><p>上一篇，我们只介绍了一个表中数据的查询操作，本篇，我们将详细介绍如何进行多表查询以及多表查询的类型。</p>
<h3 id="Inner-Join"><a href="#Inner-Join" class="headerlink" title="Inner Join"></a>Inner Join</h3><p>目前为止，我们只是从单一 Table 中选取列，但在实际生产环境中，通常需要从多张 Table 中选取。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_id, first_name, last_name<br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> customers c <br>    <span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<br></code></pre></td></tr></table></figure>

<p>注意: 内连接时，INNER 可不写。</p>
<p>如果连接的表中存在同名字段，我们就必须在 SELECT 子句中的该字段前指明表名前缀，否则会报错 ‘customer_id’ in field list is ambiguous: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_id, o.customer_id, first_name, last_name<br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> customers c <br>    <span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<br></code></pre></td></tr></table></figure>

<p>注意: 如果跨数据库进行连接，则需要在表名前指定数据库前缀。</p>
<h3 id="Self-Join"><a href="#Self-Join" class="headerlink" title="Self Join"></a>Self Join</h3><p>我们也可以将一张表与其自身进行连接: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>	e.employee_id,<br>	e.first_name,<br>	m.first_name <span class="hljs-keyword">AS</span> manager_name<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">JOIN</span> employees m<br>	<span class="hljs-keyword">ON</span> e.reports_to <span class="hljs-operator">=</span> m.employee_id<br></code></pre></td></tr></table></figure>

<h3 id="Join-Multiple-Tables"><a href="#Join-Multiple-Tables" class="headerlink" title="Join Multiple Tables"></a>Join Multiple Tables</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  <br>    order_id, <br>    order_date, <br>    first_name, <br>    last_name, <br>    `name` <span class="hljs-keyword">AS</span> status<br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">JOIN</span> customers c<br>    <span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<br><span class="hljs-keyword">JOIN</span> order_statuses os<br>    <span class="hljs-keyword">ON</span> os.order_status_id <span class="hljs-operator">=</span> o.`status`<br></code></pre></td></tr></table></figure>

<h3 id="Compound-Join-Conditions"><a href="#Compound-Join-Conditions" class="headerlink" title="Compound Join Conditions"></a>Compound Join Conditions</h3><p>我们在实际生产环境也常常遇见复合主键，复合主键的连接语句如下: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> order_items oi<br><span class="hljs-keyword">JOIN</span> order_item_notes oin<br>	<span class="hljs-keyword">ON</span> oi.order_id <span class="hljs-operator">=</span> oin.order_id <br>	<span class="hljs-keyword">AND</span> oi.product_id <span class="hljs-operator">=</span> oin.product_id <br></code></pre></td></tr></table></figure>

<h3 id="Outer-Join"><a href="#Outer-Join" class="headerlink" title="Outer Join"></a>Outer Join</h3><p>之前我们说了 INNER JOIN，现在我们来看看 OUTER JOIN 解决了什么问题。<br>SQL 有两种类型的外连接: </p>
<ol>
<li>LEFT OUTER JOIN</li>
<li>RIGHT OUTER JOIN</li>
</ol>
<p>当使用左连接时，所有左表记录都会返回，不论条件是否正确。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>	c.customer_id,<br>	c.first_name,<br>	o.order_id<br><span class="hljs-keyword">FROM</span> customers c<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> orders o<br>	<span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id <br></code></pre></td></tr></table></figure>

<p>注意: 外连接的 OUTER 关键字可有可无，与 INNER 类似。</p>
<h3 id="Self-Outer-Join"><a href="#Self-Outer-Join" class="headerlink" title="Self Outer Join"></a>Self Outer Join</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>	e.employee_id,<br>	e.first_name,<br>	m.first_name <span class="hljs-keyword">AS</span> manager_name<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> employees m<br>	<span class="hljs-keyword">ON</span> e.reports_to <span class="hljs-operator">=</span> m.employee_id<br></code></pre></td></tr></table></figure>

<h3 id="Using-子句"><a href="#Using-子句" class="headerlink" title="Using 子句"></a>Using 子句</h3><p>如果连接的表的条件字段名称一致，在 MySQL 中我们可以使用 USING 子句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    o.order_id,<br>    c.first_name<br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">JOIN</span> customers c<br><span class="hljs-comment">--    ON o.customer_id = c.customer_id</span><br>    <span class="hljs-keyword">USING</span> (customer_id)<br></code></pre></td></tr></table></figure>

<h3 id="Natural-Join"><a href="#Natural-Join" class="headerlink" title="Natural Join"></a>Natural Join</h3><p>在 MySQL 中，有一种更简便的方法来连接两个表，就是自然连接。自然连接会自动按照相同列名进行连接: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    o.order_id,<br>    c.first_name<br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> customers c<br></code></pre></td></tr></table></figure>

<p>自然连接很简便，但是因为是让数据库引擎自己猜测如何连接，所以无法控制，可能会生成意外结果，不建议使用。</p>
<h3 id="Cross-Join"><a href="#Cross-Join" class="headerlink" title="Cross Join"></a>Cross Join</h3><p>我们使用交叉连接来连接第一个表的每条记录和第二个表的每条记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    c.first_name <span class="hljs-keyword">AS</span> customer,<br>    p.name <span class="hljs-keyword">AS</span> product  <br><span class="hljs-keyword">FROM</span> customers c<br><span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> products p<br></code></pre></td></tr></table></figure>

<h3 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h3><p>通过 UNION 运算符，我们可以合并多段查询记录，可以是一张表，也可以是不同表: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br> order_id,<br> order_date,<br> &quot;Active&quot; <span class="hljs-keyword">AS</span> status<br><span class="hljs-keyword">FROM</span> orders<br><span class="hljs-keyword">WHERE</span> order_date <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span><br><br><span class="hljs-keyword">UNION</span><br><br><span class="hljs-keyword">SELECT</span> <br> order_id,<br> order_date,<br> &quot;Archive&quot; <span class="hljs-keyword">AS</span> status<br><span class="hljs-keyword">FROM</span> orders<br><span class="hljs-keyword">WHERE</span> order_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span><br></code></pre></td></tr></table></figure>

<p>注意: 列名是基于第一段查询。</p>
<h3 id="可视化-SQL-JOIN"><a href="#可视化-SQL-JOIN" class="headerlink" title="可视化 SQL JOIN"></a>可视化 SQL JOIN</h3><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/sql/Visual_SQL_JOINS_orig.jpg"></p>
</p></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/%E9%87%8D%E5%AD%A6%20SQL(%E4%B8%89)/" title="重学 SQL(三)"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: 重学 SQL(三)</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/%E9%87%8D%E5%AD%A6%20SQL(%E4%B8%80)/" title="重学 SQL(一)">下一篇: 重学 SQL(一)&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>