<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>C Primer Plus(四) · A Sort Of A Blog</title><meta name="description" content="C 的设计思想是，把函数用作构件块来组织程序。前面我们用过了 C 标准库的函数，如 printf()、scanf()、getchar()、putchar() 和 strlen()。本篇我们进一步学习函数。
函数签名
前面说过函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="https://cdn.jsdelivr.net/gh/1ess/cdn/h4cker/favicon-32x32.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">0x7c00</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">张冬冬的博客</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首頁</a></li><li><a href="/archives">歸檔</a></li><li class="soc"><a href="https://github.com/1ess" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://1ess.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>C Primer Plus(四)</a></p><p class="post-meta"><span class="date meta-item">發佈於&nbsp;2020-06-17</span></p><p class="post-abstract"><p>C 的设计思想是，把函数用作构件块来组织程序。前面我们用过了 C 标准库的函数，如 printf()、scanf()、getchar()、putchar() 和 strlen()。本篇我们进一步学习函数。</p>
<h2 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h2><hr>
<p>前面说过函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名(signature)。<br>要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第 1 次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在 C 库或其他文件中。因此，通常的做法是提前声明函数，把函数的信息告知编译器。</p>
<p>ANSI C 标准库中，函数被分成多个系列，每一系列都有各自的头文件。这些头文件中除了其他内容，还包含了本系列所有函数的声明。例如，stdio.h 头文件包含了标准 I/O 库函数(如 printf() 和 scanf())的声明。math.h 头文件包含了各种数学函数的声明。</p>
<p>一些函数(如 printf() 和 scanf())接受许多参数。例如对于 printf()，第 1 个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C 允许使用部分原型。例如: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, ...)</span></span>;<br></code></pre></td></tr></table></figure>

<p>这种原型表明，第 1 个参数是一个字符串，可能还有其他未指定的参数。C 库通过 stdarg.h 头文件提供了一个定义这类(形参数量不固定的)函数的标准方法。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><hr>
<p>C 允许函数调用它自己，这种调用过程称为递归(recursion)。可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。<br>要点: </p>
<ul>
<li>每级函数调用都有自己的变量</li>
<li>每次函数调用都会返回一次</li>
<li>递归函数中位于递归调用之前的语句，均按被调函数的顺序执行</li>
<li>递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行</li>
<li>递归函数必须包含能让递归调用停止的语句</li>
</ul>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归(tail recursion)，因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。<br>既然用递归和循环来计算都没问题，那么到底应该使用哪一个？一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢。</p>
<h2 id="多源代码程序编译"><a href="#多源代码程序编译" class="headerlink" title="多源代码程序编译"></a>多源代码程序编译</h2><hr>
<h3 id="Unix-Linux"><a href="#Unix-Linux" class="headerlink" title="Unix/Linux"></a>Unix/Linux</h3><p>假设 file1.c 和 file2.c 是两个内含 C 函数的文件，下面的命令将编译两个文件并生成一个名为 a.out 的可执行文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">cc file1.c file2.c<br></code></pre></td></tr></table></figure>

<p>另外，还生成两个名为 file1.o 和 file2.o 的目标文件。如果后来改动了 file1.c，而 file2.c 不变，可以使用以下命令编译第 1 个文件，并与第 2 个文件的目标代码合并：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">cc file1.c file2.o<br></code></pre></td></tr></table></figure>

<h3 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h3><p>绝大多数 DOS 命令行编译器的工作原理和 Unix/Linux 的 cc 命令类似，其中一个区别是，目标文件的扩展名是 .obj，而不是 .o。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><hr>
<p>把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C 标准库就是这样做的。另外，程序中经常用C预处理器定义符号常量。好的做法是把 #define 指令放进头文件，然后在每个源文件中使用 #include 指令包含该文件即可。</p>
<h2 id="amp-地址运算符"><a href="#amp-地址运算符" class="headerlink" title="&amp; 地址运算符"></a>&amp; 地址运算符</h2><hr>
<p>指针是 C 语言中最重要也是最复杂的只是之一，它用于存储变量地址。我们首先来介绍一下 &amp; 运算符。<br>&amp; 运算符给出变量的存储地址。如 age 是变量名，则 &amp;age 为该变量的地址: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> age = <span class="hljs-number">18</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %p\n&quot;</span>, age, &amp;age);<br><span class="hljs-comment">//18, 0b71</span><br></code></pre></td></tr></table></figure>

<h2 id="间接运算符"><a href="#间接运算符" class="headerlink" title="* 间接运算符"></a>* 间接运算符</h2><p>有时，我们需要修改其他函数的变量，就需要使用到指针，从根本上看，指针(pointer)是一个值为内存地址的变量(或数据对象)。<br>假设 ptr 指向 bah，如下所示: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">ptr = &amp;bah;<br></code></pre></td></tr></table></figure>

<p>然后使用间接运算符 *(indirection operator)找出储存在 bah 中的值，该运算符有时也称为解引用运算符(dereferencing operator)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">val = *ptr; <br></code></pre></td></tr></table></figure>

<h3 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h3><p>看完上面知识点，我们该如何声明指针变量呢？下面是一些指针的声明示例: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> *pi;<br><span class="hljs-keyword">char</span> *pc;<br><span class="hljs-keyword">float</span> *pf;<br></code></pre></td></tr></table></figure>

<p>类型说明符表明了指针所指向对象的类型，星号(*)表明声明的变量是一个指针。</p>
</p></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/C%20Primer%20Plus(%E4%BA%94)/" title="C Primer Plus(五)"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: C Primer Plus(五)</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/C%20Primer%20Plus(%E4%B8%89)/" title="C Primer Plus(三)">下一篇: C Primer Plus(三)&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;</p><p>如果五分钟后她必须进安检，如果安检在十米之外</p><p>那意味着，你们可以亲吻四分五十秒。&nbsp;</p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>