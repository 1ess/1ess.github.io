<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Sort Of A Blog</title>
  
  
  <link href="https://1ess.github.io/atom.xml" rel="self"/>
  
  <link href="https://1ess.github.io/"/>
  <updated>2021-07-14T12:43:18.362Z</updated>
  <id>https://1ess.github.io/</id>
  
  <author>
    <name>Stephen Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/React(%E4%B8%80)/"/>
    <id>https://1ess.github.io/React(%E4%B8%80)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周工作太忙了，用 C# 写了 API、建了数据库、部署了服务器(从 Docker 迁移回了 IIS，API 在 Docker 中的访问速度不稳定，出现随机访问超时问题，应该是 Windows 下，Docker 性能有问题或 SELinux 的问题？)、写了一个钉钉的 E 应用接入公司的系统。由于一直写前台，这一段时间确实认识到了对后台的了解不够深入，但路还是得一步一步来走。</p><hr><p>言归正传，这一篇开始，我们就开始学习 React 的知识，我们首先介绍一下 React。<br>React 是由 Facebook 公司开源的一个 JS Library，官方说法是: </p><blockquote><p>A declarative, efficient, and flexible JavaScript library for building user interfaces. </p></blockquote><p>从中可以看出 React 不是一个框架，它只是一个库。它只提供 UI 层面的解决方案。在实际的项目当中，它并不能解决我们所有的问题，需要结合其它的库，例如 Redux、React-router 等来协助提供完整的解决方法。<br>我们在开发过程中常常听到组件化这个词，在前端开发中，组件化可以帮助我们解决前端结构的复用性问题，整个页面可以由这样的不同的组件组合、嵌套构成。</p><p>一个组件有自己的显示形态和行为，组件的显示形态和行为可以由数据状态(state)和配置参数(props)共同决定。数据状态和配置参数的改变都会影响到这个组件的显示形态。</p><p>当数据变化的时候，组件的显示需要更新。所以如果组件化的模式能提供一种高效的方式自动化地帮助我们更新页面，那也就可以大大地降低我们代码的复杂度，带来更好的可维护性。</p><h2 id="React-基本环境安装"><a href="#React-基本环境安装" class="headerlink" title="React 基本环境安装"></a>React 基本环境安装</h2><hr><p>想要在生产环境使用 React ，需要一堆的库以及工具来辅助: 编译阶段需要 babel、帮助管理状态需要 Redux、构建单页面应用需要 React-router 等等，这也就是所谓的 React 全家桶。</p><h3 id="npm-的安装配置"><a href="#npm-的安装配置" class="headerlink" title="npm 的安装配置"></a>npm 的安装配置</h3><p>在正式学习 React 技术栈之前，我们先来介绍一下之后经常要使用到的 npm。<br>npm 是一个基于 nodejs 的 JavaScript 包管理工具，全称叫做 node package manager。(类似于 iOS 开发中的 Cocoapods，C# 中的 NuGet)。<br>所谓的包呢，其实就是可复用的代码，每个人都可以把自己编写的代码库发布到 npm 的源(registry)上面进行管理，你也可以下载别人开发好的包，在你自己的应用当中使用。通过使用 npm 作为项目的包管理工具，我们可以很方便地在我们的开发项目中引入以及管理第三方的框架或者库，而不需要像以前，手动下载复制粘贴代码文件。</p><p>npm 的安装非常简单，不管你是用的是什么操作系统，我们只需要打开 nodejs 官网，网站会自动匹配你的系统显示相应的安装包，点击 LTS 版本的下载按钮，等待安装包下载完成。安装完成 nodejs 之后，npm 也已经自动安装到系统中了。</p><p>安装完成之后，我们可以通过: </p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash"><code class="language-hljs bash">node -v //检查 node 版本<br>npm -v //检查 npm 版本<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>由于 npm 官方的服务器在国外，在国内使用可能会遇到很多网络问题，为了方便我们的开发，你可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm。国内最稳定的镜像源是<a href="https://npm.taobao.org/">淘宝</a>提供的。</p><p>首先，以管理员身份打开命令行，输入: </p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash"><code class="language-hljs bash">npm install -g cnpm --registry=https://registry.npm.taobao.org<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>从 registry.npm.taobao.org 安装所有模块，当安装的时候发现安装的模块还没有同步过来，淘宝 NPM 会自动在后台进行同步，并且会让你从官方 NPM registry.npmjs.org 进行安装，下次你再安装这个模块的时候, 就会直接从淘宝 NPM 安装了。</p><p>然后，我们通过: </p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash"><code class="language-hljs bash">cnpm install react react-dom --save<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>来安装 React，并添加到项目依赖里。</p><h3 id="yarn-的安装配置"><a href="#yarn-的安装配置" class="headerlink" title="yarn 的安装配置"></a>yarn 的安装配置</h3><p>相比于 npm，新的包管理工具 yarn 具有极其快速、特别安全以及超级可靠的优点。我们根据<a href="https://yarnpkg.com/en/">官方文档</a>进行安装。</p><h4 id="最常用的命令如下"><a href="#最常用的命令如下" class="headerlink" title="最常用的命令如下:"></a>最常用的命令如下:</h4><ul><li>初始化新项目</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn init<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>添加依赖包</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn add [package]<br>yarn add [package]@[version]<br>yarn add [package]@[tag]<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>将依赖项添加到不同依赖项类别，分别添加到 devDependencies、peerDependencies 和 optionalDependencies</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn add [package] --dev<br>yarn add [package] --peer<br>yarn add [package] --optional<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>升级依赖包</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn upgrade [package]<br>yarn upgrade [package]@[version]<br>yarn upgrade [package]@[tag]<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>移除依赖包</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn remove [package]<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>安装项目的全部依赖</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell">yarn<br><span class="hljs-meta">#</span><span class="bash"><code class="language-hljs shell">yarn<br><span class="hljs-meta">#</span><span class="bash"> 或者</span><br>yarn install<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="使用-create-react-app-命令行工具"><a href="#使用-create-react-app-命令行工具" class="headerlink" title="使用 create-react-app 命令行工具"></a>使用 create-react-app 命令行工具</h3><p>通过 cnpm，我们可以安装许多命令行工具。 React 官方专门为我们准备了专用的 React 项目生成工具 create-react-app，只需要简单几行代码即可生成 React 项目，并且在开发时还支持实时更新、自动重载等功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash">create-react-app my-app<br><span class="hljs-built_in"><code class="language-hljs bash">create-react-app my-app<br><span class="hljs-built_in">cd</span> my-app<br>cnpm start<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>或者使用 yarn 来操作: </p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash">yarn create react-app my-app<br><span class="hljs-built_in"><code class="language-hljs bash">yarn create react-app my-app<br><span class="hljs-built_in">cd</span> my-app<br>yarn start<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><hr><p>JSX 其是一个语法扩展，它既不是单纯的字符串，也不是 HTML，虽然长得和 HTML 很像甚至基本上看起来一样。但事实上它是 React 内部实现的一种，允许我们直接在 JS 里书写 UI 的方式: </p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;box&#x27;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;content&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;title&#x27;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;box&#x27;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;content&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;title&#x27;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>上面的 DOM 可以表示成如下 JavaScript 中的对象: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript">&#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;box&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;content&#x27;</span>&#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>      <span class="hljs-attr">arrts</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>      <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Hello&#x27;</span>]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;button&#x27;</span>,<br>      <span class="hljs-attr">attrs</span>: <span class="hljs-literal">null</span>,<br>      <span class="hljs-attr">children</span>: [<span class="hljs-string"><code class="language-hljs javascript">&#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;box&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;content&#x27;</span>&#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>      <span class="hljs-attr">arrts</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>      <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Hello&#x27;</span>]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;button&#x27;</span>,<br>      <span class="hljs-attr">attrs</span>: <span class="hljs-literal">null</span>,<br>      <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Click&#x27;</span>]<br>    &#125;<br>  ]<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们发现，HTML 的信息和 JavaScript 所包含的结构和信息其实是一样的，我们可以用 JavaScript 对象来描述所有能用 HTML 表示的 UI 信息。但是用 JavaScript 写起来太长了，结构看起来又不清晰，用 HTML 的方式写起来就方便很多了。<br>于是 React 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构。</p><h3 id="JSX-原理"><a href="#JSX-原理" class="headerlink" title="JSX 原理"></a>JSX 原理</h3><p>我们想要在浏览器里直接运行采用 JSX 语法的 JavaScript 显然暂时是不可能实现的，在实际的生产过程中，我们需要利用 Babel 一类的转译器来将我们的 JSX 语法或者 ES6 语法转译成浏览器可以直接运行的 JavaScript，事实上 JSX 在经过转译之后，会变成一个方法调用: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript">ReactDOM.render(<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello React!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript">ReactDOM.render(<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello React!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>转译之后就会变成下面这样: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript">ReactDOM.render(<br>    React.createElement(<span class="hljs-string">&#x27;p,&#x27;</span> <span class="hljs-literal">null</span>, <span class="hljs-string">`Hello React!`</span>),<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript">ReactDOM.render(<br>    React.createElement(<span class="hljs-string">&#x27;p,&#x27;</span> <span class="hljs-literal">null</span>, <span class="hljs-string">`Hello React!`</span>),<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>React.createElement() 函数会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、还有子元素等。这样的代码就是合法的 JavaScript 代码了。所以使用 React 和 JSX 的时候一定要经过编译的过程。<br>所谓的 JSX 其实就是 JavaScript 对象。每当在 JavaScript 代码中看到这种 JSX 结构的时候，要在我们的脑海中进行自动转化，这样对理解 React 的组件写法很有好处。可以理解为: JSX 本质是一种语法糖。</p><h3 id="JSX-基本语法"><a href="#JSX-基本语法" class="headerlink" title="JSX 基本语法"></a>JSX 基本语法</h3><h4 id="JSX-元素"><a href="#JSX-元素" class="headerlink" title="JSX 元素"></a>JSX 元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span></span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们用 JSX 创建的元素对象一般来说是不变的，所以通过 const 关键字来声明一个 React 元素。</p><h4 id="JSX-属性"><a href="#JSX-属性" class="headerlink" title="JSX 属性"></a>JSX 属性</h4><p>JSX 的标签同样可以拥有自己的属性: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span></span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>但它和 HTML 又不是完全相同的，因为他们本质上是 JS 对象，所以 class、for 等 JS 中的关键字不可以使用，例如我们想要为 JSX 标签添加 class 的时候需要使用 className，for 需要使用 htmlFor: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-comment">// 注意使用 className 而不是 class</span><br><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-comment">// 注意使用 className 而不是 class</span><br><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span></span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="JSX-嵌套"><a href="#JSX-嵌套" class="headerlink" title="JSX 嵌套"></a>JSX 嵌套</h4><p>JSX 的标签也可以像 HTML 一样相互嵌套，一般有嵌套结构的 JSX 元素外面，我们习惯于为它加上一个小括号: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>需要注意的是，JSX 在嵌套时，最外层有且只能有一个标签，否则就会出错: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-comment">// 错误！</span><br><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-comment">// 错误！</span><br><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果希望渲染完成之后，DOM 中没有新增节点，我们可以使用 Fragment 组件包裹: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> title = (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> title = (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="JSX-表达式"><a href="#JSX-表达式" class="headerlink" title="JSX 表达式"></a>JSX 表达式</h4><p>在 JSX 元素中，我们同样可以使用 JavaScript 表达式，在 JSX 当中的表达式需要用一个大括号括起来: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;1ess&quot;</span>;<br><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React now, &#123;name&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;1ess&quot;</span>;<br><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React now, &#123;name&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一周工作太忙了，用 C# 写了 API、建了数据库、部署了服务器(从 Docker 迁移回了 IIS，API 在 Docker 中的访问速度不稳定，出现随机访问超时问题，应该是 Windows 下，Docker 性能有问题或 SELinux 的问题？)、写了一个钉钉的 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/React(%E4%BA%8C)/"/>
    <id>https://1ess.github.io/React(%E4%BA%8C)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们将介绍 React 中最重要的概念之一 —— 组件。</p><h2 id="元素与组件-Element-amp-Component"><a href="#元素与组件-Element-amp-Component" class="headerlink" title="元素与组件(Element &amp; Component)"></a>元素与组件(Element &amp; Component)</h2><hr><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><p>元素是构建 React 应用的最小单位。元素所描述的也就是你在浏览器中能够看到的东西。<br>我们在编写 React 代码时一般用 JSX 来描述 React 元素。<br>在作用上，我们可以把 React 元素理解为 DOM 元素，但实际上，React 元素只是 JS 当中普通的对象。React 内部实现了一套叫做 React DOM 的东西，或者我们称之为 Virtual DOM 也就是虚拟 DOM.通过一个树状结构的 JS 对象来模拟 DOM 树。</p><p>React 之所以快就是因为这一套虚拟 DOM 的存在，React 内部还实现了一个低复杂度高效率的 Diff 算法，不同于以往框架，例如 Angular 使用的脏检查。在应用的数据改变之后，React 会尽力少地比较，然后根据虚拟 DOM 只改变真实 DOM 中需要被改变的部分。并且通过这一层单独抽象的逻辑让 React 有了无限的可能，就比如 react native 的实现。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>要注意到，在 React 当中元素和组件是两个不同的概念，我们需要明确的是，组件是构建在元素的基础之上的。</p><p>React 官方对组件的定义，是指在 UI 界面中，可以被独立划分的、可复用的、独立的模块。<br>其实就类似于 JS 当中对 function 函数的定义，它一般会接收一个名为 props 的输入，然后返回相应的 React 元素，再交给 ReactDOM，最后渲染到屏幕上。</p><h2 id="函数定义与类定义组件-Functional-amp-Class"><a href="#函数定义与类定义组件-Functional-amp-Class" class="headerlink" title="函数定义与类定义组件(Functional &amp; Class)"></a>函数定义与类定义组件(Functional &amp; Class)</h2><hr><p>React 提供了两种定义组件的方法: </p><ul><li>函数定义组件，只需要定义一个接收 props 传值，返回 React 元素的方法即可: </li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Title</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">const</span> Title = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Title</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">const</span> Title = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span></span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>类定义组件，也就是使用 ES6 中新引入的类的概念来定义 React 组件: </li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span></span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>组件在定义好之后，可以通过 JSX 描述的方式被引用，组件之间也可以相互嵌套和组合。</p><h2 id="展示与容器组件-Presentational-amp-Container"><a href="#展示与容器组件-Presentational-amp-Container" class="headerlink" title="展示与容器组件(Presentational &amp; Container)"></a>展示与容器组件(Presentational &amp; Container)</h2><hr><p>之前我们说过，React 不算是一个框架，他只关心视图层次，因此，他是如何处理数据与视图关系呢？为了解决这一问题，就引入了展示组件和容器组件的概念。正确的划分展示组件和容器组件是我们在开发 React 应用时的最佳实践。</p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            comments = [];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        $.ajax(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/comment.json&#x27;</span>,<br>            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">comments</span> =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123;comments = comments&#125;)<br>        &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">renderComment</span>(<span class="hljs-params">&#123;body, author&#125;</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;body&#125; - &#123;author&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;this.state.comments.map(this.renderComment)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            comments = [];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        $.ajax(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/comment.json&#x27;</span>,<br>            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">comments</span> =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123;comments = comments&#125;)<br>        &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">renderComment</span>(<span class="hljs-params">&#123;body, author&#125;</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;body&#125; - &#123;author&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;this.state.comments.map(this.renderComment)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>></span></span>;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>这是一个回复列表组件，乍看上去很正常也很合理。但实际上在开发 React 应用时，我们应该避免写出这样的组件，因为这类组件担负的功能太多了。<br>它只是一个单一的组件，但需要同时负责初始化 state，通过 ajax 获取服务器数据，渲染列表内容，在实际应用中，可能还会有更多的功能依赖。</p><p>通过应用展示组件与容器组件的概念，我们可以把上述的单一组件重构为一个展示回复列表组件和回复列表容器: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-comment">// 展示组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">renderComment</span>(<span class="hljs-params">&#123;body, author&#125;</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;body&#125;-&#123;author&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> &lt;ul&gt;&#123;<span class="hljs-built_in">this</span>.props.comments.map(<span class="hljs-built_in"><code class="language-hljs javascript"><span class="hljs-comment">// 展示组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">renderComment</span>(<span class="hljs-params">&#123;body, author&#125;</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;body&#125;-&#123;author&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> &lt;ul&gt;&#123;<span class="hljs-built_in">this</span>.props.comments.map(<span class="hljs-built_in">this</span>.renderComment)&#125;<ul>;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-comment">// 容器组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentListContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state.comments = [];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        $.ajax(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/comment.json&#x27;</span>,<br>            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">comments</span> =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123;comments = comments&#125;)<br>        &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CommentList</span> <span class="hljs-attr">comments</span>=<span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-comment">// 容器组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentListContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state.comments = [];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        $.ajax(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/comment.json&#x27;</span>,<br>            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">comments</span> =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123;comments = comments&#125;)<br>        &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CommentList</span> <span class="hljs-attr">comments</span>=<span class="hljs-string">&#123;this.state.comments&#125;</span> /></span></span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>这样单一组件就分割成两个组件了。<br>我们再来明确一下展示组件和容器组件的概念: </p><h3 id="展示组件"><a href="#展示组件" class="headerlink" title="展示组件"></a>展示组件</h3><ul><li>主要负责组建内容如何展示</li><li>从 props 接收父组件传递的数据</li><li>大多数可以通过函数定义组件声明</li></ul><h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3><ul><li>主要关注组件数据如何交互</li><li>拥有自身的 state，从服务器获取数据、或与 redux 等其他数据处理模块协作</li><li>需要通过类定义组件声明，并包含生命周期函数和其他附加方法</li></ul><h2 id="有状态与无状态组件-Stateful-amp-Stateless"><a href="#有状态与无状态组件-Stateful-amp-Stateless" class="headerlink" title="有状态与无状态组件(Stateful &amp; Stateless)"></a>有状态与无状态组件(Stateful &amp; Stateless)</h2><hr><h3 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h3><p>有状态的意思是这个组件能够获取储存改变应用或组件本身的状态数据，在 React 当中也就是 state，一些比较明显的特征是我们可以在这样的组件当中看到对 this.state 的初始化，或 this.setState 方法的调用等等。</p><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>这样的组件一般只接收来自其他组件的数据。一般这样的组件中只能看到对 this.props 的调用，通常可以用函数定义组件的方式声明。</p><p>注意: 并不是所有的展示组件都是无状态组件，所有的容器组件都是有状态组件。</p><h2 id="受控与非受控组件-Controlled-amp-Uncontrolled"><a href="#受控与非受控组件-Controlled-amp-Uncontrolled" class="headerlink" title="受控与非受控组件(Controlled &amp; Uncontrolled)"></a>受控与非受控组件(Controlled &amp; Uncontrolled)</h2><hr><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>一般涉及到表单元素时我们才会使用这种分类方法，受控组件的值由 props 或 state 传入，用户在元素上交互或输入内容会引起应用 state 的改变。在 state 改变之后重新渲染组件，我们才能在页面中看到元素中值的变化，假如组件没有绑定事件处理函数改变 state，用户的输入是不会起到任何效果的，这也就是”受控”的含义所在。</p><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>类似于传统的 DOM 表单控件，用户输入不会直接引起应用 state 的变化，我们也不会直接为非受控组件传入值。想要获取非受控组件，我们需要使用一个特殊的 ref 属性，同样也可以使用 defaultValue 属性来为其指定一次性的默认值。</p><p>注意: 通常情况下，React 当中所有的表单控件都需要是受控组件。但正如我们对受控组件的定义，想让受控组件正常工作，每一个受控组件我们都需要为其编写事件处理函数。</p><h2 id="组合与继承-Composition-amp-Inheritance"><a href="#组合与继承-Composition-amp-Inheritance" class="headerlink" title="组合与继承(Composition &amp; Inheritance)"></a>组合与继承(Composition &amp; Inheritance)</h2><hr><p>React 当中的组件是通过嵌套或组合的方式实现组件代码复用的。通过 props 传值和组合使用组件几乎可以满足所有场景下的需求。这样也更符合组件化的理念，就好像使用互相嵌套的 DOM 元素一样使用 React 的组件，并不需要引入继承的概念。</p><p>React 官方也希望我们通过组合的方式来使用组件，如果你想实现一些非界面类型函数的复用，可以单独写在其他的模块当中在引入组件进行使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们将介绍 React 中最重要的概念之一 —— 组件。&lt;/p&gt;
&lt;h2 id=&quot;元素与组件-Element-amp-Component&quot;&gt;&lt;a href=&quot;#元素与组件-Element-amp-Component&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/React(%E4%B8%89)/"/>
    <id>https://1ess.github.io/React(%E4%B8%89)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们看看组件对于数据的处理以及组件的生命周期。</p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><hr><p>props 作用: </p><ul><li>传入变量</li><li>传入函数</li><li>传入组件</li><li>props.children</li></ul><p>props 其实就是属性 Properties 的缩写。<br>在形式上，props 之于 JSX 就相当于 attributes 之于 HTML。从写法上来看呢，我们为组件传入 props 就可以像为 HTML 标签添加属性一样: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> SimpleButton = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <br>( <br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;props.className&#125;</span>&gt;</span></span><br><span class="xml">    &#123;props.buttonTitle&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>);<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SimpleButton</span>  <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;sb&quot;</span> <span class="hljs-attr">buttonTitle</span>=<span class="hljs-string">&quot;SimpleButton&quot;</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> SimpleButton = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <br>( <br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;props.className&#125;</span>&gt;</span></span><br><span class="xml">    &#123;props.buttonTitle&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>);<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SimpleButton</span>  <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;sb&quot;</span> <span class="hljs-attr">buttonTitle</span>=<span class="hljs-string">&quot;SimpleButton&quot;</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>));<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="props-是只读的"><a href="#props-是只读的" class="headerlink" title="props 是只读的"></a>props 是只读的</h3><p>在 React 中，props 都是自上向下传递，从父组件传入子组件。并且 props 是只读的，我们不能在组件中直接修改 props 的内容。</p><h3 id="props-类型检查"><a href="#props-类型检查" class="headerlink" title="props 类型检查"></a>props 类型检查</h3><p>正是因为 props 的强大，什么类型的内容都可以传递，所以在开发过程中，为了避免错误类型的内容传入，我们可以为 props 添加类型检查。</p><h3 id="props-默认值"><a href="#props-默认值" class="headerlink" title="props 默认值"></a>props 默认值</h3><p>由于 props 是只读的，我们不能直接为 props 赋值。React 专门准备了一个方法定义 props 的默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> SimpleButton = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;props.className&#125;</span>&gt;</span></span><br><span class="xml">    &#123;props.buttonTitle&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>);<br><br>SimpleButton.defaultProps = &#123;<br>    <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;defaultClassName&quot;</span>,<br>    <span class="hljs-attr">buttonTitle</span>: <span class="hljs-string">&quot;defaultButtonTitle&quot;</span><br>&#125;;<br><br>SimpleButton.propTypes = &#123;<br>    <span class="hljs-attr">className</span>: PropTypes.string.isRequired,<br>    <span class="hljs-attr"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> SimpleButton = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;props.className&#125;</span>&gt;</span></span><br><span class="xml">    &#123;props.buttonTitle&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>);<br><br>SimpleButton.defaultProps = &#123;<br>    <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;defaultClassName&quot;</span>,<br>    <span class="hljs-attr">buttonTitle</span>: <span class="hljs-string">&quot;defaultButtonTitle&quot;</span><br>&#125;;<br><br>SimpleButton.propTypes = &#123;<br>    <span class="hljs-attr">className</span>: PropTypes.string.isRequired,<br>    <span class="hljs-attr">buttonTitle</span>: PropTypes.string.isRequired<br>&#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><hr><ul><li>初始化</li><li>setState 方法</li><li>向下传递数据</li></ul><p>在 React 中 state 也是我们进行数据交互的地方，又或者叫做 state management 状态管理。<br>一个应用需要进行数据交互，比如同服务器之间的交互，同用户输入进行交互。或者反过来，从 API 获取数据，处理用户输入也就是我们需要用到 state 的时候。</p><p>在新版本的 React 当中，我们通过类定义组件来声明一个有状态组件，之后在它的构造方法中初始化组件的 state，我们可以先赋予它默认值。</p><p>之后就可以在组件中通过 this.state 来访问它，和之前的 props 一样，初始化 state 之后，如果我们想改变它，是不可以直接对其赋值的，直接修改 state 的值没有任何意义，因为这样的操作脱离了 React 运行的逻辑，不会触发组件的重新渲染。所以需要 this.setState 这个方法，在改变 state 的同时，触发 React 内部的一系列函数，最后在页面上重新渲染出组件。</p><p>随着我们开发应用的逐步扩展，state 也会变得越来越庞大复杂，假如分散到各个组件当中，对于日后应用的维护者来说将是一个噩梦。怎么处理怎么储存应用的 state 非常值得我们深入去思考，由此也就引发了一个问题——状态管理。这也正是 Redux 要解决的问题。</p><h2 id="React-是如何渲染组件的"><a href="#React-是如何渲染组件的" class="headerlink" title="React 是如何渲染组件的"></a>React 是如何渲染组件的</h2><hr><p>我们按照平时书写 React 代码的顺序来理清 React 把组件代码渲染到最终的真实 DOM 中的流程。<br>一般来讲，我们都会先定义一个组件。我们如果想要在页面中看到这个组件的渲染结果，就需要以 JSX 的形式将组件传入 ReactDOM.render 方法的第一个参数，我们一直说，这里的 JSX 经过 React 内部的转译，将 JSX 转换为 React.createElement 方法来创建的 React 元素。render 方法获取到 React 元素之后会将它实例化，之后它会根据实例化的 React 元素创建出真实的 DOM 元素，再根据第二个参数的指向，将创建好的元素插入到目标 DOM 容器当中。</p><p>在新版本的 React 当中，将 React 应用界面更新的过程分为了两个主要的部分: </p><ul><li>调度过程</li><li>执行过程</li></ul><p>在调度过程中，有 4 个生命周期函数会被触发: </p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p>在执行过程中，有 3 个生命周期函数会被触发: </p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><p>官方推荐在 componentDidMount 函数中进行一些例如 ajax 请求的操作，所以它也是我们最经常使用的生命周期函数。</p><h2 id="表单及事件处理"><a href="#表单及事件处理" class="headerlink" title="表单及事件处理"></a>表单及事件处理</h2><hr><p>之前说过受控组件与非受控组件的概念。受控与非受控组件就是专门适用于 React 当中的表单元素的。<br>在 HTML 中，表单元素与其他元素最大的不同是它自带值或数据，而且在我们的应用中，只要是有表单出现的地方，就会有用户输入，就会有表单事件触发，就会涉及的数据处理。</p><p>为了更好地管理应用中的数据，响应用户的输入，编写组件的时候，我们就会运用到受控组件与非受控组件这两个概念。</p><p>React 推荐我们在绝大多数情况下都使用受控组件。这样可以保证表单的数据在组件的 state 管理之下，而不是各自独立保有各自的数据。</p><h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><p>我们在组件中声明表单元素时，一般都要为表单元素传入应用状态中的值，可以通过 state 也可以通过 props 传递，之后需要为其绑定相关事件，例如表单提交、输入改变等。在相关事件触发的处理函数中，我们需要根据表单元素中用户的输入，对应用数据进行相应的操作和改变: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControlledInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;&quot;</span><br>        &#125;;<br>    &#125;<br><br>    handlerChange = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>            <span class="hljs-attr">value</span>: e.target.value<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handlerChange&#125;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br><br>    <span class="hljs-comment">//或者使用如下写法(属性初始化器语法)，我们通常建议在构造函数中绑定或使用属性初始化器语法来避免性能问题。</span><br>    handlerChange = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>            <span class="hljs-attr">value</span>: e.target.value<br>        &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handlerChange&#125;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ControlledInput</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControlledInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;&quot;</span><br>        &#125;;<br>    &#125;<br><br>    handlerChange = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>            <span class="hljs-attr">value</span>: e.target.value<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handlerChange&#125;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br><br>    <span class="hljs-comment">//或者使用如下写法(属性初始化器语法)，我们通常建议在构造函数中绑定或使用属性初始化器语法来避免性能问题。</span><br>    handlerChange = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>            <span class="hljs-attr">value</span>: e.target.value<br>        &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handlerChange&#125;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ControlledInput</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>));<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>使用受控组件和非受控组件都是有相应的适用场景的，就拿 input 来讲，比方说它是一个搜索框，我们需要在应用中实现根据搜索框内容输入异步返回相关搜索建议的功能，那么此处的 input 就应该是受控组件。而假如它是 Todo 应用中用来添加新事项的输入框，我们就没有特别的理由需要实时获取其中的数据，只需要在添加事项的事件触发时获取输入框中的值即可，这个地方就可以使用非受控组件。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>React 元素的事件属性几乎与 HTML 中的事件相关属性相同，不过在 React 当中，事件相关的属性是以小驼峰的方式命名的。<br>新版本的 React 中，我们可以通过类和函数声明 React 组件，在这两种形式的声明当中，我们都可以为其定义事件处理函数，函数定义的组件只需要在其方法内部再定义事件触发的函数即可，而如果是类声明组件，就像我们在之前的课程中已经强调过的，类定义组件中的自定义方法默认是没有绑定 this 的，因此假如我们需要在事件处理函数中调用 this.setState 一类的方法，就必须要在构造函数中手动将 this 绑定在相应的事件处理函数上。(箭头函数不用)。</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>我们可以使用与运算符 &amp;&amp; 进行条件渲染: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mailbox</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> unreadMessages = props.unreadMessages;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      &#123;</span><br><span class="xml">        unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">      &#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> messages = [<span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Re: React&#x27;</span>, <span class="hljs-string">&#x27;Re:Re: React&#x27;</span>];<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Mailbox</span> <span class="hljs-attr">unreadMessages</span>=<span class="hljs-string">&#123;messages&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mailbox</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> unreadMessages = props.unreadMessages;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      &#123;</span><br><span class="xml">        unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">      &#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> messages = [<span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Re: React&#x27;</span>, <span class="hljs-string">&#x27;Re:Re: React&#x27;</span>];<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Mailbox</span> <span class="hljs-attr">unreadMessages</span>=<span class="hljs-string">&#123;messages&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>之所以能这样做，是因为在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。<br>因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</p><h3 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h3><p>在极少数情况下，你可能希望隐藏组件，如下方法可以实现: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> [];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;&gt;</span><span class="hljs-tag"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> [];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;&gt;</span><span class="hljs-tag"></></span></span>);<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="列表组件"><a href="#列表组件" class="headerlink" title="列表组件"></a>列表组件</h2><hr><p>通常，我们使用 Javascript 中的 map() 方法遍历数组。对数组中的每个元素返回 li 标签，最后我们得到一个数组 listItems: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span><br>  (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span><br>  (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>></span></span><br>  )<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们把整个 listItems 插入到 ul 元素中，然后渲染进 DOM:</p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript">ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript">ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们可以把前面的例子重构成一个组件。这个组件接收 numbers 数组作为参数，输出一个无序列表: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> numbers = props.numbers;<br>  <span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span><br>    (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    )<br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> numbers = props.numbers;<br>  <span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span><br>    (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    )<br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>当我们运行这段代码，将会看到一个警告 a key should be provided for list items，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。我们来给每个列表元素分配一个 key 来解决上面的那个警告: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> numbers = props.numbers;<br>  <span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span><br>    (  <br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    )<br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> numbers = props.numbers;<br>  <span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span><br>    (  <br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    )<br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p>Keys 可以在 DOM中 的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。<br>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的 id 作为元素的 key:</p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> todoItems = todos.map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span>&gt;</span></span><br><span class="xml">    &#123;todo.text&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> todoItems = todos.map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span>&gt;</span></span><br><span class="xml">    &#123;todo.text&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>当元素没有确定的 id 时，你可以使用他的序列号索引 index 作为 key。如果列表可以重新排序，我们不建议使用索引来进行排序，因为这会导致渲染变得很慢。<br>注意: 如果你提取出一个 ListItem 组件，你应该把 key 保存在数组中的这个<ListItem />元素上，而不是放在 ListItem 组件中的 li 元素上: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListItem</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-comment">// 对啦！这里不需要指定key:</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;props.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> numbers = props.numbers;<br>  <span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span><br>    <span class="hljs-comment">// 又对啦！key应该在数组的上下文中被指定</span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;number&#125;</span> /&gt;</span></span><br><br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      &#123;listItems&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListItem</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-comment">// 对啦！这里不需要指定key:</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;props.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> numbers = props.numbers;<br>  <span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span><br>    <span class="hljs-comment">// 又对啦！key应该在数组的上下文中被指定</span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;number&#125;</span> /&gt;</span></span><br><br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      &#123;listItems&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 当你在 map() 方法的内部调用元素时，你最好随时记得为每一个元素加上一个独一无二的 key。<br>数组元素中使用的 key 在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们看看组件对于数据的处理以及组件的生命周期。&lt;/p&gt;
&lt;h2 id=&quot;props&quot;&gt;&lt;a href=&quot;#props&quot; class=&quot;headerlink&quot; title=&quot;props&quot;&gt;&lt;/a&gt;props&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;props 作用: &lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E6%9D%82(%E4%B8%80)/"/>
    <id>https://1ess.github.io/%E6%9D%82(%E4%B8%80)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，记录关于 .Net 和 .Net Core 的一些零碎的知识点，随时更新。</p><h2 id="ASP-Net-WebAPI-和-WebMVC-问题"><a href="#ASP-Net-WebAPI-和-WebMVC-问题" class="headerlink" title="ASP.Net WebAPI 和 WebMVC 问题"></a>ASP.Net WebAPI 和 WebMVC 问题</h2><hr><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul><li>针对 .NET Framework MVC 跨域，只需要在 web.config 中添加如下的内容即可: </li></ul><figure class="highlight xml"><table><tr><td class="code"><pre class="line-numbers language-hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">system.webServer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">httpProtocol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">customHeaders</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;*&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GET, POST, PUT, DELETE, OPTIONS&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">customHeaders</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">httpProtocol</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">system.webServer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">httpProtocol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">customHeaders</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;*&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GET, POST, PUT, DELETE, OPTIONS&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">customHeaders</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">httpProtocol</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">system.webServer</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>针对 .NET Framework Web API，除了上面这样的设置，还需要添加一个特殊的设计，就是为每个 APIController 添加一个 OPTIONS 方法，返回 null 即可: </li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Options</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Options</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// HTTP 200 response with empty body</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>针对 .Net Core 跨域，需要在 Startup.cs 文件的 ConfigureServices 方法中添加以下代码: </li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">//允许某些源</span><br>services.AddCors(options =&gt; &#123;<br>    options.AddPolicy(<span class="hljs-string">&quot;AllowCors&quot;</span>, policy =&gt; &#123;<br>        <span class="hljs-comment">// 多个可以用 `,` 隔开</span><br>        policy.WithOrigins(<span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-comment">//允许某些源</span><br>services.AddCors(options =&gt; &#123;<br>    options.AddPolicy(<span class="hljs-string">&quot;AllowCors&quot;</span>, policy =&gt; &#123;<br>        <span class="hljs-comment">// 多个可以用 `,` 隔开</span><br>        policy.WithOrigins(<span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<span class="hljs-string">"http://127.0.0.1"</span>)<br>                  .AllowAnyHeader()<br>                  .AllowAnyMethod()<br>                  .AllowCredentials();<br>    &#125;);<br>&#125;);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果是所有方法都允许跨域，就在 Configure 方法中还需要添加以下代码: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">app.UseCors(<span class="hljs-string">&quot;AllowCors&quot;</span>);<span class="hljs-comment"><code class="language-hljs csharp">app.UseCors(<span class="hljs-string">&quot;AllowCors&quot;</span>);<span class="hljs-comment">//必须位于 UserMvc 之前 </span><br>app.UseMvc();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果是某些方法允许跨域，就在该 Controller 添加如下代码: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Cors;<br><br>[<span class="hljs-meta">EnableCors(<span class="hljs-meta-string">&quot;AllowCors&quot;</span>)</span>] <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Cors;<br><br>[<span class="hljs-meta">EnableCors(<span class="hljs-meta-string">&quot;AllowCors&quot;</span>)</span>] <span class="hljs-comment">//可实现指定某个 controller 或者 action 跨域</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>对于 .Net Framework MVC: </p><ul><li>对于 Post 请求，不论是简单类型还是复杂类型，调用 API 时，都会在 Body 中提交数据，以 x-www-form-urlencoded 和 application/json 两种形式提交都可以在服务端获取到。简单类型直接作为 key，复杂类型属性作为 key</li><li>对于 Get 请求，不论是简单类型还是复杂类型，调用 API 时，都会在 Query 中提交数据。简单类型直接拼接，复杂类型属性拼接</li></ul><p>对于 .Net Core MVC: </p><ul><li>对于 Post 请求，不论基本类型还是复杂类型参数，调用 API 时，既可以在 Query 中提交参数，也可以使用 x-www-form-urlencoded 表单形式提交参数，在服务端都可以接收到。对于复杂类型，我们也可以指定[FromBody] attribute，使得该复杂类型可以以 application/json Json 形式提交</li><li>对于 Get 请求，参数只能是简单类型，默认只能在 Query 中提交参数。我们也不该在 Get 请求使用复杂类型放在 Body 中提交</li></ul><p>对于 .Net Framework API: </p><ul><li>对于 Post 请求: <ol><li>如果是简单类型参数，调用 API 时，默认是在 Query 中提交参数的，如果有[FromBody] attribute 修饰参数，则需要以 application/json 形式提交参数</li><li>如果是复杂类型参数，调用 API 时，既可以以 x-www-form-urlencoded 方式，又可以以 application/json 方式提交数据</li></ol></li><li>对于 Get 请求，参数只能是简单类型，默认只能在 Query 中提交参数</li></ul><p>对于 .Net Core API: </p><ul><li>对于 Post 请求: <ol><li>如果是简单类型参数，调用 API 时，默认是在 Query 中提交参数的，如果有[FromBody] attribute 修饰参数，则需要以 application/json 形式提交参数。如果有[FromForm] attribute 修饰参数，则需要以 x-www-form-urlencoded 形式提交参数</li><li>如果是复杂类型，调用 API 时，默认应该以 application/json 形式提交数据，与使用[FromBody] attribute 修饰符一致。可以使用[FromForm] attribute 修饰参数，指定以 x-www-form-urlencoded 形式提交数据</li></ol></li><li>对于 Get 请求，参数只能是简单类型，只能以 Query 方式提交数据</li></ul><h3 id="Json-输出"><a href="#Json-输出" class="headerlink" title="Json 输出"></a>Json 输出</h3><p>在 .Net Core WebAPI 默认是 JSON 输出，而 .Net Framework WebAPI 默认是 XML 输出。如果希望 Framework 以 JSON 格式返回，则需要在 WebApiConfig.cs 的 Register 方法添加如下代码: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">config.Formatters.Remove(config.Formatters.XmlFormatter);<br>config.Formatters.JsonFormatter.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;<br>config.Formatters.JsonFormatter.SerializerSettings.ContractResolver = <span class="hljs-keyword"><code class="language-hljs csharp">config.Formatters.Remove(config.Formatters.XmlFormatter);<br>config.Formatters.JsonFormatter.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;<br>config.Formatters.JsonFormatter.SerializerSettings.ContractResolver = <span class="hljs-keyword">new</span> DefaultContractResolver();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>虽然 .Net Core WebAPI 默认是 JSON 输出，但是返回的对象是驼峰命名，如果希望与实体属性对应，需要在 ConfigureServices 方法添加如下代码: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">services.AddMvc()<br>.AddJsonOptions(options =&gt;<br>&#123;<br>    <span class="hljs-keyword">if</span> (options.SerializerSettings.ContractResolver <span class="hljs-keyword">is</span> DefaultContractResolver resolver)<br>    &#123;<br>        resolver.NamingStrategy = <span class="hljs-literal"><code class="language-hljs csharp">services.AddMvc()<br>.AddJsonOptions(options =&gt;<br>&#123;<br>    <span class="hljs-keyword">if</span> (options.SerializerSettings.ContractResolver <span class="hljs-keyword">is</span> DefaultContractResolver resolver)<br>    &#123;<br>        resolver.NamingStrategy = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="IIS-部署"><a href="#IIS-部署" class="headerlink" title="IIS 部署"></a>IIS 部署</h3><p>虚拟主机(新建一个网站就是一个虚拟主机): 可以为不同网站绑定同一个 IP 和端口，然后根据主机头(IIS8 上面改称为主机名)的不同来访问不同的站点。<br>IIS 也支持虚拟目录: 一个站点的网页的存储位置目录是固定的，而且结构和物理保存网页的磁盘路径相同。<br>例如: 默认网页的存储位置是 C:\inetpub\wwwroot，当访问 localhost 即访问 C:\inetpub\wwwroot 目录下的 index.html 文件，如果访问 localhost/dir1/ 则访问的是 C:\inetpub\wwwroot\dir1\index.html，访问 localhost/dir2 一般情况下是访问默认目录中的 dir2 目录下的 index.html 文件，但是此处的 dir2 目录指向的是 D:\web\ 目录(甚至是其他的服务器上)，这就是虚拟目录。</p><h3 id="Net-Core-部署配置"><a href="#Net-Core-部署配置" class="headerlink" title=".Net Core 部署配置"></a>.Net Core 部署配置</h3><ol><li>首先安装 .Net Core SDK</li><li>然后安装  AspNetCoreModule 托管模块: DotNetCore.x.x.x-WindowsHosting.exe</li><li>然后重启服务器或使用管理员命令行，依次执行: </li></ol><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">net stop was /y  // Windows Activation Service (WAS)<br>net start w3svc  // 万维网发布服务(W3SVC)<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>部署出现 502.5 错误，一般是 SDK 版本或者托管模块安装有问题。</p><h3 id="React，Vue-单页面应用刷新-404-问题"><a href="#React，Vue-单页面应用刷新-404-问题" class="headerlink" title="React，Vue 单页面应用刷新 404 问题"></a>React，Vue 单页面应用刷新 404 问题</h3><p>原因是单页面应用内容只有一个(一般是 index.html)。这个页面中引入的 js 框架会根据当前访问的 url 去路由到相应的子页面组件(可以理解为页面片段)进行逻辑处理和页面渲染。web 站中并没访问的这个页面资源，所以出现 404。<br>IIS 中可以使用 URL 重写方案解决该问题: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">&lt;system.webServer&gt;<br>    &lt;rewrite&gt;<br>        &lt;rules&gt;<br>            &lt;rule name=<span class="hljs-string">&quot;React Router Refresh&quot;</span> patternSyntax=<span class="hljs-string">&quot;ECMAScript&quot;</span> stopProcessing=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>                    &lt;match url=<span class="hljs-string">&quot;.*&quot;</span> /&gt;<br>                    &lt;conditions&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTP_METHOD&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^GET$&quot;</span> /&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTP_ACCEPT&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^text/html&quot;</span> /&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;REQUEST_FILENAME&#125;&quot;</span> matchType=<span class="hljs-string">&quot;IsFile&quot;</span> negate=<span class="hljs-string">&quot;true&quot;</span> /&gt;<br>                    &lt;/conditions&gt;<br>                    &lt;action type=<span class="hljs-string">&quot;Rewrite&quot;</span> url=<span class="hljs-string"><code class="language-hljs csharp">&lt;system.webServer&gt;<br>    &lt;rewrite&gt;<br>        &lt;rules&gt;<br>            &lt;rule name=<span class="hljs-string">&quot;React Router Refresh&quot;</span> patternSyntax=<span class="hljs-string">&quot;ECMAScript&quot;</span> stopProcessing=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>                    &lt;match url=<span class="hljs-string">&quot;.*&quot;</span> /&gt;<br>                    &lt;conditions&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTP_METHOD&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^GET$&quot;</span> /&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTP_ACCEPT&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^text/html&quot;</span> /&gt;<br>                        &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;REQUEST_FILENAME&#125;&quot;</span> matchType=<span class="hljs-string">&quot;IsFile&quot;</span> negate=<span class="hljs-string">&quot;true&quot;</span> /&gt;<br>                    &lt;/conditions&gt;<br>                    &lt;action type=<span class="hljs-string">&quot;Rewrite&quot;</span> url=<span class="hljs-string">"/index.html"</span> /><br>                </rule><br>        </rules><br>    </rewrite><br></system.webServer><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>Nginx 中使用: </p><figure class="highlight nginx"><table><tr><td class="code"><pre class="line-numbers language-hljs nginx"><span class="hljs-attribute"><code class="language-hljs nginx"><span class="hljs-attribute">try_files</span> $uri /index.html;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Net-的垃圾回收机制"><a href="#Net-的垃圾回收机制" class="headerlink" title=".Net 的垃圾回收机制"></a>.Net 的垃圾回收机制</h3><p>触发时机: </p><ul><li>物理内存吃紧</li><li>分配在托管堆上的内存超出阈值</li><li>手动调用 GC.Collect() 方法</li></ul><h3 id="HTTPS-重定向"><a href="#HTTPS-重定向" class="headerlink" title="HTTPS 重定向"></a>HTTPS 重定向</h3><p>需要 IIS 安装 URL 重写模块。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">&lt;system.webServer&gt;<br>    &lt;rewrite&gt;<br>        &lt;rules&gt;<br>            &lt;rule name=<span class="hljs-string">&quot;REDIRECT TO HTTPS&quot;</span> stopProcessing=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>                &lt;match url=<span class="hljs-string">&quot;(.*)&quot;</span> /&gt;<br>                &lt;conditions&gt;<br>                    &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTPS&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^OFF$&quot;</span> /&gt;<br>                &lt;/conditions&gt;<br>                &lt;action type=<span class="hljs-string">&quot;Redirect&quot;</span> url=<span class="hljs-string"><code class="language-hljs csharp">&lt;system.webServer&gt;<br>    &lt;rewrite&gt;<br>        &lt;rules&gt;<br>            &lt;rule name=<span class="hljs-string">&quot;REDIRECT TO HTTPS&quot;</span> stopProcessing=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>                &lt;match url=<span class="hljs-string">&quot;(.*)&quot;</span> /&gt;<br>                &lt;conditions&gt;<br>                    &lt;<span class="hljs-keyword">add</span> input=<span class="hljs-string">&quot;&#123;HTTPS&#125;&quot;</span> pattern=<span class="hljs-string">&quot;^OFF$&quot;</span> /&gt;<br>                &lt;/conditions&gt;<br>                &lt;action type=<span class="hljs-string">&quot;Redirect&quot;</span> url=<span class="hljs-string">"https://&#123;HTTP_HOST&#125;/&#123;R:1&#125;"</span> /><br>            </rule><br>        </rules><br>    </rewrite><br></system.webServer><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>Nginx 中使用: </p><figure class="highlight nginx"><table><tr><td class="code"><pre class="line-numbers language-hljs nginx"><span class="hljs-attribute">return</span> <span class="hljs-number"><code class="language-hljs nginx"><span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$server_name$request_uri;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="API-版本控制"><a href="#API-版本控制" class="headerlink" title="API 版本控制"></a>API 版本控制</h3><h4 id="Media-Type-进行版本控制"><a href="#Media-Type-进行版本控制" class="headerlink" title="Media Type 进行版本控制"></a>Media Type 进行版本控制</h4><ol><li>引入官方 Microsoft.AspNet.WebApi.Versioning package</li><li>在 WebApiConfig 的 Register 方法中添加如下代码: </li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">config.AddApiVersioning(options =&gt;<br>&#123;<br>    options.ApiVersionReader = <span class="hljs-keyword">new</span> MediaTypeApiVersionReader();<br>    options.AssumeDefaultVersionWhenUnspecified = <span class="hljs-literal">true</span>;<br>    options.ApiVersionSelector = <span class="hljs-keyword"><code class="language-hljs csharp">config.AddApiVersioning(options =&gt;<br>&#123;<br>    options.ApiVersionReader = <span class="hljs-keyword">new</span> MediaTypeApiVersionReader();<br>    options.AssumeDefaultVersionWhenUnspecified = <span class="hljs-literal">true</span>;<br>    options.ApiVersionSelector = <span class="hljs-keyword">new</span> CurrentImplementationApiVersionSelector(options);<br>&#125;);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="3"><li>在类上使用 [ApiVersion(“1.0”)] Attribute</li></ol><p>调用 API 时，我们就在 Content-Type 或 Accept 中用 application/xxx;v=1.0 使用 1.0 版本的 API。</p><h4 id="URL-路径进行版本控制"><a href="#URL-路径进行版本控制" class="headerlink" title="URL 路径进行版本控制"></a>URL 路径进行版本控制</h4><p>API 版本控制的另一种常见方法是使用 URL 路径。</p><ol><li>引入官方 Microsoft.AspNet.WebApi.Versioning package</li><li>在 WebApiConfig 的 Register 方法中添加如下代码: </li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">var</span> constraintResolver = <span class="hljs-keyword">new</span> DefaultInlineConstraintResolver()<br>&#123;<br>    ConstraintMap =<br>    &#123;<br>        [<span class="hljs-meta"><span class="hljs-meta-string">&quot;apiVersion&quot;</span></span>] = <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">var</span> constraintResolver = <span class="hljs-keyword">new</span> DefaultInlineConstraintResolver()<br>&#123;<br>    ConstraintMap =<br>    &#123;<br>        [<span class="hljs-meta"><span class="hljs-meta-string">&quot;apiVersion&quot;</span></span>] = <span class="hljs-keyword">typeof</span>(ApiVersionRouteConstraint)<br>    &#125;<br>&#125;;<br>configuration.MapHttpAttributeRoutes(constraintResolver);<br>configuration.AddApiVersioning();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="3"><li>在类上使用如下特性: </li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">ApiVersion( <span class="hljs-meta-string">&quot;2.0&quot;</span> )</span>]<br>[<span class="hljs-meta">Route( <span class="hljs-meta-string"><code class="language-hljs csharp">[<span class="hljs-meta">ApiVersion( <span class="hljs-meta-string">&quot;2.0&quot;</span> )</span>]<br>[<span class="hljs-meta">Route( <span class="hljs-meta-string">"api/v&#123;version:apiVersion&#125;/foo"</span> )</span>]<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>调用 API 时，请求 <a href="https://localhost/api/v2/foo">https://localhost/api/v2/foo</a> 即可。</p><h3 id="AutoMapper-的使用"><a href="#AutoMapper-的使用" class="headerlink" title="AutoMapper 的使用"></a>AutoMapper 的使用</h3><ol><li>NuGet 安装 AutoMapper.Extensions.Microsoft.DependencyInjection 依赖</li><li>在 ConfigureServices 方法中 services.AddMvc() 之后添加 services.AddAutoMapper();</li><li>自定义类并继承自 Profile</li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MappingProfile</span> : <span class="hljs-title">Profile</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MappingProfile</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//直接映射</span><br>        CreateMap&lt;Simple, SimpleDTO&gt;().ReverseMap();<br><br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MappingProfile</span> : <span class="hljs-title">Profile</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MappingProfile</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//直接映射</span><br>        CreateMap&lt;Simple, SimpleDTO&gt;().ReverseMap();<br><br>        <span class="hljs-comment">//自定义对应属性映射</span><br>        CreateMap<Simple, SimpleDTO>().ForMember(dest => dest.属性,<br>            opts => opts.MapFrom(<br>                src => src.属性操作<br>            )).ReverseMap();<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="4"><li>在控制器类依赖注入 IMapper 对象</li><li>在适当位置调用 var dest = mapper.Map<DestType>(srcObject); 即可</li></ol><h3 id="Net-Core-依赖注入-Context-对象"><a href="#Net-Core-依赖注入-Context-对象" class="headerlink" title=".Net Core 依赖注入 Context 对象"></a>.Net Core 依赖注入 Context 对象</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">services.AddDbContext&lt;CustomContext&gt;(options =&gt;<br>&#123;<br>    options.UseSqlServer(Configuration.GetConnectionString(<span class="hljs-string"><code class="language-hljs csharp">services.AddDbContext&lt;CustomContext&gt;(options =&gt;<br>&#123;<br>    options.UseSqlServer(Configuration.GetConnectionString(<span class="hljs-string">"DefaultConnection"</span>));<br>&#125;);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Net-Core-依赖注入配置文件"><a href="#Net-Core-依赖注入配置文件" class="headerlink" title=".Net Core 依赖注入配置文件"></a>.Net Core 依赖注入配置文件</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">services.Configure&lt;CustomSetting&gt;(Configuration.GetSection(<span class="hljs-keyword"><code class="language-hljs csharp">services.Configure&lt;CustomSetting&gt;(Configuration.GetSection(<span class="hljs-keyword">nameof</span>(CustomSetting)));<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><hr><h3 id="SQLServer-连接字符串写法"><a href="#SQLServer-连接字符串写法" class="headerlink" title="SQLServer 连接字符串写法"></a>SQLServer 连接字符串写法</h3><figure class="highlight json"><table><tr><td class="code"><pre class="line-numbers language-hljs json"><span class="hljs-string">&quot;ConnectionStrings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;ConnectionString&quot;</span>: <span class="hljs-string"><code class="language-hljs json"><span class="hljs-string">&quot;ConnectionStrings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;ConnectionString&quot;</span>: <span class="hljs-string">"Persist Security Info=False;User ID=xxxxxx;Password=xxxxxx;Initial Catalog=[db name];Server=[ip or domain]"</span><br>  &#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>其中: </p><ol><li>Persist Security Info=False 表示使用账户密码连接数据库</li><li>User ID 表示用户名</li><li>Password 表示密码</li><li>Initial Catalog 表示所连接的数据库</li><li>Server 表示数据库所在服务器，可以使用 IP 或域名</li></ol><h2 id="Visual-Studio-技巧"><a href="#Visual-Studio-技巧" class="headerlink" title="Visual Studio 技巧"></a>Visual Studio 技巧</h2><hr><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> (未实现)……</span><br><br><span class="hljs-comment">//UNDONE:(没有做完)……</span><br><br><span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> (未实现)……</span><br><br><span class="hljs-comment">//UNDONE:(没有做完)……</span><br><br><span class="hljs-comment">//HACK：(修改)……</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>之后，我们可以在 “视图-任务列表” 使其显示所有带有特殊注释的代码位置。</p><h3 id="选中代码块"><a href="#选中代码块" class="headerlink" title="选中代码块"></a>选中代码块</h3><p>我们使用 Alt + Shift + ] 可以直接选中光标所在代码的代码块。</p><h3 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h3><ol><li>Alt + 鼠标拖选</li><li>Ctrl + Alt + 鼠标点选</li></ol><h3 id="使用的-C-语言版本"><a href="#使用的-C-语言版本" class="headerlink" title="使用的 C# 语言版本"></a>使用的 C# 语言版本</h3><p>我们可以通过编辑 *.csproj 文件，在 PropertyGroup 内添加 LangVersion 元素，值为 latest 即可: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp"><PropertyGroup><br>    ...<br>    <LangVersion>latest</LangVersion><br></PropertyGroup><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，记录关于 .Net 和 .Net Core 的一些零碎的知识点，随时更新。&lt;/p&gt;
&lt;h2 id=&quot;ASP-Net-WebAPI-和-WebMVC-问题&quot;&gt;&lt;a href=&quot;#ASP-Net-WebAPI-和-WebMVC-问题&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%B8%80)/"/>
    <id>https://1ess.github.io/C#(%E4%B8%80)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>之前本来想学习一下 NodeJS，考虑到最近一直在使用 C#(主要使用 .Net Core 的 MVC 和 API)，并且之前也仔细地研究过一段时间的 C#，.Net 平台的发展也有上升趋势，最近微软收购 Github，打算整合自己的平台，还有 Visual Studio 这一个宇宙第一 IDE 加持，所以就打算把后台技术栈先放在 .Net 上。<br>目前的打算是将 C# 的知识都过一遍，再逐渐学习一些常用类库，最后把 ASP.Net Core MVC 和 API 都好好看看。<br>这次我打算边复习边将 C# 中的概念与其他语言做一下对比，以方便有其他语言基础的同学可以更好地理解在 C# 中的相似概念。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>要注意在使用 .Net 进行开发时，我们要知道 Solution 和 Project 的区别: </p><ul><li>Solution 是针对需求的一个总的解决方案</li><li>Project 则用来解决具体的某个问题</li></ul><h3 id="各类-C-可编写的程序"><a href="#各类-C-可编写的程序" class="headerlink" title="各类 C# 可编写的程序"></a>各类 C# 可编写的程序</h3><ul><li>Console</li><li>WinForm(old)</li><li>WPF</li><li>WebForm(old)</li><li>WebMVC</li><li>WCF</li><li>WF</li><li>UWP</li></ul><p>我们可以使用 C# 写出上述各种类型的应用，有的已经过时了，现在主流使用技术是: WebMVC、WebAPI 以及 WCF。</p><h3 id="类型和命名空间"><a href="#类型和命名空间" class="headerlink" title="类型和命名空间"></a>类型和命名空间</h3><p>C# 程序的本质是由多个类型声明组成。命名空间则是与某个名称相关联的一组类型声明。(在写 Objective-C 或者 Swift 时，是没有命名空间的概念，所以官方给出的最佳实践是使用前缀的方式来区分不同类型。)</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C# 中标识符规则: </p><ul><li>字母和下划线可以出现在任意位置</li><li>数字可以放在除了首位的任意位置</li><li>@字符只可以出现在首位，但不推荐</li></ul><p>C# 语言的标识符是大小写敏感的，这一点跟 Objective-C，Swift，JavaScript 都一样。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>C# 中的语句必须以分号作为结束标志。<br>块是由成对的大括号包围的 0 条或多条语句序列，在语法上，相当于一条语句。</p><ul><li>在语法上只需要一条语句，而一条语句无法表达时，就需要使用块</li><li>某些特定的程序结构只能使用块</li><li>虽然简单语句以号结尾，但块后面不跟分号(这样会多解析一条空语句)</li></ul><h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p>新版 C# 可以使用字符串插值，类似 JavaScript 中的字符串插值: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">$&quot;a + b= <span class="hljs-subst"><code class="language-hljs csharp"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">$&quot;a + b= <span class="hljs-subst">&#123;a + b&#125;</span>"</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>C# 允许三种注释: </p><ul><li>单行注释 //</li><li>多行注释 /**/</li><li>文档注释 ///</li></ul><h2 id="类型，存储和变量"><a href="#类型，存储和变量" class="headerlink" title="类型，存储和变量"></a>类型，存储和变量</h2><hr><p>如果要描述程序代码特征的话，我们可以说 C 程序就是一组函数和数据类型，C++ 程序就是一组函数和类，而 C# 则是一组类型声明。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyProgram</span><br>&#123;<br>    DeclarationOfTypeA<br>    DeclarationOfTypeB<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><code class="language-hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyProgram</span><br>&#123;<br>    DeclarationOfTypeA<br>    DeclarationOfTypeB<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>        &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="类型是一种模板"><a href="#类型是一种模板" class="headerlink" title="类型是一种模板"></a>类型是一种模板</h3><p>我们学习 C#，其实就是学习如何创建和使用类型，所以我们需要了解什么是类型。<br>我们可以把类型想象成创建数据结构的模板，模板本身不是数据结构，但可以描述由改模板构造的对象特征。<br>类型由下面元素定义: </p><ul><li>名称</li><li>保存数据成员的结构</li><li>一些行为和约束</li></ul><p>比如，int 类型: </p><ul><li>名称: int</li><li>结构: 4 字节</li><li>行为: 32 位整数</li></ul><h3 id="实例化类型"><a href="#实例化类型" class="headerlink" title="实例化类型"></a>实例化类型</h3><p>从模板创建实际对象的过程，就称为实例化该类型。</p><ul><li>通过实例化类型创建的对象，可以称为对象，也可以称为实例</li><li>C# 中，每个数据项都是某种类型的实例</li></ul><h3 id="数据成员和函数成员"><a href="#数据成员和函数成员" class="headerlink" title="数据成员和函数成员"></a>数据成员和函数成员</h3><p>像 short，long 等这样的类型称为简单类型，只能存储一个数据项。</p><p>其他的类型可以存储多个数据项，如数组类型就可以存储多个相同类型的数据项。这些数据项称为数组元素，通过索引来获取每个数组元素。C# 数组这一特征与 Objective-C 相同，与 JavaScript 的特征不同。</p><p>然而，另外一些类型可以包含不同类型的数据项，这些类型中的数据项个体称为 <strong>成员</strong>。<br>有两种成员: </p><ul><li>数据成员</li><li>函数成员</li></ul><h3 id="预定义类型"><a href="#预定义类型" class="headerlink" title="预定义类型"></a>预定义类型</h3><p>C# 提供了 16 种预定义类型，包括 13 种简单类型和 3 种非简单类型。<br>所有预定义类型由全小写字母组成，预定义的简单类型包括以下 3 种: </p><ul><li>11 种数值类型: <ol><li>不同长度的有符号和无符号整数类型</li><li>浮点数类型: float 和 double</li><li>高精度小数类型: decimal</li></ol></li><li>1 种 Unicode 字符类型: char</li><li>1 种布尔类型: bool</li></ul><p>与 Objective-C 或 JavaScript 不同，C# 中的数值类型不具有布尔含义。</p><p>3 种非简单类型: </p><ul><li>string: Unicode 字符数组</li><li>object: 所有其他类型的基类</li><li>dynamic</li></ul><p>注意: 在 C# 程序中，应使用小写的 C# 类型名称而不是大写的 .Net 类型名称。</p><h3 id="用户定义类型"><a href="#用户定义类型" class="headerlink" title="用户定义类型"></a>用户定义类型</h3><p>有 6 种类型可以由用户自己创建: </p><ul><li>class 类型</li><li>struct 类型</li><li>array 类型</li><li>enum 类型</li><li>delegate 类型</li><li>interface 类型</li></ul><p>类型通过类型声明创建，类型声明包含以下信息: </p><ul><li>要创建的类型种类</li><li>新类型名称</li><li>对每个成员的声明(array 和 delegate 除外，他们没有命名成员)</li></ul><p>一旦声明了类型，就可以像预定义类型一样使用了。</p><p>预定义类型已经由系统创建好了，我们直接使用即可，而用户定义类型，我们使用前需要先进行声明，再使用。</p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p>对于非成员数据的存储(如函数中的局部变量): </p><ul><li>值类型存储于栈内存</li><li>引用类型的 <strong>数据部分</strong> 存储于堆内存，<strong>引用部分</strong> 存放在栈内存</li></ul><p>对于成员数据，存储有些不同: </p><ul><li>引用类型的 <strong>数据部分</strong> 始终存放在堆内存</li><li>值类型的对象，或者引用类型的 <strong>引用部分</strong>，可能存储在栈内存，也可能存储在堆内存，取决于执行环境</li></ul><h3 id="C-类型分类"><a href="#C-类型分类" class="headerlink" title="C# 类型分类"></a>C# 类型分类</h3><ul><li>预定义类型: 对于简单类型都是值类型，非简单类型都是引用类型</li><li>用户定义类型: struct 和 enum 类型是值类型，其他 4 种是引用类型</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>C# 提供了 4 中变量: </p><ul><li>本地变量</li><li>字段</li><li>参数</li><li>数组元素</li></ul><p>变量在使用前必须声明。变量声明完成了两件事: </p><ul><li>给变量命名，并关联了一种类型</li><li>让编译器为它分配了一块内存</li></ul><p>我们还可以直接在声明时初始化变量。<br>一些类型的变量如果在声明时没有初始化，那么会被自动设置为默认值。<br>注意: 本地变量和参数不会被自动初始化，类字段，结构字段和数组元素会被自动初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前本来想学习一下 NodeJS，考虑到最近一直在使用 C#(主要使用 .Net Core 的 MVC 和 API)，并且之前也仔细地研究过一段时间的 C#，.Net 平台的发展也有上升趋势，最近微软收购 Github，打算整合自己的平台，还有 Visual Studio </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%BA%8C)/"/>
    <id>https://1ess.github.io/C#(%E4%BA%8C)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们看看 C# 中的类有哪些特殊的概念。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>上一篇，我们说过用户定义类型有 6 种，其中最重要的就是类类型，类是面向对象的基础。<br>程序的数据和功能被组织为逻辑上相关的数据项和函数的封装集合就称为类(class)。<br>类是一种能存储数据并执行代码的数据结构，包含数据成员和函数成员。<br>数据成员包括: </p><ul><li>字段</li><li>常量</li></ul><p>函数成员包括: </p><ul><li>方法</li><li>属性</li><li>构造函数</li><li>析构函数</li><li>运算符</li><li>索引器</li><li>事件</li></ul><h2 id="声明类-类定义"><a href="#声明类-类定义" class="headerlink" title="声明类(类定义)"></a>声明类(类定义)</h2><hr><p>类的声明提供以下内容: </p><ul><li>类的名称</li><li>类的成员</li><li>类的特征</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-comment">//成员声明</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>字段是属于类的变量，可以被写入和读取。与 Objective-C 和 JavaScript 不同，所有字段都属于类型，必须在内部声明，也就是说没有全局变量的概念。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-built_in">int</span> MyField;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>之前也说过字段是可以被自动初始化的，每种类型的默认值都是 0，bool 类型为 false，引用类型为 null。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法是可执行的代码块。方法声明包括以下组成部分: </p><ul><li>返回值类型，如果没有返回值，则指定为 void</li><li>方法名</li><li>参数列表，至少是一个空圆括号</li><li>方法体，包裹在一对大括号之间</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyFunc</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyFunc</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">"Hello World!"</span>);<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><p>与 JavaScript 类似，使用 new 操作符实例化一个对象。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">MyClass mc = <span class="hljs-keyword"><code class="language-hljs csharp">MyClass mc = <span class="hljs-keyword">new</span> MyClass();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>类中的成员可分为: </p><ul><li>实例成员</li><li>静态成员</li></ul><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>访问修饰符是可选部分，放在简单声明之前。<br>5 种成员访问控制如下: </p><ul><li>private</li><li>public</li><li>protected</li><li>internal</li><li>protected internal</li></ul><p>私有访问只能从声明他的类内访问，<strong>私有访问是默认的访问级别</strong>。</p><h3 id="类内类外访问成员"><a href="#类内类外访问成员" class="headerlink" title="类内类外访问成员"></a>类内类外访问成员</h3><p>在类内可以直接使用成员名来访问成员，而要从类外访问实例成员，必须使用点运算符访问。</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><hr><p>C# 方法体是一个块，包含以下项目: </p><ul><li>本地变量</li><li>控制流结构</li><li>方法调用</li><li>内嵌块</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">3</span>) &#123;<br>        Console.WriteLine(<span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">3</span>) &#123;<br>        Console.WriteLine(<span class="hljs-string">"a"</span>);<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><p>字段保存的是与类或对象有关的数据，本地变量保存临时信息。<br>本地变量的生命周期从声明的那一刻开始存在，在块完成执行时结束存在。<br>并且本地变量是没有隐式初始化的，所以在使用之前没有显示初始化的话，编译器会产生错误信息。</p><p>在声明本地变量时可以使用 var 关键字，条件是: </p><ul><li>只能用于本地变量，不能用于字段</li><li>只能用于声明时包含初始化的语句</li><li>一旦编译器推断出类型，他就是固定且不能更改的</li></ul><p>注意: C# 中的 var 与 JavaScript 中的不同。</p><h3 id="本地常量"><a href="#本地常量" class="headerlink" title="本地常量"></a>本地常量</h3><p>本地常量和本地变量类似，只是本地常量一旦初始化，他的值就不能更改: </p><ul><li>本地常量在声明时必须初始化</li><li>常量在声明之后不能更改</li><li>声明时，在类型之前加 const 关键字</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayRadii</span>(<span class="hljs-params"></span>)</span> <br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> PI = <span class="hljs-number">3.1416</span>;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayRadii</span>(<span class="hljs-params"></span>)</span> <br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> PI = <span class="hljs-number">3.1416</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><hr><h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><p>形参是本地变量，它声明在方法的参数列表中，而不是函数体中。</p><h3 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h3><p>用于初始化形参的表达式或变量称为实参(argument)。<br>实参的数量必须与形参的数量一致，并且每个实参的类型也必须与对应的形参类型一致。这种形式的参数称为<strong>位置参数</strong>。</p><h3 id="值参数"><a href="#值参数" class="headerlink" title="值参数"></a>值参数</h3><p>通过将实参的值复制到形参的方式，将数据传递给方法，就称为值参数。<br>使用值参数方法被调用时，系统做如下操作: </p><ul><li>在栈中为形参分配空间</li><li>将实参的值复制给形参</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Val = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params">MyClass f1, <span class="hljs-built_in">int</span> f2</span>)</span><br>    &#123;<br>        f1.Val = f1.Val + <span class="hljs-number">5</span>;<br>        f2 = f2 + <span class="hljs-number">5</span>;<br>        Console.iteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, f1.Val, f2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass();<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>        MyMethod(cls, a); <span class="hljs-comment">// 25, 15</span><br>        Console.WriteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, cls.Val, a);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Val = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params">MyClass f1, <span class="hljs-built_in">int</span> f2</span>)</span><br>    &#123;<br>        f1.Val = f1.Val + <span class="hljs-number">5</span>;<br>        f2 = f2 + <span class="hljs-number">5</span>;<br>        Console.iteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, f1.Val, f2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass();<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>        MyMethod(cls, a); <span class="hljs-comment">// 25, 15</span><br>        Console.WriteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, cls.Val, a);  <span class="hljs-comment">// 25, 10</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><ul><li>在使用引用参数时，在方法声明以及调用时，都要在参数前使用 ref 关键字</li><li>实参必须是变量</li></ul><p>引用参数有如下特征: </p><ul><li>不会为形参在栈上分配空间</li><li>实际情况是，形参的参数名将作为实参的别名，指向相同的内存位置</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Val = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MyClass f1, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> f2</span>)</span><br>    &#123;<br>        f1.Val = f1.Val + <span class="hljs-number">5</span>;<br>        f2 = f2 + <span class="hljs-number">5</span>;<br>        Console.iteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, f1.Val, f2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass();<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>        MyMethod(<span class="hljs-keyword">ref</span> cls, <span class="hljs-keyword">ref</span> a); <span class="hljs-comment">// 25, 15</span><br>        Console.WriteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, cls.Val, a);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Val = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MyClass f1, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> f2</span>)</span><br>    &#123;<br>        f1.Val = f1.Val + <span class="hljs-number">5</span>;<br>        f2 = f2 + <span class="hljs-number">5</span>;<br>        Console.iteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, f1.Val, f2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass();<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>        MyMethod(<span class="hljs-keyword">ref</span> cls, <span class="hljs-keyword">ref</span> a); <span class="hljs-comment">// 25, 15</span><br>        Console.WriteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, cls.Val, a);  <span class="hljs-comment">// 25, 15</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们要注意引用类型作为值参数和引用参数的不同，他们都可以改变成员的值，但是当在方法内给这个引用重新赋值就不同了: </p><ul><li>当是值参数时，会切断与实参的联系</li><li>当是引用参数时，会改变实参的指向</li></ul><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>输出参数用于从方法体内把数据传递到调用的代码，如同引用参数，输出参数有如下要求: </p><ul><li>必须在声明和调用时同时使用 out 关键字</li><li>实参必须是变量</li><li>在方法内部，输出参数在能被读取之前必须被赋值，这意味着，参数初始值是无用的，没必要在调用输出参数方法时给输出参数初始化</li><li>在方法返回之前，所有路径都必须已经给输出参数进行过一次赋值</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Val = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> MyClass f1, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> f2</span>)</span><br>    &#123;<br>        f1 = <span class="hljs-keyword">new</span> MyClass();<br>        f2 = <span class="hljs-number">10</span>;<br>        Console.iteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, f1.Val, f2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyClass cls;<br>        <span class="hljs-built_in">int</span> a;<br>        MyMethod(<span class="hljs-keyword">out</span> cls, <span class="hljs-keyword">out</span> a); <span class="hljs-comment">// 20, 10</span><br>        Console.WriteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, cls.Val, a);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Val = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> MyClass f1, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> f2</span>)</span><br>    &#123;<br>        f1 = <span class="hljs-keyword">new</span> MyClass();<br>        f2 = <span class="hljs-number">10</span>;<br>        Console.iteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, f1.Val, f2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyClass cls;<br>        <span class="hljs-built_in">int</span> a;<br>        MyMethod(<span class="hljs-keyword">out</span> cls, <span class="hljs-keyword">out</span> a); <span class="hljs-comment">// 20, 10</span><br>        Console.WriteLine(<span class="hljs-string">&quot;f1: &#123;0&#125;, f2: &#123;1&#125;&quot;</span>, cls.Val, a);  <span class="hljs-comment">// 20, 10</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="参数数组"><a href="#参数数组" class="headerlink" title="参数数组"></a>参数数组</h3><p>参数数组允许零个或多个实参对应一个特殊的形参。参数数组的特征如下: </p><ul><li>在一个参数列表中只能有一个参数数组</li><li>如果有，必须位于参数列表的最后一个</li><li>参数数组中的所有参数必须具有相同类型</li><li>在声明时使用 param 修饰符，并在类型后加 []</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListInts</span>(<span class="hljs-params">param <span class="hljs-built_in">int</span>[] intVals</span>)</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListInts</span>(<span class="hljs-params">param <span class="hljs-built_in">int</span>[] intVals</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>有两种方式为参数数组提供实参: </p><ul><li>用逗号分隔的该类型元素的列表(延展式)</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">ListInts(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number"><code class="language-hljs csharp">ListInts(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>一个该数据类型的一维数组</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] intArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] intArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>ListInts(intArray);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 与之前三种参数不同，参数数组不用在调用时使用 params 修饰符。</p><p>当使用延展式调用参数数组函数时，编译器会接受实参列表，并在堆中初始化一个数组，将数组的引用保存到栈中的形参里。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ListInts</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] intVals</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (intVals != <span class="hljs-literal">null</span> &amp;&amp; intVals.Length != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; intVals.Length; i++) &#123;<br>                intVals[i] = intVals[i] * <span class="hljs-number">10</span>;<br>                Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>, intVals[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> first = <span class="hljs-number">5</span>, second = <span class="hljs-number">6</span>, third = <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass();<br>        cls.ListInts(first, second, third);  <span class="hljs-comment">//50, 60, 70</span><br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;</span>, first, second, third);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ListInts</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] intVals</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (intVals != <span class="hljs-literal">null</span> &amp;&amp; intVals.Length != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; intVals.Length; i++) &#123;<br>                intVals[i] = intVals[i] * <span class="hljs-number">10</span>;<br>                Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>, intVals[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> first = <span class="hljs-number">5</span>, second = <span class="hljs-number">6</span>, third = <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass();<br>        cls.ListInts(first, second, third);  <span class="hljs-comment">//50, 60, 70</span><br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;</span>, first, second, third);  <span class="hljs-comment">//5, 6, 7</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>当使用数组作为实参时，编译器直接使用你的数组而不重新创建。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ListInts</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] intVals</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (intVals != <span class="hljs-literal">null</span> &amp;&amp; intVals.Length != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; intVals.Length; i++) &#123;<br>                intVals[i] = intVals[i] * <span class="hljs-number">10</span>;<br>                Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>, intVals[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] intArray = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass();<br>        cls.ListInts(intArray);  <span class="hljs-comment">//50, 60, 70</span><br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;</span>, intArray[<span class="hljs-number">0</span>], intArray[<span class="hljs-number">1</span>], intArray[<span class="hljs-number">2</span>]);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ListInts</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] intVals</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (intVals != <span class="hljs-literal">null</span> &amp;&amp; intVals.Length != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; intVals.Length; i++) &#123;<br>                intVals[i] = intVals[i] * <span class="hljs-number">10</span>;<br>                Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>, intVals[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] intArray = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass();<br>        cls.ListInts(intArray);  <span class="hljs-comment">//50, 60, 70</span><br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;</span>, intArray[<span class="hljs-number">0</span>], intArray[<span class="hljs-number">1</span>], intArray[<span class="hljs-number">2</span>]);  <span class="hljs-comment">//50, 60, 70</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="方法重载-method-overload"><a href="#方法重载-method-overload" class="headerlink" title="方法重载(method overload)"></a>方法重载(method overload)</h3><p>一个类中可以有一个以上的方法具有相同的名称，这就叫做方法重载。<br>但是每个同名的方法必须有不同的方法签名。<br>方法签名由如下信息组成: </p><ul><li>方法名</li><li>参数数目</li><li>参数类型和顺序</li><li>参数的修饰符</li></ul><p>注意: 返回值类型和参数名不是方法签名的一部分。<br>也要注意与继承概念中的方法重写(method override)的区别</p><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>之前我们讲的都是位置参数，此外 C# 还允许使用命名参数。<br>在调用方法时，形参名后跟冒号和实参: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">c.Calc(a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number"><code class="language-hljs csharp">c.Calc(a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>方法在调用时，可以既有位置参数又有命名参数，如果这么做，所有的位置参数必须先列出。<br>与 Swift 中的函数调用很相似。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>C# 还允许可选参数，我们需要在函数声明时在可选参数中指定默认值: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Calc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b = <span class="hljs-number">3</span></span>)</span> <br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>Calc(<span class="hljs-number">5</span>);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Calc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b = <span class="hljs-number">3</span></span>)</span> <br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>Calc(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 8</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>方法声明中参数的语法顺序: 必填参数 - 可选参数 - 参数数组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们看看 C# 中的类有哪些特殊的概念。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;上一篇，我们说过用户定义类型有 6 种，其中最重要的就是类类型，类</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%B8%89)/"/>
    <id>https://1ess.github.io/C#(%E4%B8%89)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们深入理解一下 C# 中的类。</p><h2 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h2><hr><p>上篇我们说过了 2 个类成员: 字段和方法。这一篇我们介绍除了事件和运算符之外的成员。</p><h3 id="成员修饰符的顺序"><a href="#成员修饰符的顺序" class="headerlink" title="成员修饰符的顺序"></a>成员修饰符的顺序</h3><p>成员声明语句有下列部分组成: 核心声明，可选的修饰符和可选的特性(attribute)。<br>[特性] [修饰符] 核心声明;<br>我们之前说过的 public 和 private 都是修饰符，还有 static 和 const 也都是修饰符。</p><h3 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h3><p>成员可以关联到一个类的实例，也可以关联到类的整体，默认情况下，成员被关联到一个实例，这些成员称为实例成员。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>         <span class="hljs-keyword">var</span> cls1 = <span class="hljs-keyword">new</span> MyClass();<br>         <span class="hljs-keyword">var</span> cls2 = <span class="hljs-keyword">new</span> MyClass();<br>         cls1.a = <span class="hljs-number">10</span>;<br>         cls2.a = <span class="hljs-number">20</span>;<br>         Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;  --  &#123;1&#125;&quot;</span>, cls1.a, cls2.a);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>         <span class="hljs-keyword">var</span> cls1 = <span class="hljs-keyword">new</span> MyClass();<br>         <span class="hljs-keyword">var</span> cls2 = <span class="hljs-keyword">new</span> MyClass();<br>         cls1.a = <span class="hljs-number">10</span>;<br>         cls2.a = <span class="hljs-number">20</span>;<br>         Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;  --  &#123;1&#125;&quot;</span>, cls1.a, cls2.a);  <span class="hljs-comment">// 10 -- 20</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>除了实例成员，类还可以拥有静态成员。静态成员被所有实例共享，访问内存同一位置，使用 static 修饰符将成员声明为静态。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-built_in">int</span> Mem1;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Mem2;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>         <span class="hljs-keyword">var</span> cls1 = <span class="hljs-keyword">new</span> MyClass();<br>         <span class="hljs-keyword">var</span> cls2 = <span class="hljs-keyword">new</span> MyClass();<br>         cls1.Mem1 = <span class="hljs-number">10</span>;<br>         MyClass.Mem2 = <span class="hljs-number">1</span>;<br>         cls2.Mem1 = <span class="hljs-number">20</span>;<br>         MyClass.Mem2 = <span class="hljs-number">2</span>;<br>         Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;  --  &#123;1&#125;&quot;</span>, cls1.Mem1 , cls2.Mem1 );  <span class="hljs-comment">// 10 -- 20</span><br>         Console.WriteLine(MyClass.Mem2);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-built_in">int</span> Mem1;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Mem2;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>         <span class="hljs-keyword">var</span> cls1 = <span class="hljs-keyword">new</span> MyClass();<br>         <span class="hljs-keyword">var</span> cls2 = <span class="hljs-keyword">new</span> MyClass();<br>         cls1.Mem1 = <span class="hljs-number">10</span>;<br>         MyClass.Mem2 = <span class="hljs-number">1</span>;<br>         cls2.Mem1 = <span class="hljs-number">20</span>;<br>         MyClass.Mem2 = <span class="hljs-number">2</span>;<br>         Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;  --  &#123;1&#125;&quot;</span>, cls1.Mem1 , cls2.Mem1 );  <span class="hljs-comment">// 10 -- 20</span><br>         Console.WriteLine(MyClass.Mem2);  <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="类外访问静态成员"><a href="#类外访问静态成员" class="headerlink" title="类外访问静态成员"></a>类外访问静态成员</h3><p>与实例成员一样在类外使用点运算符来访问静态成员，只不过是使用类名来访问。<br>静态函数成员不能访问实例成员，他们可以访问其他静态成员。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> A;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(A);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> A;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(A);  <span class="hljs-comment">//可以在静态方法访问静态字段</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>除了<strong>常量</strong>和<strong>索引器</strong>，其他成员都可以是静态成员。</p><h3 id="成员常量"><a href="#成员常量" class="headerlink" title="成员常量"></a>成员常量</h3><p>如同本地常量一样，只是成员常量被声明在类中: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> IntVal = <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> IntVal = <span class="hljs-number">5</span>;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>成员常量表现得很像静态值，他们对每个实例都是可见的，但是他们没有自己的存储位置，只是在编译期被替换。类似于 C 语言的 #define。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> PI = <span class="hljs-number">3.14156</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(MyClass.PI);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> PI = <span class="hljs-number">3.14156</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(MyClass.PI);  <span class="hljs-comment">// 3.14156</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 虽然成员常量表现得像静态量，但是不能使用 static 修饰符修饰。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>C# 中的属性非常像 Swift 中的计算属性。他们在使用时非常像字段，但是和字段不同的是，他们是函数成员，可以执行代码。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> MyVal <br>&#123;<br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-comment">//get</span><br>    &#125;<br><br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> MyVal <br>&#123;<br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-comment">//get</span><br>    &#125;<br><br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        <span class="hljs-comment">//set</span><br>    &#125;<br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>set 访问器拥有一个隐式的名为 value 的值参数，与属性类型相同，返回值为 void。<br>get 访问器没有参数，有一个与属性相同类型的返回值。<br>我们要注意: 属性本身没有任何存储，通常要有一个关联字段作为存储。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _intVal;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IntVal<br>&#123;<br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        _intVal = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _intVal;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IntVal<br>&#123;<br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        _intVal = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> _intVal;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们还可以设置只读属性(只有 get 方法)或者只写属性(只有 set 方法)，但是两个访问器至少要定义一个，否则编译器会报错。<br>C# 还提供了自动属性实现，不需要提供关联字段，也不需要提供访问器的方法体，get 和 set 后直接跟分号。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IntVal &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IntVal &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>属性也可以被声明为静态，与静态字段一样，使用类名访问静态属性。</p><h3 id="实例构造函数"><a href="#实例构造函数" class="headerlink" title="实例构造函数"></a>实例构造函数</h3><p>构造函数是一个特殊的方法，他在创建类实例时执行，用于初始化实例状态。通常声明为 public。<br>它的特点是: </p><ul><li>构造函数没有返回值</li><li>构造函数名称与类名相同</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>构造函数也可以被重载，带有不同的参数: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span><br>&#123;<br>    <span class="hljs-built_in">int</span> Id;<br>    <span class="hljs-built_in">string</span> Name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class1</span>(<span class="hljs-params"></span>)</span> &#123; Id = <span class="hljs-number">1</span>; Name=<span class="hljs-string">&quot;1ess&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Id</span>)</span> &#123; <span class="hljs-keyword">this</span>.Id = Id; Name=<span class="hljs-string">&quot;1ess&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> Name</span>)</span> &#123; Id = <span class="hljs-number">1</span>; <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span><br>&#123;<br>    <span class="hljs-built_in">int</span> Id;<br>    <span class="hljs-built_in">string</span> Name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class1</span>(<span class="hljs-params"></span>)</span> &#123; Id = <span class="hljs-number">1</span>; Name=<span class="hljs-string">&quot;1ess&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Id</span>)</span> &#123; <span class="hljs-keyword">this</span>.Id = Id; Name=<span class="hljs-string">&quot;1ess&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> Name</span>)</span> &#123; Id = <span class="hljs-number">1</span>; <span class="hljs-keyword">this</span>.Name=Name; &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果我们没有为类提供构造函数，那么编译器会隐式提供一个无参构造函数，方法体为空。<br>如果我们显示提供了一个构造函数，那么就不会为我们创建一个隐式的无参构造函数。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span><br>&#123;    <br>    <span class="hljs-built_in">int</span> Id;<br>    <span class="hljs-built_in">string</span> Name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Id</span>)</span> &#123; <span class="hljs-keyword">this</span>.Id = Id; Name=<span class="hljs-string">&quot;1ess&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> Name</span>)</span> &#123; Id = <span class="hljs-number">1</span>; <span class="hljs-keyword">this</span>.Name=Name; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Class2 cls2 = <span class="hljs-keyword">new</span> Class2();  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span><br>&#123;    <br>    <span class="hljs-built_in">int</span> Id;<br>    <span class="hljs-built_in">string</span> Name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Id</span>)</span> &#123; <span class="hljs-keyword">this</span>.Id = Id; Name=<span class="hljs-string">&quot;1ess&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Class2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> Name</span>)</span> &#123; Id = <span class="hljs-number">1</span>; <span class="hljs-keyword">this</span>.Name=Name; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Class2 cls2 = <span class="hljs-keyword">new</span> Class2();  <span class="hljs-comment">// 错误，编译器不会再隐式提供无参构造函数</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><p>这一点与很多语言不同，构造函数也可以是静态的，用来初始化静态成员。调用时机是: </p><ul><li>在引用任何静态成员之前</li><li>在创建类的任何实例之前</li></ul><p>静态构造函数的特点是: </p><ul><li>名称必须与类名相同</li><li>不能有返回值</li><li>只能有一个静态构造函数</li><li>不能有参数</li><li>不能有访问修饰符</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Class1</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Class1</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//执行静态成员初始化</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>在静态构造函数不能访问实例成员，我们也不能显示的调用静态构造函数。</p><h3 id="对象初始化语句"><a href="#对象初始化语句" class="headerlink" title="对象初始化语句"></a>对象初始化语句</h3><p>对象初始化语句扩展创建语法，在表达式的尾部放置一组成员初始化语句，允许我们在创建实例时，设置字段和属性值。<br>该语法有两种形式: </p><ul><li>包括构造函数的参数列表</li><li>不包括构造函数的参数列表</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">new</span> TypeName(ArgList) &#123; FieldOrProp = InitVal, FieldOrProp = InitVal, ...&#125;;<br><span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">new</span> TypeName(ArgList) &#123; FieldOrProp = InitVal, FieldOrProp = InitVal, ...&#125;;<br><span class="hljs-keyword">new</span> TypeName &#123; FieldOrProp = InitVal, FieldOrProp = InitVal, ...&#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>要注意: 初始化列表中的字段和属性都是可访问的(public)，并且<strong>初始化语句执行于构造方法之后</strong>。</p><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>this 是对当前实例的引用，只能被用于: </p><ul><li>实例构造方法</li><li>实例方法</li><li>属性和索引器的实例访问器</li></ul><p>this 的目的用于区分成员和本地变量: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Say</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span> <br>    &#123;<br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Say</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span> <br>    &#123;<br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>不推荐参数和字段同名。</p><h3 id="分部类和分部类型"><a href="#分部类和分部类型" class="headerlink" title="分部类和分部类型"></a>分部类和分部类型</h3><p>类的声明可以分割成几个分部类声明: </p><ul><li>每个分部类都含有一些类成员声明</li><li>每个局部声明必须标记为 partial class</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>   <span class="hljs-built_in">int</span> a;<br>&#125;<br><br><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>   <span class="hljs-built_in">int</span> a;<br>&#125;<br><br><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-built_in">int</span> b;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>除了分部类，还有分部结构和分部接口，我们之后说。</p><h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p>分部方法是声明在分部类的不同部分的方法。<br>分部方法两部分如下: </p><ul><li>分部方法的声明</li><li>分部方法的实现</li></ul><p>分部方法的特征: </p><ul><li>声明部分和实现部分的返回值和方法签名必须一致，并且，返回值必须是 void</li><li>不能有访问修饰符修饰，也就是分部方法隐式私有</li><li>不能有输出参数</li><li>方法声明和方法实现之前要有 partial 修饰</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        Add(a, b);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;a + b = <span class="hljs-subst">&#123;a + b&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass1();<br>        cls.PrintSum(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        Add(a, b);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;a + b = <span class="hljs-subst">&#123;a + b&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">new</span> MyClass1();<br>        cls.PrintSum(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);  <span class="hljs-comment">// 11</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们深入理解一下 C# 中的类。&lt;/p&gt;
&lt;h2 id=&quot;类的成员&quot;&gt;&lt;a href=&quot;#类的成员&quot; class=&quot;headerlink&quot; title=&quot;类的成员&quot;&gt;&lt;/a&gt;类的成员&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;上篇我们说过了 2 个类成员: 字段和方法。这一篇我们介绍</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%9B%9B)/"/>
    <id>https://1ess.github.io/C#(%E5%9B%9B)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中关于继承的相关知识。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><p>通过继承我们可以定义新的派生类(derived class)，来对基类(base class)进行扩展。<br>派生类的成员包括: </p><ul><li>本身声明的成员</li><li>基类的成员</li></ul><p>注意: 派生类不能删除它所继承的任何成员。</p><p>要声明一个派生类，需要在类名后跟一个冒号，然后跟基类名。与 Objective-C 的继承声明相同。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>     <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>     <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>继承的成员可以被访问，就像他们是派生类本身声明的一样: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;base class field&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Base class -- Method1:    &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field2 = <span class="hljs-string">&quot;derived class&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Derived class -- Method2:    &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        OtherClass oc = <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;base class field&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Base class -- Method1:    &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field2 = <span class="hljs-string">&quot;derived class&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Derived class -- Method2:    &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        OtherClass oc = <span class="hljs-keyword">new</span> OtherClass();<br><br>        oc.Method1(oc.Field1);<br>        oc.Method1(oc.Field2);        <br>        oc.Method2(oc.Field1);<br>        oc.Method2(oc.Field2);        <br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>除了 object，所有的类都是派生类，object 是唯一的非派生类，他是继承层次结构的基础。<br>没有基类声明的类隐式直接派生自 object 类。<br>C# 中的继承是单继承，与 Objective-C、JavaScript 一样。<br>通常我们称一个类为派生类时，我们是说他直接派生自某个类而不是 object。</p><h3 id="屏蔽基类成员"><a href="#屏蔽基类成员" class="headerlink" title="屏蔽基类成员"></a>屏蔽基类成员</h3><p>我们虽然不能删除基类的任何成员，但是我们可以使用与基类名相同名称的成员来屏蔽基类成员。<br>在派生类屏蔽基类成员的要点如下: </p><ul><li>要屏蔽一个数据成员，需要声明一个新的相同类型的同名成员</li><li>要屏蔽一个函数成员，需要在派生类中声明带有相同签名的函数成员</li><li>要然编译器知道我们故意屏蔽基类成员，需要使用 new 修饰符。否则屏蔽成员会报警告</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;SomeClass Field1&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;SomeClass.Method1: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;OtherClass Field1&quot;</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;OtherClass.Method1: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        OtherClass oc = <span class="hljs-keyword">new</span> OtherClass();<br>        oc.Method1(oc.Field1);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;SomeClass Field1&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;SomeClass.Method1: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span><br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;OtherClass Field1&quot;</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;OtherClass.Method1: &#123;0&#125;&quot;</span>, <span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        OtherClass oc = <span class="hljs-keyword">new</span> OtherClass();<br>        oc.Method1(oc.Field1);  <span class="hljs-comment">//OtherClass.Method1: OtherClass Field1</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="基类访问"><a href="#基类访问" class="headerlink" title="基类访问"></a>基类访问</h3><p>如果要在派生类中需要访问被屏蔽的成员，可以使用基类访问表达式来访问隐藏的成员。<br>基类访问表达式由关键字 base 后跟点操作符加要访问的成员: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>, <span class="hljs-keyword"><code class="language-hljs csharp">Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>, <span class="hljs-keyword">base</span>.Field1);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果程序需要经常使用这个特性，可能需要重新设计了。</p><h3 id="使用基类的引用"><a href="#使用基类的引用" class="headerlink" title="使用基类的引用"></a>使用基类的引用</h3><p>派生类的引用指向整个类结构，包括基类部分。<br>如果有一个派生类引用，我们就可以获取对象基类部分的引用(使用类型转换): </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is base class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is derived class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        DerivedClass dc = <span class="hljs-keyword">new</span> DerivedClass();<br>        BaseClass bc = (BaseClass)dc;<br>        dc.Print();  <span class="hljs-comment">// derived class print</span><br>        bc.Print();  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is base class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is derived class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        DerivedClass dc = <span class="hljs-keyword">new</span> DerivedClass();<br>        BaseClass bc = (BaseClass)dc;<br>        dc.Print();  <span class="hljs-comment">// derived class print</span><br>        bc.Print();  <span class="hljs-comment">// base class print</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>通过类型转换而来的”基类”，不能”看”到派生类的部分。</p><h3 id="虚方法和覆写方法"><a href="#虚方法和覆写方法" class="headerlink" title="虚方法和覆写方法"></a>虚方法和覆写方法</h3><p>虚方法可以使基类的引用访问”提升”至派生类，只需满足如下条件: </p><ul><li>派生类的方法和基类的方法的签名和返回值都一致</li><li>基类方法使用 virtual 标注</li><li>派生类方法使用 override 标注</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is base class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is derived class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        DerivedClass dc = <span class="hljs-keyword">new</span> DerivedClass();<br>        BaseClass bc = (BaseClass)dc;<br>        dc.Print();  <span class="hljs-comment">// derived class print</span><br>        bc.Print();  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is base class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is derived class method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        DerivedClass dc = <span class="hljs-keyword">new</span> DerivedClass();<br>        BaseClass bc = (BaseClass)dc;<br>        dc.Print();  <span class="hljs-comment">// derived class print</span><br>        bc.Print();  <span class="hljs-comment">// derived class print</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>关于 virtual 和 override 修饰符的重要信息如下: </p><ul><li>覆写和被覆写的方法必须具有相同的访问性</li><li>不能覆写 static 方法和非虚方法</li><li>方法、属性、索引器和事件可以被声明为 virtual 和 override</li></ul><p>覆写方法可以在继承的任何层次出现，方法的调用会沿着派生层次一直追溯到标记为 override 的最高派生类。</p><p>注意: Objective-C 没有虚方法的概念，Objective-C 中所有的方法都是虚方法: </p><figure class="highlight objectivec"><table><tr><td class="code"><pre class="line-numbers language-hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Animal</span>: <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-keyword">void</span>)sing;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Animal</span></span><br>- (<span class="hljs-keyword">void</span>)sing &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;animal sing&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Dog</span>: <span class="hljs-title">Animal</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Dog</span></span><br>- (<span class="hljs-keyword">void</span>)sing &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;dog sing&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)main &#123;<br>    Dog *dog = [[Dog alloc] init];<br>    Animal *animal = dog;<br>    [dog sing];  <span class="hljs-comment">//&quot;dog sing&quot;</span><br>    [animal sing]; <span class="hljs-comment"><code class="language-hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Animal</span>: <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-keyword">void</span>)sing;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Animal</span></span><br>- (<span class="hljs-keyword">void</span>)sing &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;animal sing&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Dog</span>: <span class="hljs-title">Animal</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Dog</span></span><br>- (<span class="hljs-keyword">void</span>)sing &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;dog sing&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)main &#123;<br>    Dog *dog = [[Dog alloc] init];<br>    Animal *animal = dog;<br>    [dog sing];  <span class="hljs-comment">//&quot;dog sing&quot;</span><br>    [animal sing]; <span class="hljs-comment">//"dog sing"</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p><strong>虚方法是面向对象中多态的基础，多态性又叫动态绑定、推迟绑定或运行期绑定。是允许你将父对象设置成为一个或更多的它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</strong></p><h3 id="构造函数的执行"><a href="#构造函数的执行" class="headerlink" title="构造函数的执行"></a>构造函数的执行</h3><p>派生类对象有一部分就是基类对象: </p><ul><li>要创建对象的基类部分，需要隐式的调用基类的某个构造函数作为实例创建的一部分</li><li>每个类在执行自己的构造函数之前要执行基类的构造函数</li></ul><p><strong>默认情况，构造对象时，将调用基类的无参构造函数</strong>，如果希望派生类调用的是有参构造的话，就需要构造函数初始化语句。<br>有两种形式的构造函数初始化语句: </p><ul><li>使用 base 并指明使用哪一个基类的构造函数</li><li>使用 this 并指明使用哪一个当前类的构造函数</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> MyDerivedClass<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">string</span> s</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">base</span>(<span class="hljs-params">x, s</span>)</span> <br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> MyDerivedClass<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">string</span> s</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">base</span>(<span class="hljs-params">x, s</span>)</span> <br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>另外，我们可以需要在构造函数中使用当前类的其他构造: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> a;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        a = <span class="hljs-number">10</span>;<br>        b = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">this</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        FirstName = firstName;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> lastName</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">this</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        LastName = lastName;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> a;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        a = <span class="hljs-number">10</span>;<br>        b = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">this</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        FirstName = firstName;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> lastName</span>) </span><br><span class="hljs-function">    : <span class="hljs-title">this</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        LastName = lastName;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="类的访问修饰符"><a href="#类的访问修饰符" class="headerlink" title="类的访问修饰符"></a>类的访问修饰符</h3><p>类的可访问修饰符有两种: public 和 internal: </p><ul><li>标记为 public 的类可以被系统内任何程序集访问</li><li>标记为 internal 的类只能被该类所在的程序集访问</li></ul><p>注意: internal 是类的默认访问级别。</p><h3 id="成员的访问修饰符"><a href="#成员的访问修饰符" class="headerlink" title="成员的访问修饰符"></a>成员的访问修饰符</h3><p>成员的默认的访问级别是 private，并且成员不能比他的类有更高的可访问性。</p><ul><li>private 成员只能被他自己的类访问，不能被其他类访问，包括继承的类。但能被嵌套在他的类中的类访问</li><li>protected 成员访问级别与 private 一样，只是它允许派生自他的类访问该成员</li><li>internal 成员只对程序集内部可见</li><li>protected internal 成员对所有继承自他的类可以访问，也可以对他所在的程序集可访问(注意是并集而不是交集)</li></ul><h3 id="抽象成员和抽象类"><a href="#抽象成员和抽象类" class="headerlink" title="抽象成员和抽象类"></a>抽象成员和抽象类</h3><p>抽象成员是指被设计为被覆写的函数成员，有以下特征: </p><ul><li>必须是函数成员</li><li>必须是由 abstract 修饰符修饰</li><li>没有方法实现代码块</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>抽象成员只能在抽象类中声明，一共有 4 中类型的成员可以声明为抽象: </p><ul><li>方法</li><li>属性</li><li>事件</li><li>索引</li></ul><p>派生类重写抽象成员要是有 override 标记: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">"override abstract method"</span>);<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>抽象类就是被设计为被继承的类，抽象类只能作为其他类的基类: </p><ul><li>我们不能创建抽象类的实例</li><li>抽象类也使用 abstract 修饰符修饰</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyAbstractClass</span><br>&#123;<br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: </p><ul><li>抽象类中可以有非抽象成员</li><li>抽象类可以派生自其他抽象类</li><li>任何派生自抽象类的类必须实现所有抽象成员，除非她本身也是派生类</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassB</span> : <span class="hljs-title">ClassA</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassB</span> : <span class="hljs-title">ClassA</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>密封类与抽象类相反，他不能被继承，使用 sealed 修饰。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySealedClass</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySealedClass</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><ul><li>静态类中所有成员都是静态的</li><li>静态类被标记为 static</li><li>静态类是隐式密封的，也就是说，他不能被继承</li><li>它可以有一个静态构造函数，但不能有实例构造函数</li></ul><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>如果我们不能修改某个类的源文件，而希望给该类添加方法，可以使用扩展方法: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">//必须是静态类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExtendMyClass</span><br>&#123;<br>    <span class="hljs-comment">//必须声明为 public 和 static 方法，参数传入要扩展的类的实例，并且前面加 this 关键字</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Avg</span>(<span class="hljs-params"><span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment">//必须是静态类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExtendMyClass</span><br>&#123;<br>    <span class="hljs-comment">//必须声明为 public 和 static 方法，参数传入要扩展的类的实例，并且前面加 this 关键字</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Avg</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> MyBaseClass bc</span>)</span><br>    &#123;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="C-命名约定"><a href="#C-命名约定" class="headerlink" title="C# 命名约定"></a>C# 命名约定</h3><ul><li>帕斯卡命名: 命名空间、类名、方法、属性和公共字段</li><li>驼峰命名: 私有变量和形参</li><li>下划线加驼峰: 私有和受保护字段</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中关于继承的相关知识。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;通过继承我们可以定义新的派生类(derived class)，来对基</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%BA%94)/"/>
    <id>https://1ess.github.io/C#(%E4%BA%94)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中的表达式和运算符。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr><p>运算符(操作符)是一个符号，表示返回单个结果的操作。<br>一个操作符: </p><ul><li>将操作数作为输入</li><li>执行某个操作</li><li>基于该操作返回一个值</li></ul><p>可以作为操作数的结构有: </p><ul><li>字面量</li><li>常量</li><li>变量</li><li>方法调用</li><li>元素访问器</li><li>其他表达式</li></ul><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>C# 中字面量有: </p><ul><li>整数字面量: 1024</li><li>双精度浮点数字面量: 3.1415</li><li>单精度浮点数字面量: 3.1415F</li><li>布尔值字面量: true，false</li><li>字符字面量: ‘x’</li><li>字符串字面量: “Hi 1ess”</li><li>空引用字面量: null</li></ul><p>根据不同后缀，每个常数能被编译成不同的整数类型: </p><ul><li>后缀 L，被编译成长整型</li><li>后缀 U，被编译成无符号整型</li></ul><p>整型字面量还可以写成十六进制形式，以 0x 或 0X 开头。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> KernelPanic = <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> KernelPanic = <span class="hljs-number">0x12131992</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>与其它语言一样，C# 有加，减，乘，除，取余5种运算符。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>与其它语言一样，C# 有大于、大于等于、小于、小于等于、等于、不等于 6 种关系运算符。<br>需要注意的是: 与 Objective-C 和 JavaScript 中不同，C# 的数字不具有布尔含义。<br>对于比较相等时，除了 string 和 delegate 类型的比较是深比较，其他引用类型的比较都是浅比较，只要指向堆中的对象是同一个对象就相等。</p><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>与其它语言一样，也分为前自增和后自增，前自增先增加 1，在返回新值，后自增先返回原值，再增加 1。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>分为逻辑与，逻辑或和逻辑非。与其它语言一样，逻辑运算符也有<strong>短路特性</strong>。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>有位与、位或、位异或、位非、左移和右移操作符。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>分为简单赋值和复合赋值运算符。</p><h3 id="条件运算符-三目运算符"><a href="#条件运算符-三目运算符" class="headerlink" title="条件运算符(三目运算符)"></a>条件运算符(三目运算符)</h3><p>与其它语言一样，三目运算符是基于条件返回两个值中的一个。</p><h3 id="用户定义类型转换"><a href="#用户定义类型转换" class="headerlink" title="用户定义类型转换"></a>用户定义类型转换</h3><p>类型转换我们之后会详细说，这里我们说一下他作为运算符有哪些特点。<br>我们可以为自己的类或者结构定义隐式转换和显式转换: </p><ul><li>对于隐式转换，编译器会自动执行转换</li><li>对于显式转换，编译器只有在使用显式转换运算符时才会转换</li></ul><p>声明隐式转换的语法: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">//一定要有 public static</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">TargetType</span>(<span class="hljs-params">SourceType Identifier</span>)</span> &#123;<br>    <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment">//一定要有 public static</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">TargetType</span>(<span class="hljs-params">SourceType Identifier</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> ...<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>显式转换的语法一样，只是把 implicit 换成 explicit: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitInt</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TheValue &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">Limit li</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> li.TheValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">LimitInt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>    &#123;<br>        LimitInt li = <span class="hljs-keyword">new</span> LimitInt();<br>        li.TheValue = x;<br>        <span class="hljs-keyword">return</span> li;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        LimitInt li = <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitInt</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TheValue &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">Limit li</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> li.TheValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">LimitInt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>    &#123;<br>        LimitInt li = <span class="hljs-keyword">new</span> LimitInt();<br>        li.TheValue = x;<br>        <span class="hljs-keyword">return</span> li;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        LimitInt li = <span class="hljs-number">500</span>;<br>        Int a = li;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果我们声明的是显式转换运算符，那么我们就不得不使用强制类型转换: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitInt</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TheValue &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">Limit li</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> li.TheValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">LimitInt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>    &#123;<br>        LimitInt li = <span class="hljs-keyword">new</span> LimitInt();<br>        li.TheValue = x;<br>        <span class="hljs-keyword">return</span> li;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        LimitInt li = (LimitInt)<span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitInt</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TheValue &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">Limit li</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> li.TheValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">LimitInt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>    &#123;<br>        LimitInt li = <span class="hljs-keyword">new</span> LimitInt();<br>        li.TheValue = x;<br>        <span class="hljs-keyword">return</span> li;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        LimitInt li = (LimitInt)<span class="hljs-number">500</span>;<br>        Int a = (Int)li;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><p>typeof 运算符返回作为其参数的任何类型的 System.Type 对象。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">Type t = <span class="hljs-keyword"><code class="language-hljs csharp">Type t = <span class="hljs-keyword">typeof</span>(SomeClass);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>GetType 方法也会调用 typeof 运算符。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><hr><p>我们只介绍一下 C# 中比较特殊的语句。<br>C# 中 switch 语句比较特殊的地方在于: 每个 case 语句必须有控制跳转语句如 break，return 等，除非两个 case 语句中没有任何可执行语句: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">switch</span>(x)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//正确</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">switch</span>(x)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//正确</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//错误</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们可以使用 foreach 遍历数组中的元素，就像 Objective-C 中的 forin 一样。</p><p>对于某些非托管对象，有数量限制或很耗费系统资源，在使用完成之后，应该尽快释放他们，我们就应使用 using 语句简化该过程确保资源被适当处置(dispose)。<br><strong>资源是指实现了 System.IDisposable 接口的类或结构。</strong></p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">//先分配资源，在使用资源</span><br><span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment">//先分配资源，在使用资源</span><br><span class="hljs-keyword">using</span> (ResourceType Identifier = Expression) Statement<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中的表达式和运算符。&lt;/p&gt;
&lt;h2 id=&quot;运算符&quot;&gt;&lt;a href=&quot;#运算符&quot; class=&quot;headerlink&quot; title=&quot;运算符&quot;&gt;&lt;/a&gt;运算符&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;运算符(操作符)是一个符号，表示返回单个结果的操作。&lt;br&gt;一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%85%AD)/"/>
    <id>https://1ess.github.io/C#(%E5%85%AD)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，讲讲 C# 中的结构体类型和枚举类型。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><hr><p>结构与类类似，都是用户定义类型，都有数据成员和函数成员，但有两个最大的区别: </p><ul><li>类是引用类型而结构是值类型</li><li>结构是隐式密封的</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">strcut StructName<br>&#123;<br>    MemberDeclarations;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="结构是值类型"><a href="#结构是值类型" class="headerlink" title="结构是值类型"></a>结构是值类型</h3><p>因此: </p><ul><li>结构类型的变量不能为 null</li><li>两个结构不能引用同一对象</li></ul><p>把一个结构赋值给另一个结构，就是将这个结构的值复制给另一个结构。需要注意与类的赋值的不同。</p><p>结构允许有实例构造函数和静态构造函数，但不允许有析构函数。</p><p>与类一样，编译器隐式的为结构提供一个无参构造，这个构造将每个成员设置为该类型的默认值。与类不同的是，这个无参构造函数不能被重定义，我们只能创建另外的有参构造，而不能重写无参构造，并且我们提供了有参构造，编译器提供给我们的无参构造依然存在。</p><p>我们也用 new 操作符调用构造函数，即使不从堆中分配内存。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Point p = <span class="hljs-keyword">new</span> Point();<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Point p = <span class="hljs-keyword">new</span> Point();<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们也可以不使用构造来创建结构的实例，但有一些限制: </p><ul><li>显式设置数据成员之后，才可以使用这些成员的值</li><li>对所有的数据成员赋值之后，才能调用任何函数成员</li></ul><p>结构的字段是不允许有初始化语句的。</p><p>之前说了，结构是隐式密封的，因此 protected，internal，abstruct，virtual 修饰符不可使用。</p><p>与 Swift 类似，C# 中的简单预定义类型在实现方式上是使用结构类型。所以可以调用一些方法，如: 所有类型都有的 GetType 方法。<br>另外说一句: JavaScript 中的简单类型如 string 也可以调用方法，他们是在使用值时被临时包装成一个对象。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><hr><p>枚举只有一个类型的成员: 命名的整数值常量。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-built_in">enum</span> TrafficLight<br>&#123;<br>    Yellow,<br>    Green,<br>    Red<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>枚举的底层都是一个整数类型，默认是 int。<br>默认情况编译器把第一个值赋值为 0，之后的成员加 1。<br>我们把枚举值赋值成枚举对象: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    TrafficLight yellow = TrafficLight.Yellow;<br>    Console.WriteLine(yellow);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    TrafficLight yellow = TrafficLight.Yellow;<br>    Console.WriteLine(yellow);  <span class="hljs-comment">//Yellow 打印成员名</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们也可以显式的设置每个枚举成员的值和类型: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">enum</span> TrafficLight: <span class="hljs-built_in">uint</span><br>&#123;<br>    Yellow = <span class="hljs-number">15</span>,<br>    Green =  <span class="hljs-number">20</span>,<br>    Red = <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">enum</span> TrafficLight: <span class="hljs-built_in">uint</span><br>&#123;<br>    Yellow = <span class="hljs-number">15</span>,<br>    Green =  <span class="hljs-number">20</span>,<br>    Red = <span class="hljs-number">20</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="位标记"><a href="#位标记" class="headerlink" title="位标记"></a>位标记</h3><p>我们使用 Flags 特性实现位标记: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">Flags</span>]<br><span class="hljs-built_in">enum</span> Setting : <span class="hljs-built_in">uint</span><br>&#123;<br>    A = <span class="hljs-number">0x0001</span>,<br>    B = <span class="hljs-number">0x0010</span>,<br>    C = <span class="hljs-number">0x0100</span>,<br>    D = <span class="hljs-number">0x1000</span><br>&#125;<br><br>Setting opts = Setting.A | Setting.B | Setting.C;<br>opts.HasFlags(Setting.D);  <span class="hljs-comment"><code class="language-hljs csharp">[<span class="hljs-meta">Flags</span>]<br><span class="hljs-built_in">enum</span> Setting : <span class="hljs-built_in">uint</span><br>&#123;<br>    A = <span class="hljs-number">0x0001</span>,<br>    B = <span class="hljs-number">0x0010</span>,<br>    C = <span class="hljs-number">0x0100</span>,<br>    D = <span class="hljs-number">0x1000</span><br>&#125;<br><br>Setting opts = Setting.A | Setting.B | Setting.C;<br>opts.HasFlags(Setting.D);  <span class="hljs-comment">//false</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>C# 中的枚举与 Objective-C 的实现 NS_ENUM 和 NS_OPTIONS 类似。</p><p>注意: 枚举是一个独特的类型，比较不同类型的枚举对象会导致编译错误，即使他们的底层都是整数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，讲讲 C# 中的结构体类型和枚举类型。&lt;/p&gt;
&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;结构与类类似，都是用户定义类型，都有数据成员和函数成员，但有两个最大</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%B8%83)/"/>
    <id>https://1ess.github.io/C#(%E4%B8%83)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中的数组对象及其协变概念。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>数组是由变量名表示的一组同类型的数据元素，每个元素可以通过索引来访问。</p><p>C# 数组的特点: </p><ul><li>C# 不支持动态数组，也就是数组一旦创建，就不可以更改大小</li><li>索引从 0 开始</li></ul><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>C# 支持一维数组和多维数组，多维数组又分为矩形数组和交错数组。</p><h3 id="数组是对象"><a href="#数组是对象" class="headerlink" title="数组是对象"></a>数组是对象</h3><p>数组实例是从 System.Array 继承来的对象，继承了很多属性和方法: </p><ul><li>Rank 属性，返回数组的维数</li><li>Length 属性，返回数组的长度</li></ul><p>注意: 数组是引用类型，数组元素可以是值类型也可以是引用类型，这一点与 Ocjective-C 不同，Ocjective-C 中的数组元素不能是基本类型。</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>我们可以在类型和变量名之间加中括号来声明一维数组: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-built_in">long</span>[] array;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>要实例化一维数组，我们使用数组创建表达式，使用 new 操作符，后跟基类名称和中括号，中括号里要有数组长度: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>要访问数组元素，要使用索引: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br>array[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> intVal = array[<span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br>array[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> intVal = array[<span class="hljs-number">2</span>];<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>当数组创建后，每个元素会自动初始化默认值: </p><ul><li>整型: 0</li><li>浮点数: 0.0</li><li>布尔型: false</li><li>对象: null</li></ul><p>我们还可以使用初始化列表显式初始化数组元素: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>当在一条语句声明并初始化数组时，可以使用快捷语法: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们可以使用 foreach 语句遍历数组元素: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array) <br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array) <br>&#123;<br>    <span class="hljs-comment">//...item</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="数组的协变"><a href="#数组的协变" class="headerlink" title="数组的协变"></a>数组的协变</h3><p>协变和逆变我们之后说泛型的时候会细讲，这里我们只是提一下数组中的协变。<br>协变是指: 即使某个对象不是数组的基类型，我们也可以把他赋值给数组元素。以下情况可以使用数组协变: </p><ul><li>数组是引用类型数组</li><li>赋值类型和数组基类类型存在显式或隐式转换</li></ul><p>由于基类和派生类总存在隐式转换，因此我们可以把派生类对象赋值给基类型数组元素: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        A[] array = <span class="hljs-keyword">new</span> A[<span class="hljs-number">3</span>];<br>        A[<span class="hljs-number">0</span>] = <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        A[] array = <span class="hljs-keyword">new</span> A[<span class="hljs-number">3</span>];<br>        A[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> B();<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中的数组对象及其协变概念。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;数组是由变量名表示的一组同类型的数据元素，每个元素可以通过索引来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%85%AB)/"/>
    <id>https://1ess.github.io/C#(%E5%85%AB)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中特殊的委托(delegate)。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>委托和类一样，都是用户定义类型。类表示数据和方法的集和，而委托则是持有一个或多个方法，以及一系列预定义操作。</p><p>我们通过以下步骤来使用委托: </p><ul><li>声明一个委托，委托的声明看上去和方法声明类似，只是没有实现块</li><li>使用委托类型声明一个委托变量</li><li>创建委托类型的变量，赋值为委托变量，这个委托类型变量指向方法的引用，这个方法和委托定义的签名和返回值类型一样</li><li>可以为委托对象增加其他方法</li><li>可以像调用方法一样调用委托，调用委托时，其包含的每一个方法都会被执行</li></ul><h3 id="声明委托"><a href="#声明委托" class="headerlink" title="声明委托"></a>声明委托</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"><span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="创建委托对象"><a href="#创建委托对象" class="headerlink" title="创建委托对象"></a>创建委托对象</h3><p>有两种方式创建委托对象: </p><ul><li>第一种是使用 new 操作符的创建表达式，参数是调用列表第一个方法的名字</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">delVal = <span class="hljs-keyword">new</span> MyDel(instance.MyM1);  <span class="hljs-comment">//实例方法</span><br>dVal = <span class="hljs-keyword">new</span> MyDel(SClass.OtherM2);  <span class="hljs-comment"><code class="language-hljs csharp">delVal = <span class="hljs-keyword">new</span> MyDel(instance.MyM1);  <span class="hljs-comment">//实例方法</span><br>dVal = <span class="hljs-keyword">new</span> MyDel(SClass.OtherM2);  <span class="hljs-comment">//静态方法</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>我们还可以使用快捷语法，直接赋值为方法名即可</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">delVal = instance.MyM1;<br>dVal = SClass.OtherM2;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="为委托增加方法"><a href="#为委托增加方法" class="headerlink" title="为委托增加方法"></a>为委托增加方法</h3><p>我们使用 += 操作符为委托增加方法。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">MyDel  del = inst.M1;<br>del += SCl.M3;<br>del += X.Act;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>同样使用 -= 从委托移除方法。</p><h3 id="调用委托"><a href="#调用委托" class="headerlink" title="调用委托"></a>调用委托</h3><p>我们可以像调用方法一样调用委托: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">MyDel  del = inst.M1;<br>del += SCl.M3;<br>del += X.Act;<br><span class="hljs-comment">//...</span><br>del(<span class="hljs-number"><code class="language-hljs csharp">MyDel  del = inst.M1;<br>del += SCl.M3;<br>del += X.Act;<br><span class="hljs-comment">//...</span><br>del(<span class="hljs-number">444</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="调用带有返回值的委托"><a href="#调用带有返回值的委托" class="headerlink" title="调用带有返回值的委托"></a>调用带有返回值的委托</h3><ul><li>调用列表最后一个方法返回的值就是委托返回值</li><li>调用列表的其他方法返回值将被忽略</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"></span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IntVal = <span class="hljs-number">5</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add2</span>(<span class="hljs-params"></span>)</span> &#123; IntVal += <span class="hljs-number">2</span>; <span class="hljs-keyword">return</span> IntVal; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add3</span>(<span class="hljs-params"></span>)</span> &#123; IntVal += <span class="hljs-number">3</span>; <span class="hljs-keyword">return</span> IntVal; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyCls cls = <span class="hljs-keyword">new</span> MyCls();<br>        MyDel del = <span class="hljs-keyword">new</span> MyDel(cls.Add2);<br>        del += cls.Add3;<br>        del += cls.Add2;<br><br>        Console.WriteLine(del());  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"></span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IntVal = <span class="hljs-number">5</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add2</span>(<span class="hljs-params"></span>)</span> &#123; IntVal += <span class="hljs-number">2</span>; <span class="hljs-keyword">return</span> IntVal; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add3</span>(<span class="hljs-params"></span>)</span> &#123; IntVal += <span class="hljs-number">3</span>; <span class="hljs-keyword">return</span> IntVal; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyCls cls = <span class="hljs-keyword">new</span> MyCls();<br>        MyDel del = <span class="hljs-keyword">new</span> MyDel(cls.Add2);<br>        del += cls.Add3;<br>        del += cls.Add2;<br><br>        Console.WriteLine(del());  <span class="hljs-comment">//12</span><br>    &#123;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="调用带引用参数的委托"><a href="#调用带引用参数的委托" class="headerlink" title="调用带引用参数的委托"></a>调用带引用参数的委托</h3><p>再调用方法列表的下一个方法时，参数的新值会传给下一个方法。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add2</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; x += <span class="hljs-number">2</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add3</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; x += <span class="hljs-number">3</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyCls cls = <span class="hljs-keyword">new</span> MyCls();<br>        MyDel del = <span class="hljs-keyword">new</span> MyDel(cls.Add2);<br>        del += cls.Add3;<br>        del += cls.Add2;<br><br>        <span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>;<br>        del(<span class="hljs-keyword">ref</span> x);<br>        Console.WriteLine(x);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add2</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; x += <span class="hljs-number">2</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add3</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; x += <span class="hljs-number">3</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyCls cls = <span class="hljs-keyword">new</span> MyCls();<br>        MyDel del = <span class="hljs-keyword">new</span> MyDel(cls.Add2);<br>        del += cls.Add3;<br>        del += cls.Add2;<br><br>        <span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>;<br>        del(<span class="hljs-keyword">ref</span> x);<br>        Console.WriteLine(x);  <span class="hljs-comment">//12</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>我们可以使用 Lambda 表达式创建委托对象。<br>C# 中的 Lambda 表达式与 JavaScript 中的很像。如果只有一个参数，可以省略括号，如果只有一个返回值语句，可以省略大括号和 reuturn 关键字。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">MyDel del = (<span class="hljs-built_in">int</span> x) =&gt; &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-comment">//简写形式</span><br>MyDel del = x =&gt; x + <span class="hljs-number"><code class="language-hljs csharp">MyDel del = (<span class="hljs-built_in">int</span> x) =&gt; &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-comment">//简写形式</span><br>MyDel del = x =&gt; x + <span class="hljs-number">1</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中特殊的委托(delegate)。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;委托和类一样，都是用户定义类型。类表示数据和方法的集和，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%B9%9D)/"/>
    <id>https://1ess.github.io/C#(%E4%B9%9D)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>前几篇，我们都在讲类型，这一篇，我们来说说事件成员。</p><h2 id="发布者和订阅者"><a href="#发布者和订阅者" class="headerlink" title="发布者和订阅者"></a>发布者和订阅者</h2><hr><p>很多程序都会有一个需求: 当一个特定事件发生时，程序的其他部分可以得到这个事件发生的通知。<br>发布者/订阅者模式可以满足这个需求:<br>发布者定义了一系列事件，其他类可以注册某些事件，以便在事件发生时，订阅者可以收到通知响应事件。订阅者注册事件时提供的方法称为回调函数或者事件处理程序。</p><p>在 Objective-C 中，我们可以在某些类 addObserver 注册一些事件处理程序，当事件发生时，pushNotifacitation。在 JavaScript 中，我们同样可以 addEventListener 注册一些事件处理程序。</p><p>发布者: 发布某个事件的类或结构<br>订阅者: 注册并在事件发生时得到通知执行事件处理程序的类或结构<br>事件处理程序: 当事件发生时执行的回调函数</p><p><strong>事件包含了一个私有委托</strong>。<br>关于事件的私有委托: </p><ul><li>事件提供了对他的私有委托的结构化访问，我们无法直接访问私有委托</li><li>对于事件，我们只可以添加，删除和调用事件处理程序</li><li>事件触发时，会依次调用调用列表的方法</li></ul><h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><hr><p>发布者类必须提供事件对象。声明事件需要委托类型和事件名: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-comment">//声明事件: event 关键字，EventHandler 委托类型，CountedADozen 事件名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-comment">//声明事件: event 关键字，EventHandler 委托类型，CountedADozen 事件名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler CountedADozen;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 事件是成员而不是类型，由于他是成员: </p><ul><li>我们不能在可执行代码中声明事件</li><li>必须声明在类或结构中</li><li>声明事件需要委托类型，我们可以声明一个委托或使用已存在的。</li></ul><p>BCL 声明了一个 EventHandler 的委托，专门处理系统事件。</p><h2 id="订阅事件"><a href="#订阅事件" class="headerlink" title="订阅事件"></a>订阅事件</h2><hr><p>订阅者向事件添加处理程序: </p><ul><li>使用 += 运算符为事件添加事件处理程序</li><li>事件处理程序可以是: <ol><li>实例方法名称</li><li>静态方法名称</li><li>匿名方法</li><li>Lambda 表达式</li></ol></li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">cls.CountedADozen += IncreatmentCountedADozen;<br>cls.CountedADozen += ClassB.CountedHandlerB;<br>cls.CountedADozen += () => DozensCount ++;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><hr><p>触发事件时要注意: </p><ul><li>触发前要与 null 比较，如果是 null，则不能执行</li><li>触发事件的语法与调用方法一样</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几篇，我们都在讲类型，这一篇，我们来说说事件成员。&lt;/p&gt;
&lt;h2 id=&quot;发布者和订阅者&quot;&gt;&lt;a href=&quot;#发布者和订阅者&quot; class=&quot;headerlink&quot; title=&quot;发布者和订阅者&quot;&gt;&lt;/a&gt;发布者和订阅者&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;很多程序都会有一个需求</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们再回来说说最后一种类型: 接口(interface)。</p><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>接口是指定一组函数成员而不实现他们的引用类型。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IInfo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetName</span>(<span class="hljs-params"></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetAge</span>(<span class="hljs-params"><code class="language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IInfo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetName</span>(<span class="hljs-params"></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetAge</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们可以用类或结构来实现接口。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span>: <span class="hljs-title">IComparable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TheValue;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  <span class="hljs-title">CompareTo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>    &#123;<br>        MyCls cls = (MyCls)obj;<br>        <span class="hljs-keyword">if</span> (TheValue &gt; cls.TheValue) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (TheValue &lt; cls.TheValue) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span>: <span class="hljs-title">IComparable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TheValue;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  <span class="hljs-title">CompareTo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>    &#123;<br>        MyCls cls = (MyCls)obj;<br>        <span class="hljs-keyword">if</span> (TheValue &gt; cls.TheValue) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (TheValue &lt; cls.TheValue) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h3><ul><li><p>接口声明不能包含数据成员和静态成员</p></li><li><p>接口只能包含如下非静态成员: </p><ol><li>方法</li><li>属性</li><li>事件</li><li>索引器</li></ol></li><li><p>接口应该以大写字母 I 开始</p></li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-comment">//注意: 接口函数成员不能有访问修饰符</span><br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"><span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-comment">//注意: 接口函数成员不能有访问修饰符</span><br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> val</span>)</span>;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>要实现接口: </p><ul><li>与继承类似，类或结构后跟冒号，再跟接口名</li><li>为每一个接口成员提供实现</li></ul><p>注意: 如果有继承，并实现接口，基类名必须出现在接口之前: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IIfc1</span>, <span class="hljs-title">IIfc2</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IIfc1</span>, <span class="hljs-title">IIfc2</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><ul><li>类或结构可以实现任意数量的接口</li><li>所有实现的接口，必须列在基类列表以逗号分隔</li></ul><h3 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h3><p>与类的继承不同，接口可以多继承。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IData</span> : <span class="hljs-title">IDataR</span>, <span class="hljs-title">IDataS</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IData</span> : <span class="hljs-title">IDataR</span>, <span class="hljs-title">IDataS</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们再回来说说最后一种类型: 接口(interface)。&lt;/p&gt;
&lt;h3 id=&quot;什么是接口&quot;&gt;&lt;a href=&quot;#什么是接口&quot; class=&quot;headerlink&quot; title=&quot;什么是接口&quot;&gt;&lt;/a&gt;什么是接口&lt;/h3&gt;&lt;p&gt;接口是指定一组函数成员而不实现他们</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%B8%80)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%B8%80)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们再来看看 C# 中的显式转换以及隐式转换。</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>有些类型的转换不会丢失数据或精度: </p><ul><li>C# 会自动做这些转换，称为隐式转换</li><li>从位数少的源转换为位数更多的源，目标多出来的位使用 0 或 1 补充</li><li>当从小的无符号类型转换为更大的无符号类型，多出来的位以 0 进行填充，称为 0 扩展</li><li>对于有符号类型，额外的高位使用符号位进行扩展，称为符号扩展</li></ul><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>对于源类型的任意值在被转换为目标类型时会丢失的情况，C# 语言是不提供两种类型的自动转换，如果我们希望这两种类型进行转换，就必须使用显式转换，这叫做强制转换表达式。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">ushort</span> var1 = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">sbyte</span> var2 = (<span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-built_in">ushort</span> var1 = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">sbyte</span> var2 = (<span class="hljs-built_in">sbyte</span>)var1;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>C# 所有类型都继承自 object 类型，然而，值类型是高效轻量的类型，但是当我们需要对象组件，可以使用装箱。<br>装箱是一种隐式转换，接受值类型的值，在堆上创建一个引用类型对象，返回该引用。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">object</span> oi = <span class="hljs-literal"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">object</span> oi = <span class="hljs-literal">null</span>;<br>oi = i;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>需要注意的是: 装箱操作的时一个副本，装箱之后，原始值和引用副本可以独立操作。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">object</span> oi = i;<br>Console.WriteLine(<span class="hljs-string">&quot;i: &#123;0&#125;, oi: &#123;1&#125;&quot;</span>, i, oi); <span class="hljs-comment">// 10, 10</span><br><br>i = <span class="hljs-number">12</span>;<br>oi = <span class="hljs-number">15</span>;<br>Console.WriteLine(<span class="hljs-string">&quot;i: &#123;0&#125;, oi: &#123;1&#125;&quot;</span>, i, oi); <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">object</span> oi = i;<br>Console.WriteLine(<span class="hljs-string">&quot;i: &#123;0&#125;, oi: &#123;1&#125;&quot;</span>, i, oi); <span class="hljs-comment">// 10, 10</span><br><br>i = <span class="hljs-number">12</span>;<br>oi = <span class="hljs-number">15</span>;<br>Console.WriteLine(<span class="hljs-string">&quot;i: &#123;0&#125;, oi: &#123;1&#125;&quot;</span>, i, oi); <span class="hljs-comment">// 12, 15</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h3><p>拆箱是将装箱后的引用返回值类型的操作。<br>注意: 拆箱是显式转换。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">object</span> oi = i;<br><br><span class="hljs-built_in">int</span> j = (<span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">object</span> oi = i;<br><br><span class="hljs-built_in">int</span> j = (<span class="hljs-built_in">int</span>)oi;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>拆箱非值类型会抛出异常。</p><h3 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h3><p>我们可以使用 is 运算符检测转换是否会成功，避免盲目转换。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;1ess&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Employee emp = <span class="hljs-keyword">new</span> Employee();<br>        <span class="hljs-keyword">if</span> (emp <span class="hljs-keyword">is</span> Person p) &#123;<br>            <span class="hljs-comment">//如果转换失败，返回 false</span><br>            <span class="hljs-comment">//如果转换成功，返回 true，并赋值给 p</span><br>            <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;1ess&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Employee emp = <span class="hljs-keyword">new</span> Employee();<br>        <span class="hljs-keyword">if</span> (emp <span class="hljs-keyword">is</span> Person p) &#123;<br>            <span class="hljs-comment">//如果转换失败，返回 false</span><br>            <span class="hljs-comment">//如果转换成功，返回 true，并赋值给 p</span><br>            <span class="hljs-comment">//...</span><br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="as-运算符"><a href="#as-运算符" class="headerlink" title="as 运算符"></a>as 运算符</h3><p>as 运算符和强制转换类似，只是他不会抛出异常。如果转换失败，会返回 null。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;1ess&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Employee emp = <span class="hljs-keyword">new</span> Employee();<br>        Person p = emp <span class="hljs-keyword">as</span> Person;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;1ess&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Employee emp = <span class="hljs-keyword">new</span> Employee();<br>        Person p = emp <span class="hljs-keyword">as</span> Person;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//...</span><br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们再来看看 C# 中的显式转换以及隐式转换。&lt;/p&gt;
&lt;h3 id=&quot;隐式转换&quot;&gt;&lt;a href=&quot;#隐式转换&quot; class=&quot;headerlink&quot; title=&quot;隐式转换&quot;&gt;&lt;/a&gt;隐式转换&lt;/h3&gt;&lt;p&gt;有些类型的转换不会丢失数据或精度: &lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%BA%8C)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%BA%8C)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>理想有两种: 一种，我实现了我的理想；另一种: 理想通过我而实现。</p></blockquote><p>这一篇，讲讲泛型。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>没有泛型的时候，我们封装的行为都是作用在特定类型上的，但是，很多时候如果我们把行为提取或重构出来，使其可以应用到很多类型上去的话，那么就会更有意义。这也是泛型出现的原因。</p><p>我们可以额外增加一层抽象，这样类型就不用再硬编码了，这样就可以使得多段代码在不同类型执行相同的指令成为可能。</p><p>之前写 Objective-C 的时候，感觉他的泛型太弱了，现在写 C#，感觉他的泛型系统太好用了！</p><h3 id="无泛型栈示例"><a href="#无泛型栈示例" class="headerlink" title="无泛型栈示例"></a>无泛型栈示例</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIntStack</span><br>&#123;<br>    <span class="hljs-built_in">int</span> StackPoint = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span>[] StackArray;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIntStack</span><br>&#123;<br>    <span class="hljs-built_in">int</span> StackPoint = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span>[] StackArray;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果希望将相同的功能应用于 float 类型，我们就必须复制粘贴上面的代码再改成 float。<br>这样做可行，但是缺点明显: </p><ul><li>我们要仔细检查类型的修改</li><li>每当新增类型，就要复制粘贴修改</li><li>调试维护这些类似的代码易出错</li></ul><h3 id="C-中的泛型"><a href="#C-中的泛型" class="headerlink" title="C# 中的泛型"></a>C# 中的泛型</h3><p>泛型(generic)提供了更优雅的解决方案，让多个类型共享一组代码。我们可以使用类型占位符书写代码，在创建实例时指明实际类型即可。</p><p>C# 提供了 5 种泛型可用在的地方: 类、结构、接口、委托、方法。前四种是类型，最后一种是成员。</p><h3 id="泛型栈示例"><a href="#泛型栈示例" class="headerlink" title="泛型栈示例"></a>泛型栈示例</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-built_in">int</span> StackPointer = <span class="hljs-number">0</span>;<br>    T[] StackArray;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params">T x</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-built_in">int</span> StackPointer = <span class="hljs-number">0</span>;<br>    T[] StackArray;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params">T x</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="声明泛型类"><a href="#声明泛型类" class="headerlink" title="声明泛型类"></a>声明泛型类</h3><p>上面我们已经展示了一个示例来演示泛型类，这里我们具体介绍一下，看看如何创建并使用泛型类。<br>创建使用非泛型类有两步: 声明类和创建类的实例。<br>但是泛型类不是实际类，而是类的模板，所以我们必须先从模板构建出实际类型，然后创建这个构建后的类型的实例。</p><p>声明步骤: </p><ul><li>在类名后放置一对尖括号&lt;&gt;</li><li>在尖括号中用逗号分隔占位字符串来表示希望提供的类型，这叫做类型参数(type parameters)</li><li>在泛型类的主体使用类型参数代替实际类型</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> &lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T1 SomeVal = <span class="hljs-keyword">new</span> T1();<br>    <span class="hljs-keyword">public</span> T2 OtherVal = <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> &lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T1 SomeVal = <span class="hljs-keyword">new</span> T1();<br>    <span class="hljs-keyword">public</span> T2 OtherVal = <span class="hljs-keyword">new</span> T2();<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="创建构造类型"><a href="#创建构造类型" class="headerlink" title="创建构造类型"></a>创建构造类型</h3><p>列出类名并在尖括号中提供真实类型代替类型参数，我们将替代类型参数的真实类型称为类型实参(type argument)。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in"><code class="language-hljs csharp">SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>非泛型类创建实例: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">MyNonGenClass myNGC = <span class="hljs-keyword"><code class="language-hljs csharp">MyNonGenClass myNGC = <span class="hljs-keyword">new</span> MyNonGenClass();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>泛型类创建实例: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>&gt; mySc1 = <span class="hljs-keyword">new</span> SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in"><code class="language-hljs csharp">SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>&gt; mySc1 = <span class="hljs-keyword">new</span> SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>>();<br><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="类型参数约束"><a href="#类型参数约束" class="headerlink" title="类型参数约束"></a>类型参数约束</h3><p>为了让泛型变得更有用，我们需要提供额外信息让编译器知道 type parameter 可以接受哪些类型。<br>这些额外信息称为约束(constraint)。</p><h4 id="Where-子句"><a href="#Where-子句" class="headerlink" title="Where 子句"></a>Where 子句</h4><ul><li>每个 type parameter 都有自己的 where 子句</li><li>如果有多个约束，在约束列表用逗号分隔</li></ul><p>where 子句使用要点: </p><ul><li>在关闭尖括号后列出</li><li>where 子句之间不用逗号分隔</li><li>子句之间可以以任何顺序列出</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, <span class="hljs-title">T3</span>&gt;<br>                      <span class="hljs-keyword">where</span> <span class="hljs-title">T2</span>: <span class="hljs-title">Customer</span><br>                      <span class="hljs-keyword">where</span> <span class="hljs-title">T3</span>: <span class="hljs-title">IComparable</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, <span class="hljs-title">T3</span>&gt;<br>                      <span class="hljs-keyword">where</span> <span class="hljs-title">T2</span>: <span class="hljs-title">Customer</span><br>                      <span class="hljs-keyword">where</span> <span class="hljs-title">T3</span>: <span class="hljs-title">IComparable</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="约束类型和次序"><a href="#约束类型和次序" class="headerlink" title="约束类型和次序"></a>约束类型和次序</h4><p>共有 5 种类型的约束: </p><ul><li>类名: 某种类或类的子类才能做 type argument</li><li>class: 任何引用类型才能做 type argument</li><li>struct: 任何值类型才能做 type argument</li><li>接口名: 只有这个接口或实现这个接口的类型才能做 type argument</li><li>new(): 任何带有无参构造的类型才能做 type argument</li></ul><p>顺序: </p><ul><li>主约束必须放在第一位且只有一个: 主约束只能是类名、class 或者 struct</li><li>接口名约束可以有任意多个</li><li>如果存在构造约束，必须放在最后</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedList</span>&lt;<span class="hljs-title">S</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">S</span>: <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">S</span>&gt; &#123; ... &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">M</span>, <span class="hljs-title">N</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">M</span>: <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">M</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">N</span>: <span class="hljs-title">ICloneable</span> &#123; ... &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyDictionary</span>&lt;<span class="hljs-title">KeyType</span>, <span class="hljs-title">ValueType</span>&gt;<br>                              <span class="hljs-keyword">where</span> <span class="hljs-title">KeyType</span>: <span class="hljs-title">IEnumerable</span>, <span class="hljs-title"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedList</span>&lt;<span class="hljs-title">S</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">S</span>: <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">S</span>&gt; &#123; ... &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">M</span>, <span class="hljs-title">N</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">M</span>: <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">M</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">N</span>: <span class="hljs-title">ICloneable</span> &#123; ... &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyDictionary</span>&lt;<span class="hljs-title">KeyType</span>, <span class="hljs-title">ValueType</span>&gt;<br>                              <span class="hljs-keyword">where</span> <span class="hljs-title">KeyType</span>: <span class="hljs-title">IEnumerable</span>, <span class="hljs-title">new</span>() &#123; ... &#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>与其他的泛型不同，泛型方法是成员而不是类型，它可以用于泛型、非泛型类、结构或接口。</p><h4 id="声明泛型方法"><a href="#声明泛型方法" class="headerlink" title="声明泛型方法"></a>声明泛型方法</h4><p>泛型方法具有类型参数和可选的约束。<br>泛型方法有两个参数列表: </p><ul><li>封闭在圆括号内的方法参数列表</li><li>封闭在尖括号内的类型参数列表</li></ul><p>要声明泛型方法: </p><ul><li>在方法名之后，方法参数之前放置类型参数列表</li><li>在方法参数之后放置可选的约束子句</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintData</span>&lt;<span class="hljs-title">S</span>, <span class="hljs-title">T</span>&gt; (<span class="hljs-params">S s, T t</span>) <span class="hljs-keyword">where</span> S: Person</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintData</span>&lt;<span class="hljs-title">S</span>, <span class="hljs-title">T</span>&gt; (<span class="hljs-params">S s, T t</span>) <span class="hljs-keyword">where</span> S: Person</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="调用泛型方法"><a href="#调用泛型方法" class="headerlink" title="调用泛型方法"></a>调用泛型方法</h4><p>要调用泛型方法，需要在调用时提供类型实参: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">MyMethod&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in"><code class="language-hljs csharp">MyMethod&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>>();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果我们在调用泛型方法时，可以从方法参数推断出类型实参，则可以省略类型实参: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>&lt;<span class="hljs-title">T</span>&gt; (<span class="hljs-params">T t</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-built_in">int</span> IntVal = <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>&lt;<span class="hljs-title">T</span>&gt; (<span class="hljs-params">T t</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-built_in">int</span> IntVal = <span class="hljs-number">10</span>;<br>MyMethod(IntVal);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型结构"><a href="#泛型结构" class="headerlink" title="泛型结构"></a>泛型结构</h3><p>与泛型类一样，泛型结构也有类型参数和约束子句。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">struct</span> PieceOfData &lt;T&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T _Data;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PieceOfData</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        _data = data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T Data <br>    &#123;<br>        <span class="hljs-keyword">set</span> &#123; _data = <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _data; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> intData = <span class="hljs-keyword">new</span> PieceOfData&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">10</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst"><code class="language-hljs csharp"><span class="hljs-keyword">struct</span> PieceOfData &lt;T&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T _Data;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PieceOfData</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        _data = data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T Data <br>    &#123;<br>        <span class="hljs-keyword">set</span> &#123; _data = <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _data; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> intData = <span class="hljs-keyword">new</span> PieceOfData&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">10</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;intData.Data&#125;</span>"</span>);<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h3><p>泛型委托与非泛型委托类似，要声明泛型委托，需要在委托名称之后，委托参数列表之前放置类型参数列表: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> R <span class="hljs-title">MyDelegate</span> &lt;T, R&gt;(<span class="hljs-params"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> R <span class="hljs-title">MyDelegate</span> &lt;T, R&gt;(<span class="hljs-params">T t</span>)</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>C# 中有两个常用的预定义的泛型委托: Func 和 Action: </p><ul><li>Action 是无返回值的泛型委托，有 16 个重载(即最多 16 个参数)</li><li>Func 是有返回值的泛型委托，有 17 个重载(即最多 16 个参数和 1 个返回值)</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TR <span class="hljs-title">Func</span> &lt;T1, T2, TR&gt;(<span class="hljs-params">T1 p1, T2 p2</span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">PrintString</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> total = a + b;<br>        <span class="hljs-keyword">return</span> total.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> myDel = <span class="hljs-keyword">new</span> Func &lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;(Simple.PrintString);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;myDel(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)&#125;</span>&quot;</span>);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TR <span class="hljs-title">Func</span> &lt;T1, T2, TR&gt;(<span class="hljs-params">T1 p1, T2 p2</span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">PrintString</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> total = a + b;<br>        <span class="hljs-keyword">return</span> total.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> myDel = <span class="hljs-keyword">new</span> Func &lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;(Simple.PrintString);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;myDel(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)&#125;</span>&quot;</span>);  <span class="hljs-comment">// 5</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口允许我们编写参数和返回值是泛型类型参数的接口。我们需要在接口名之后用尖括号放置类型参数列表。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMyIfc</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">ReturnIt</span>(<span class="hljs-params">T val</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span>&lt;<span class="hljs-title">S</span>&gt;: <span class="hljs-title">IMyIfc</span>&lt;<span class="hljs-title">S</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">ReturnIt</span>(<span class="hljs-params">S s</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> simple = <span class="hljs-keyword">new</span> Simple&lt;<span class="hljs-built_in">int</span>&gt;();<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;simple.ReturnIt(<span class="hljs-number">3</span>)&#125;</span>&quot;</span>);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMyIfc</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">ReturnIt</span>(<span class="hljs-params">T val</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span>&lt;<span class="hljs-title">S</span>&gt;: <span class="hljs-title">IMyIfc</span>&lt;<span class="hljs-title">S</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">ReturnIt</span>(<span class="hljs-params">S s</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> simple = <span class="hljs-keyword">new</span> Simple&lt;<span class="hljs-built_in">int</span>&gt;();<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;simple.ReturnIt(<span class="hljs-number">3</span>)&#125;</span>&quot;</span>);  <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;理想有两种: 一种，我实现了我的理想；另一种: 理想通过我而实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一篇，讲讲泛型。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%B8%89)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%B8%89)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们看看 C# 中的枚举器和迭代器的基本概念。<br>之前我们说过可以使用 foreach 来遍历数组元素，本篇来讨论为什么数组可以使用 foreach 语句处理，我们可以还使用迭代器来使得自定义类型也可以使用 foreach。</p><h2 id="枚举器和可枚举类型"><a href="#枚举器和可枚举类型" class="headerlink" title="枚举器和可枚举类型"></a>枚举器和可枚举类型</h2><hr><p>为什么数组可以使用 foreach 呢？因为数组可以提供一个枚举器(enumerator)对象。枚举器对象可以依次返回数组元素。<br>获取一个对象的枚举器可以调用对象的 GetEnumerator 方法。实现了 GetEnumerator 方法的对象称为可枚举(enumerable)对象。</p><p>foreach 语句就是用来配合可枚举类型一起使用的，他会执行下列行为: </p><ul><li>调用 GetEnumerator 方法获取对象的枚举器</li><li>从枚举器请求每一项作为迭代变量(iteration variable)，我们可以读取该变量但不能改变</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">foreach</span> (Type ValName <span class="hljs-keyword">in</span> EnumerableObject) &#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">foreach</span> (Type ValName <span class="hljs-keyword">in</span> EnumerableObject) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h3><p>实现 IEnumerator 接口的枚举器包含三个函数成员: </p><ul><li>Current: 返回当前位置项的属性，只读</li><li>MoveNext: 把枚举器位置前进到集合下一项的方法，返回布尔值，位置有效返回 true，无效(到达尾部)返回 false。枚举器原始位置在第一项之前，因此在使用 Current 之前必须先调用 MoveNext</li><li>Reset: 位置重置为原始状态</li></ul><p>下面代码与直接使用 foreach 产生的结果是一样的: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] MyArr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;;<br>        IEnumerator ie = MyArr.GetEnumerator();<br>        <span class="hljs-keyword">while</span> (ie.MoveNext())<br>        &#123;<br>            <span class="hljs-built_in">int</span> current = (<span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] MyArr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;;<br>        IEnumerator ie = MyArr.GetEnumerator();<br>        <span class="hljs-keyword">while</span> (ie.MoveNext())<br>        &#123;<br>            <span class="hljs-built_in">int</span> current = (<span class="hljs-built_in">int</span>)ie.Current;<br>            Console.WriteLine(current);<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h3><p>可枚举类型是指实现了 IEnumerable 接口的类。IEnumerable 只有一个函数成员: </p><ul><li>GetEnumerator: 获取可枚举类型的枚举器</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="使用-IEnumerator-和-IEnumerable-示例"><a href="#使用-IEnumerator-和-IEnumerable-示例" class="headerlink" title="使用 IEnumerator 和 IEnumerable 示例"></a>使用 IEnumerator 和 IEnumerable 示例</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ColorEnumerator</span> : <span class="hljs-title">IEnumerator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] _colors;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _position = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorEnumerator</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] colors</span>)</span><br>    &#123;<br>        _colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[colors.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++) &#123;<br>            _colors[i] = colors[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> (_position &lt;= <span class="hljs-number">-1</span> || _position &gt;= _colors.Length) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>            &#125;<br>            <span class="hljs-keyword">return</span> _colors[_position];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>(<span class="hljs-params">(</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (_position &lt; _colors.Length - <span class="hljs-number">1</span>) &#123;<br>            _position++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>(<span class="hljs-params"></span>)</span> <br>    &#123;<br>        _position = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Colors</span> : <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] _colors;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colors</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] colors</span>)</span><br>    &#123;<br>        _colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[colors.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++) &#123;<br>            _colors[i] = colors[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorEnumerator(_colors);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Progeam</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Colors colors = <span class="hljs-keyword">new</span> Colors(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>&#125;);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> color <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ColorEnumerator</span> : <span class="hljs-title">IEnumerator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] _colors;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _position = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorEnumerator</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] colors</span>)</span><br>    &#123;<br>        _colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[colors.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++) &#123;<br>            _colors[i] = colors[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> (_position &lt;= <span class="hljs-number">-1</span> || _position &gt;= _colors.Length) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>            &#125;<br>            <span class="hljs-keyword">return</span> _colors[_position];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>(<span class="hljs-params">(</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (_position &lt; _colors.Length - <span class="hljs-number">1</span>) &#123;<br>            _position++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>(<span class="hljs-params"></span>)</span> <br>    &#123;<br>        _position = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Colors</span> : <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] _colors;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colors</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] colors</span>)</span><br>    &#123;<br>        _colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[colors.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++) &#123;<br>            _colors[i] = colors[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorEnumerator(_colors);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Progeam</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Colors colors = <span class="hljs-keyword">new</span> Colors(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>&#125;);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> color <span class="hljs-keyword">in</span> colors) &#123;<br>            Console.WriteLine(color);<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h3><p>之前我们写的都是非泛型版本，实际工作中，我们基本都使用泛型版本的 IEnumerator<T> 和 IEnumerable<T> 。非泛型版本只是兼任 2.0 版本之前无泛型的遗留代码。</p><p>泛型与非泛型版本的主要区别是: </p><ul><li>IEnumerable<T> 接口的 GetEnumerator 方法要返回实现 IEnumerator<T> 接口的枚举器实例</li><li>泛型版本的 Current 属性返回的不是 object 类型，而是实际类型的对象</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>C# 2.0 之后，提供了更简单的创建枚举器和可枚举类型的方式。这种结构称为迭代器(iterator)。</p><ul><li>迭代器返回一个泛型的枚举器</li><li>yield return 语句声明这是枚举的下一项</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">BlackAndWhite</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;black&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gray&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">BlackAndWhite</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;black&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gray&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">"white"</span>;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们看看 C# 中的枚举器和迭代器的基本概念。&lt;br&gt;之前我们说过可以使用 foreach 来遍历数组元素，本篇来讨论为什么数组可以使用 foreach 语句处理，我们可以还使用迭代器来使得自定义类型也可以使用 foreach。&lt;/p&gt;
&lt;h2 id=&quot;枚举器和可枚</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E5%9B%9B)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E5%9B%9B)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，讲讲 LINQ。<br>LINQ(发音同 link，不要读成 lin-q)代表语言集成查询(Language Integrated Query)，他是 .Net 的扩展，允许我们很轻松的操作对象集合。<br>LINQ 的出现也就意味着允许我们在 C# 中使用函数式编程的思想。</p><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>创建匿名对象与创建具名对象类似，只是没有类名和构造函数: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">new</span> &#123; FieldProp = InitExpr; FieldProp = InitExpr, ... &#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: </p><ul><li>匿名对象只能用于局部变量，不能用于成员</li><li>必须是由 var 作为类型</li><li>不能设置属性，匿名对象的属性是只读的</li></ul><h3 id="方法语法和查询语法"><a href="#方法语法和查询语法" class="headerlink" title="方法语法和查询语法"></a>方法语法和查询语法</h3><p>我们再写 LINQ 可以使用两种语法: </p><ul><li>方法语法</li><li>查询语法</li></ul><p>微软推荐使用查询语法，但是我更习惯方法语法。<br><strong>更新: 查询语法真香！</strong></p><h3 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h3><p>LINQ 查询返回两种类型的结果: </p><ul><li>可枚举的类型</li><li>单一标量</li></ul><h3 id="标准查询运算符"><a href="#标准查询运算符" class="headerlink" title="标准查询运算符"></a>标准查询运算符</h3><p>标准查询运算符由一系列 API 方法组成，标准查询运算符特性如下: </p><ul><li>被查询的集合对象称为序列，必须实现 IEnumerable<T> 接口</li><li>标准查询运算符使用方法语法</li><li>一些运算符返回 IEnumerable<T> 对象，一些则返回标量</li><li>很多操作都以谓词作为参数，谓词是一个方法，以对象作为参数，根据是否满足条件返回 true 或 false</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> total = numbers.Sum();  <span class="hljs-comment">// 6</span><br>        <span class="hljs-built_in">int</span> howMany = numbers.Count(); <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> total = numbers.Sum();  <span class="hljs-comment">// 6</span><br>        <span class="hljs-built_in">int</span> howMany = numbers.Count(); <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>C# 中的序列包括 Array、List<T>、Dictionary&lt;T1, T2&gt; 等。LINQ 可以以非常强大的方式来操纵这些对象。</p><p>共有 47 个标准查询运算符，常用的如: Where(类似于 filter)、Select(类似于 map)、toList<T>、First、FirstOrDefault、Last、LastOrDefault、Take、Skip 等，当我们需要使用高级用法时，我们可以在查询文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，讲讲 LINQ。&lt;br&gt;LINQ(发音同 link，不要读成 lin-q)代表语言集成查询(Language Integrated Query)，他是 .Net 的扩展，允许我们很轻松的操作对象集合。&lt;br&gt;LINQ 的出现也就意味着允许我们在 C# 中使用函数式编</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%BA%94)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%BA%94)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 网络编程中比较重要的概念 —— 异步。</p><h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><p>当程序启动时，系统就会在内存创建一个新进程。进程是构成程序的资源的集合，资源包括虚拟地址、文件句柄等。</p><p>在进程内部，系统还创建了称为线程的内核对象。也就是说一旦进程创建，系统就会在 Main 方法的第一行语句开始线程执行。</p><p>关于线程: </p><ul><li>默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束</li><li>线程可以派生其他线程</li><li>如果一个进程包含多个线程，他们将共享进程资源</li><li>系统为处理器执行所规划的基本单元是线程而不是进程</li></ul><p>在 C# 5.0 引入了一个非常好的特性 —— async/await。在 JavaScript 和即将到来的 Swift 5.0 中都存在引入了此特性，虽然实现的底层原理并不相同。<br>这个特性是 .Net 框架的一部分，但是没有嵌入 C# 中。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>如果程序调用某个方法，等待其执行所有处理之后才继续执行，我们称这样的方法为同步方法。<br>相反的，异步方法就是在处理完成之前就返回到调用方法。我们使用 async/await 特性可以很方便的创建异步方法。<br>该特性有三部分组成: </p><ul><li>调用方法: 调用异步方法的方法，在异步方法执行任务时继续执行</li><li>异步方法: 该方法异步执行其工作，然后立即返回到调用方法</li><li>await 表达式: 用于异步方法内，指明需要异步执行的任务，一个异步方法可以包含多个 await 表达式，如果一个都不包含，则该方法将同步执行，编译器会报警告</li></ul><p>async 关键字是一个专门给编译器的提示，意思是该函数的实现可能会出现 await 表达式。</p><ul><li>在 Debug 模式下，对于 async 方法，生成一个 class 状态机</li><li>在 Release 模式下，对于 async 方法，生成一个 struct 状态机</li></ul><h3 id="什么是异步方法"><a href="#什么是异步方法" class="headerlink" title="什么是异步方法"></a>什么是异步方法</h3><p>异步方法的特点: </p><ul><li>方法头包含 async 方法修饰符</li><li>包含一个或多个 await 表达式表示异步完成的任务</li><li>返回值只能是 void，Task 或 Task&lt;T&gt;</li><li>异步方法参数不能有 out 或 ref 修饰</li><li>按照约定，异步方法以 Async 结尾</li><li>Lambda 表达式也可以作为异步对象</li><li>调用方法读取 Task 的 Result 属性获取 T 类型的值</li><li>任何返回 Task&lt;T&gt; 的异步方法必须返回 T 类型的值</li></ul><p>需要注意: </p><ul><li>不要使用 void 作为 async 方法的返回值类型，async 方法可以返回 void，仅限于编写事件处理程序，如果是普通方法没有返回值，需要返回 Task</li><li>避免使用 Task.Wait 和 Task.Result 方法，可能会导致死锁</li><li>当第一次遇到 await 表达式所返回的类型就是方法头的返回值类型，与 await 表达式的返回值类型没关系</li><li>异步方法的 return 语句并没有真正返回值，而只是退出了</li></ul><h3 id="在调用方法同步等待任务"><a href="#在调用方法同步等待任务" class="headerlink" title="在调用方法同步等待任务"></a>在调用方法同步等待任务</h3><p>我们可能需要在调用方法中同步等待某个任务完成，Task&lt;T&gt; 实例提供了 Wait 方法，来等待某个特殊的 Task 完成。<br>还可以使用 Task 的静态方法 WaitAll 和 WaitAny 方法同步等待多个任务完成。参数为 Task[]。</p><h3 id="在异步方法异步等待任务"><a href="#在异步方法异步等待任务" class="headerlink" title="在异步方法异步等待任务"></a>在异步方法异步等待任务</h3><p>我们可以使用 await 和 Task 的静态方法 WhenAll 和 WhenAny 方法异步等待多个任务完成。参数为 List&lt;Task&lt;T&gt;&gt;。</p><p>注意: async 和 await 都没有新开线程，新开线程是 Task.Run() 做的事情。如果自己编写异步方法，注意要自己编写 Task.Run()。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 网络编程中比较重要的概念 —— 异步。&lt;/p&gt;
&lt;h3 id=&quot;什么是异步&quot;&gt;&lt;a href=&quot;#什么是异步&quot; class=&quot;headerlink&quot; title=&quot;什么是异步&quot;&gt;&lt;/a&gt;什么是异步&lt;/h3&gt;&lt;p&gt;当程序启动时，系统就会在内存创建一个新</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E5%85%AD)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E5%85%AD)/</id>
    <published>2021-07-14T12:43:18.362Z</published>
    <updated>2021-07-14T12:43:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中的异常处理 —— try、catch、finially。</p><h3 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h3><p>异常是程序运行时错误，出现正常操作时未预料的情况。当发生时，系统会捕获这个错误并抛出异常。<br>在编写 iOS 程序时，我们可能很少使用异常，通常我们使用 NSError **error 这样的二级指针来获取错误对象，处理不同的错误。</p><h3 id="try-语句"><a href="#try-语句" class="headerlink" title="try 语句"></a>try 语句</h3><p>try 语句是为了避免出现异常而被保护的代码段，在出现异常时提供异常处理。<br>try 语句由三部分组成: </p><ul><li>try 包含为避免出现异常而被保护的代码</li><li>catch 是异常处理程序</li><li>finally 是在所有情况都会执行的代码块，不论有没有异常</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>catch () &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>catch () &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>catch () &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>catch () &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>有许多不同类型的异常可能在程序中发生。BCL 定义了许多异常类。当一个异常发生时，我们应: </p><ul><li>创建该类型的异常对象</li><li>在适当的 catch 子句处理</li></ul><p>所有的异常类都继承自 System.Exception。异常对象含有只读属性: </p><ul><li>Message: 包含异常原因</li><li>StackTrace: 调用栈</li></ul><h3 id="catch-子句"><a href="#catch-子句" class="headerlink" title="catch 子句"></a>catch 子句</h3><p>catch 子句有三种形式: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">catch &#123;<br>    <span class="hljs-comment">//没有参数，匹配 try 中发生的任何异常</span><br>&#125;<br><br>catch (ExceptionType) &#123;<br>    <span class="hljs-comment">//异常类型作为参数，匹配该类型的异常</span><br>&#125;<br><br>catch (ExceptionType Exp) &#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp">catch &#123;<br>    <span class="hljs-comment">//没有参数，匹配 try 中发生的任何异常</span><br>&#125;<br><br>catch (ExceptionType) &#123;<br>    <span class="hljs-comment">//异常类型作为参数，匹配该类型的异常</span><br>&#125;<br><br>catch (ExceptionType Exp) &#123;<br>    <span class="hljs-comment">//特定异常对象作为参数，匹配该类型的异常，在代码块中可以使用异常对象</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="finally-子句"><a href="#finally-子句" class="headerlink" title="finally 子句"></a>finally 子句</h3><p>如果程序进入了一个带有 finally 块的 try 语句，那么 finally 块总会执行。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>我们可以使用 throw 语句显式触发一个异常，语法如下: </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">throw</span> ExceptionObject;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>throw 还可以不带异常对象使用，只能用在 catch 块内部。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中的异常处理 —— try、catch、finially。&lt;/p&gt;
&lt;h3 id=&quot;什么是异常&quot;&gt;&lt;a href=&quot;#什么是异常&quot; class=&quot;headerlink&quot; title=&quot;什么是异常&quot;&gt;&lt;/a&gt;什么是异常&lt;/h3&gt;&lt;p&gt;异常是程序运行时错</summary>
      
    
    
    
    
  </entry>
  
</feed>
