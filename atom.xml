<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Sort Of A Blog</title>
  
  
  <link href="https://1ess.github.io/atom.xml" rel="self"/>
  
  <link href="https://1ess.github.io/"/>
  <updated>2021-07-14T06:47:45.453Z</updated>
  <id>https://1ess.github.io/</id>
  
  <author>
    <name>Stephen Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E5%9B%9B)/"/>
    <id>https://1ess.github.io/MySQL(%E5%9B%9B)/</id>
    <published>2021-07-14T06:47:45.453Z</published>
    <updated>2021-07-14T06:47:45.453Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们说说 MySQL 对于数据的增删改查操作以及运算符。</p><h2 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h2><hr><h3 id="多数据插入"><a href="#多数据插入" class="headerlink" title="多数据插入"></a>多数据插入</h3><p>基本语法: insert into {表名}({字段列表}) values({值列表1}), ({值列表2}), …</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> my_advance_insert<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'zhangsan'</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Lisi'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h3><p>在有的表中，使用的是业务主键，但是往往在进行数据插入时，又不确定数据表中是否存在对应的主键。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> my_stud <span class="token punctuation">(</span>    stud_id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">comment</span> <span class="token string">'主键，学生ID'</span><span class="token punctuation">,</span>    name <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span> <span class="token keyword">charset</span> utf8<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> my_stud <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'stu0001'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'stu0002'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'stu0003'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 主键冲突</span><span class="token keyword">insert</span> <span class="token keyword">into</span> my_stud <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'stu0003'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方案: </p><ol><li>主键冲突更新，类似插入语法，如果插入过程主键冲突，采用更新方法。基本语法: insert into {表名}({字段列表}) values({值列表1}) on duplicate key update {字段}={新值};</li></ol><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 主键冲突更新</span><span class="token keyword">insert</span> <span class="token keyword">into</span> my_stud <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'stu0003'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token keyword">duplicate key</span> <span class="token keyword">update</span> name<span class="token operator">=</span><span class="token string">'d'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>主键冲突替换，先删除，再重新插入。基本语法: replace into {表名}({字段列表}) values({值列表1});</li></ol><pre class="line-numbers language-sql"><code class="language-sql">replace <span class="token keyword">into</span> my_stud <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'stu0001'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h3><p>基本语法: insert into {表名}({字段列表}) select * from {其他表名或本身表};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> my_stud2 <span class="token punctuation">(</span>    stud_id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">comment</span> <span class="token string">'主键，学生ID'</span><span class="token punctuation">,</span>    name <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span> <span class="token keyword">charset</span> utf8<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 复制到本身</span><span class="token keyword">insert</span> <span class="token keyword">into</span> my_stud <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 复制到新表</span><span class="token keyword">insert</span> <span class="token keyword">into</span> my_stud2 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: </p><ol><li>蠕虫复制可以在短期快速增加数据量，从而测试表压力，测试索引效率</li><li>注意主键冲突</li></ol><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><hr><p>在更新数据时，要特别注意，通常一定要跟随条件进行更新。而且还可以使用 limit 来限制更新数量。<br>基本语法: update {表名} set {字段名}={字段值} [where 条件] [limit {数量}];</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">update</span> my_stud <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">'x'</span> <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'c'</span> <span class="token keyword">limit</span> <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><hr><p>删除数据时，也要特别注意，通常一定要跟随条件进行删除。而且也可以使用 limit 来限制删除数量。<br>基本语法: delete from {表名} [where 条件] [limit {数量}];</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">update</span> my_stud <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">'x'</span> <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'c'</span> <span class="token keyword">limit</span> <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要注意: delete 删除数据时，无法重置 auto_increment。要解决这个问题，我们可以使用: truncate {表名};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">truncate</span> my_stud<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 相当于先 drop，再 create</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><hr><p>完整的查询指令: select [select 选项] {字段列表/*} from {数据源} [where 条件] [group by 分组] [having 条件] [order by 排序] [limit 数量];</p><h3 id="Select-选项"><a href="#Select-选项" class="headerlink" title="Select 选项"></a>Select 选项</h3><p>select 选项用来确定如何对待查询返回的结果。<br>可取值为: </p><ol><li>all，默认的，保存所有返回结果</li></ol><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>distinct，去重，只保留不重复的结果(所有字段值都相同才算重复)</li></ol><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="字段列表"><a href="#字段列表" class="headerlink" title="字段列表"></a>字段列表</h3><p>字段我们可以取别名。<br>基本语法: {字段名} [as] {别名}</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> name <span class="token keyword">as</span> name1<span class="token punctuation">,</span> name <span class="token keyword">as</span> name2 <span class="token keyword">from</span> my_stud<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="From-数据源"><a href="#From-数据源" class="headerlink" title="From 数据源"></a>From 数据源</h3><p>数据源只要是复合二位表结构的数据即可。</p><h4 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h4><p>单表数据源就是表名。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h4><p>基本语法: from {表名1}, {表名2}, …<br>结果为: 两表记录相乘，字段数拼接。<br>从前一张表的每条记录，去拼凑第二张表的所有记录。这种操作在数学上定义就是笛卡尔积，在实际中要避免笛卡尔积。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_int<span class="token punctuation">,</span> my_set<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h4><p>数据源不是一个实体表，而是从表中查询出来的二维结果表，也称为子查询。<br>基本语法: from (select [select 选项] {字段列表/*} from {数据源}) as {别名};<br>注意: 子查询必须使用括号和别名。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> int_1<span class="token punctuation">,</span> int_3 <span class="token keyword">from</span> my_int<span class="token punctuation">)</span> <span class="token keyword">as</span> int_alias<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Where-子句"><a href="#Where-子句" class="headerlink" title="Where 子句"></a>Where 子句</h3><p>用来从数据表获取数据时，进行条件筛选。</p><h3 id="Group-By-子句"><a href="#Group-By-子句" class="headerlink" title="Group By 子句"></a>Group By 子句</h3><p>根据指定字段，将数据进行分组。分组的目的就是用于统计。<br>基本语法: group by {字段名}<br>注意: MySQL 5.7 之后，默认开启 ONLY_FULL_GROUP_BY 选项提供对 group by 合法性的检查。一条 select 语句，MySQL 允许 target list 中输出的表达式是除聚集函数或 group by column 以外的表达式。否则就是非法的。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">group</span> <span class="token keyword">by</span> class_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意: group by 分组之后，只会取出每组的第一条记录。</p><p>有一些聚合函数可以使用: </p><ul><li>Count(): 统计每组数量，如果统计目标是字段，那么不会统计为 null 字段。如果是 *，则统计记录。</li><li>Avg(): 取平均值</li><li>Sum(): 求和</li><li>Max(): 求最大值</li><li>Min(): 求最小值</li><li>Group_concat(): 分组之后拼接字段</li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> class_id<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token keyword">from</span> my_stu <span class="token keyword">group</span> <span class="token keyword">by</span> class_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="多分组"><a href="#多分组" class="headerlink" title="多分组"></a>多分组</h4><p>按某个字段分组之后，对已分组数据再进行分组。</p><p>基本语法: group by {字段1}, {字段2}, …</p><p>先使用字段1 进行分组，分组之后再使用字段2 进行分组。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span> gender<span class="token punctuation">,</span> group_concat<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">from</span> my_stud <span class="token keyword">group</span> <span class="token keyword">by</span> class_id<span class="token punctuation">,</span> gender<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h4><p>按分组字段排序，注意: MySQL 8.0 不再进行隐式排序。必须使用 Order by 进行排序。<br>基本语法: </p><ul><li>Mysql 8.0之前: group by {字段1} [asc/desc], {字段2} [asc/desc];</li><li>Mysql 8.0之后: group by {字段1}, {字段2}, … order by {字段a} [asc/desc], {字段b} [asc/desc], … ;</li></ul><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 8.0 之前</span><span class="token keyword">select</span> id<span class="token punctuation">,</span> gender<span class="token punctuation">,</span> group_concat<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">from</span> my_stud <span class="token keyword">group</span> <span class="token keyword">by</span> class_id<span class="token punctuation">,</span> gender <span class="token keyword">desc</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 8.0 之后</span><span class="token keyword">select</span> id<span class="token punctuation">,</span> gender<span class="token punctuation">,</span> group_concat<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">from</span> my_stud <span class="token keyword">group</span> <span class="token keyword">by</span> class_id<span class="token punctuation">,</span> gender <span class="token keyword">order</span> <span class="token keyword">by</span> class_id <span class="token keyword">asc</span><span class="token punctuation">,</span> gender <span class="token keyword">desc</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Having-子句"><a href="#Having-子句" class="headerlink" title="Having 子句"></a>Having 子句</h3><p>having 与 where 类似，都是进行条件筛选，但是也有不同点，having 用于 group by 子句之后，用于分组数据进行筛选。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> class_id<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> number <span class="token keyword">from</span> my_stud <span class="token keyword">group</span> <span class="token keyword">by</span> class_id <span class="token keyword">having</span> number <span class="token operator">>=</span> <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Order-By-子句"><a href="#Order-By-子句" class="headerlink" title="Order By 子句"></a>Order By 子句</h3><p>根据字段对数据进行排序。<br>基本语法: order by {字段1} [asc/desc], {字段2} [asc/desc], …</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">order</span> <span class="token keyword">by</span> height <span class="token keyword">desc</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Limit-子句"><a href="#Limit-子句" class="headerlink" title="Limit 子句"></a>Limit 子句</h3><p>用来限制记录数量。</p><h4 id="记录数量限制"><a href="#记录数量限制" class="headerlink" title="记录数量限制"></a>记录数量限制</h4><p>基本语法: limit {数量};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">order</span> <span class="token keyword">by</span> height <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>利用 limit 限制获取指定区间的数量。<br>基本语法: limit {offset, length};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">order</span> <span class="token keyword">by</span> height <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意: limit 表示最多获取数量，如果不够，就只显示真实数量。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算数运算符包括: +, -, *, /, %<br>算数运算符通常用于运算结果(select 字段中)。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> int_1 <span class="token operator">+</span> int_2 <span class="token keyword">from</span> my_operator<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意: </p><ul><li>在 MySQL 中，除法运算结果是浮点数表示</li><li>除法中如果除数如果为 0，结果为 null</li><li>null 进行算术运算，结果都为 null</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符包括: &gt;, &gt;=, &lt;, &lt;=, =, &lt;&gt;<br>常用于在条件中进行结果限定。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">where</span> age <span class="token operator">>=</span> <span class="token number">20</span> <span class="token keyword">order</span> <span class="token keyword">by</span> height<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意: </p><ul><li>MySQL 中数据会自动转换成相同类型，在进行比较</li><li>MySQL 中没有布尔类型，0 表示 false，1 表示 true</li></ul><p>在关系运算符中还可以使用: between and。<br>基本语法: between {条件1} and {条件2};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">where</span> age <span class="token operator">between</span> <span class="token number">20</span> <span class="token operator">and</span> <span class="token number">30</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意: between and 中条件1 必须小于条件2，否则结果为空。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符包括: and, or, not</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">where</span> age <span class="token operator">>=</span> <span class="token number">20</span> <span class="token operator">and</span> age <span class="token operator">&lt;=</span> <span class="token number">30</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="In-运算符"><a href="#In-运算符" class="headerlink" title="In 运算符"></a>In 运算符</h3><p>基本语法: in (结果1, 结果2, …);</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">where</span> age <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Is-运算符"><a href="#Is-运算符" class="headerlink" title="Is 运算符"></a>Is 运算符</h3><p>is 专门用来判断字段值是否为 null。<br>基本语法: is null/is not null</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">where</span> name <span class="token operator">is</span> <span class="token boolean">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Like-运算符"><a href="#Like-运算符" class="headerlink" title="Like 运算符"></a>Like 运算符</h3><p>用来进行模糊匹配。<br>基本语法: like ‘模式匹配’;</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%a%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们说说 MySQL 对于数据的增删改查操作以及运算符。&lt;/p&gt;
&lt;h2 id=&quot;新增数据&quot;&gt;&lt;a href=&quot;#新增数据&quot; class=&quot;headerlink&quot; title=&quot;新增数据&quot;&gt;&lt;/a&gt;新增数据&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;多数据插入&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E4%BA%94)/"/>
    <id>https://1ess.github.io/MySQL(%E4%BA%94)/</id>
    <published>2021-07-14T06:47:45.453Z</published>
    <updated>2021-07-14T06:47:45.453Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们说说 MySQL 中的联合查询、连接查询以及子查询。</p><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><hr><p>基本概念: 可合并多个相似的选择查询结果的结果集，等同于将一个表追加到另一个表，从而实现将两个表的查询结果组合到一起，使用 Union 或 Union all。<br>注意: 这个合并是纵向合并，字段数不变，多个查询的结果合并。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>同一张表的不同结果，合并到一起展示</li><li>在大数据量情况，会分表操作，会使用联合查询将数据存放到一起显示</li></ol><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>select 语句 union [all/distinct(默认)] select 语句;</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">where</span> gender <span class="token operator">=</span> <span class="token string">'男'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> height <span class="token keyword">asc</span><span class="token punctuation">)</span><span class="token keyword">union</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">where</span> gender <span class="token operator">=</span> <span class="token string">'女'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> height <span class="token keyword">desc</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意: 如果联合查询中使用 order by，必须把该 select 语句使用括号包裹。并且 MySQL 8.0 之前，为了使 order by 生效，还必须使用 limit {大数量}</p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><hr><p>基本概念: 将多张表连接到一起进行查询，会导致记录的行数和字段列数发生改变。</p><p>连接查询分类: </p><ol><li>交叉连接</li><li>内连接</li><li>外连接</li></ol><ul><li>左连接</li><li>右连接</li></ul><ol start="4"><li>自然连接</li></ol><h3 id="交叉连接-Cross-Join"><a href="#交叉连接-Cross-Join" class="headerlink" title="交叉连接(Cross Join)"></a>交叉连接(Cross Join)</h3><p>之前咱们说过多表查询时，就说过交叉查询的概念，只是语法不同。<br>基本语法: {表1} cross join {表2};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">cross</span> <span class="token keyword">join</span> my_operator<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="内连接-Inner-Join"><a href="#内连接-Inner-Join" class="headerlink" title="内连接(Inner Join)"></a>内连接(Inner Join)</h3><p>从一张表中取出所有的记录，去另一张表中匹配，利用匹配条件进行匹配，成功保留，失败舍去。<br>基本语法: {表1} [inner] join {表2} on {匹配条件};<br>注意: 如果内连接没有条件，则与交叉连接返回结果一样。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">inner</span> <span class="token keyword">join</span> my_class <span class="token keyword">on</span> my_stud<span class="token punctuation">.</span>class_id <span class="token operator">=</span> my_class<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于表名可能很长，我们通常也使用表别名简化操作。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">as</span> <span class="token number">a</span> <span class="token keyword">inner</span> <span class="token keyword">join</span> my_class <span class="token keyword">as</span> <span class="token number">b</span> <span class="token keyword">on</span> <span class="token number">a</span><span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">b</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意: 内连接只有匹配到的记录才会保留。</p><h3 id="外连接-Outer-Join"><a href="#外连接-Outer-Join" class="headerlink" title="外连接(Outer Join)"></a>外连接(Outer Join)</h3><p>一张表作为主表(表中记录都会保留)，根据条件去匹配另一张从表中的记录，从而得到目标数据。<br>外连接分为: </p><ul><li>左外连接(left join)，左表作为主表</li><li>右外连接(right join)，右表作为主表</li></ul><p>左连接基本语法: {主表} left join {从表} on {匹配条件};<br>右连接基本语法: {从表} right join {主表} on {匹配条件};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">as</span> s <span class="token keyword">left</span> <span class="token keyword">join</span> my_class <span class="token keyword">as</span> <span class="token number">c</span> <span class="token keyword">on</span> s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意: 如果从表数据都不匹配，则返回结果该条记录从表字段值都为 null。</p><h3 id="Using-关键字"><a href="#Using-关键字" class="headerlink" title="Using 关键字"></a>Using 关键字</h3><p>是在连接查询中替代 on 关键字的。<br>使用前提是两张表连接的字段是同名的，并且最终在结果只保留一个字段。</p><p>基本语法: {表1} [inner/left/right join] {表2} using({同名字段列表});</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">left</span> <span class="token keyword">join</span> my_class <span class="token keyword">using</span><span class="token punctuation">(</span>class_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><hr><p>当一个查询是另一个查询的条件时，称之为子查询(Sub Query)。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>按功能来分: </p><ul><li>标量子查询: 子查询返回结果是一个数据</li><li>列子查询: 返回结果是一列</li><li>行子查询: 返回结果时一行</li><li>表子查询: 返回结果是多行多列</li><li>Exists 子查询: 返回结果是 1 或 0</li></ul><p>按位置来分: </p><ul><li>Where 子查询: 子查询语句出现在 Where 子句中</li><li>From 子查询: 子查询语句出现在 From 子句中，作为数据源</li></ul><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p>标量子查询 where 子句常使用 = 或 &lt;&gt; 操作符。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_class <span class="token keyword">as</span> <span class="token number">c</span> <span class="token keyword">where</span> <span class="token number">c</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> class_id <span class="token keyword">from</span> my_stud <span class="token keyword">as</span> s <span class="token keyword">where</span> s<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'zhangsan'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><p>列子查询 where 子句常使用 in 操作符。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_class <span class="token keyword">as</span> <span class="token number">c</span> <span class="token keyword">where</span> <span class="token number">c</span><span class="token punctuation">.</span>id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> class_id <span class="token keyword">from</span> my_stud<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><p>行子查询 where 子句 = 左值要是一个构造的行元素。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_class <span class="token keyword">where</span> <span class="token punctuation">(</span>age<span class="token punctuation">,</span> height<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token keyword">from</span> my_stud<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><p>表子查询用于 from 数据源，之前在动态查询时已经说过。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">order</span> <span class="token keyword">by</span> height <span class="token keyword">desc</span><span class="token punctuation">)</span> <span class="token keyword">as</span> order_stud <span class="token keyword">group</span> <span class="token keyword">by</span> class_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Exists-子查询"><a href="#Exists-子查询" class="headerlink" title="Exists 子查询"></a>Exists 子查询</h3><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_class <span class="token keyword">as</span> <span class="token number">c</span> <span class="token keyword">where</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_stud <span class="token keyword">as</span> s <span class="token keyword">where</span> s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们说说 MySQL 中的联合查询、连接查询以及子查询。&lt;/p&gt;
&lt;h2 id=&quot;联合查询&quot;&gt;&lt;a href=&quot;#联合查询&quot; class=&quot;headerlink&quot; title=&quot;联合查询&quot;&gt;&lt;/a&gt;联合查询&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;基本概念: 可合并多个相似的选择查询</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E5%85%AD)/"/>
    <id>https://1ess.github.io/MySQL(%E5%85%AD)/</id>
    <published>2021-07-14T06:47:45.453Z</published>
    <updated>2021-07-14T06:47:45.453Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们说说 MySQL 中的外键、视图以及事务安全等问题。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><hr><p>如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。<br>以另一个关系的外键作为主关键字的表称为主表，具有此外键的表称为主表的从表，外键又称为外关键字。</p><h3 id="外键操作"><a href="#外键操作" class="headerlink" title="外键操作"></a>外键操作</h3><h4 id="增加外键"><a href="#增加外键" class="headerlink" title="增加外键"></a>增加外键</h4><p>MySQL 中提供两种方式增加外键: </p><ol><li><p>在创建表时，直接新增外键<br>基本语法: [constraint {外键名}] foregin key({外键字段}) references {主表}(主键);</p></li><li><p>在创建表后，再新增外键<br>基本语法: alter table {从表名} add [constraint {外键名}] foregin key({外键字段}) references {主表}(主键);</p></li></ol><h4 id="外键基本要求"><a href="#外键基本要求" class="headerlink" title="外键基本要求"></a>外键基本要求</h4><ol><li>外键字段需要保证与关联的主表的主键字段类型一致</li><li>基本属性也要相同</li><li>如果在表后增加外键，对数据有一定要求</li><li>外键只能使用 innodb 引擎</li></ol><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键约束: 通过建立外键关系之后，对主表和从表都会有一定数据约束。</p><h4 id="约束的基本概念"><a href="#约束的基本概念" class="headerlink" title="约束的基本概念"></a>约束的基本概念</h4><ol><li>当一个外键产生时，从表会受制于主表数据的存在从而导致数据不能进行某些不符合规范的操作(不能插入主表不存在的数据)</li><li>如果一个表被其他表外键引入，那么该表的数据操作就不能随意，必须保证从表数据的有效性(不能删除从表存在的数据)</li></ol><h4 id="外键约束的概念"><a href="#外键约束的概念" class="headerlink" title="外键约束的概念"></a>外键约束的概念</h4><p>可以在创建外键时，对外键约束进行选择性的操作。</p><p>基本语法: add foregin key({外键字段}) references {主表名}(主键) on {约束模式};</p><p>约束模式有三种: </p><ol><li>district，严格模式，默认，不允许操作</li><li>cascade，级联模式，一起操作变化</li><li>set null，置空模式，主表变化，从表字段置空，前提是从表该外键字段允许为空</li></ol><p>常用约束: on update cascade on delete set null;</p><h4 id="约束的作用"><a href="#约束的作用" class="headerlink" title="约束的作用"></a>约束的作用</h4><p>保证数据的完整性: 主表数据与从表数据一致。<br>但是外键很强大，但是很少使用，因为其可能会导致业务无法把握。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><hr><h3 id="视图基本操作"><a href="#视图基本操作" class="headerlink" title="视图基本操作"></a>视图基本操作</h3><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p>视图的本质是 SQL 指令(select 语句)。<br>基本语法: create view {视图名} as select 指令</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 两表具有同名字段会有问题</span><span class="token keyword">create</span> <span class="token keyword">view</span> student_v <span class="token keyword">as</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_student <span class="token keyword">as</span> s <span class="token keyword">left</span> <span class="token keyword">join</span> my_class <span class="token keyword">as</span> <span class="token number">c</span> <span class="token keyword">on</span> s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>class_id<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">view</span> student_v <span class="token keyword">as</span> <span class="token keyword">select</span> s<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token number">c</span><span class="token punctuation">.</span>name <span class="token keyword">from</span> my_student <span class="token keyword">as</span> s <span class="token keyword">left</span> <span class="token keyword">join</span> my_class <span class="token keyword">as</span> <span class="token number">c</span> <span class="token keyword">on</span> s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>class_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h4><p>视图是一张虚拟表，可以把视图当作”表”来操作，但是视图本身没有数据，是临时执行 select 语句得到对应的结果。<br>基本语法: select 字段列表 from {视图名};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student_v<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h4><p>本质是修改视图对应的查询语句。<br>基本语法: alter view {视图名} as 新 select 指令</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">view</span> student_v <span class="token keyword">as</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_student <span class="token keyword">as</span> s <span class="token keyword">left</span> <span class="token keyword">join</span> my_class <span class="token keyword">as</span> <span class="token number">c</span> <span class="token keyword">using</span><span class="token punctuation">(</span>class_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p>基本语法: drop view {视图名};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">view</span> student_v<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><hr><p>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言书写的用户程序的执行所引起的。<br>事务由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。</p><h3 id="事务的基本原理"><a href="#事务的基本原理" class="headerlink" title="事务的基本原理"></a>事务的基本原理</h3><p>MySQL(Innodb) 允许将事务统一进行管理，将用户操作暂存，不直接操作数据表，等用户确认结果之后再进行操作。<br>事务在 MySQL 中通常是<strong>自动提交</strong>，也可以<strong>手动事务</strong>。</p><h3 id="自动事务"><a href="#自动事务" class="headerlink" title="自动事务"></a>自动事务</h3><p>自动事务(autocommit): 当客户端发送一条 SQL 指令(写操作)，给服务器时，服务器在执行之后，不用等待用户反馈结果，自动将结果同步到数据表。<br>关闭自动事务: set autocommit = off;<br>一旦关闭自动事务，就需要用户来提供是否同步的指令: </p><ol><li>Commit;: 提交(同步到数据表并清空该事务)</li><li>Rollback;: 回滚(清空该事务)</li></ol><p>执行事务端的客户端，在提供是否同步指令之前，该客户端仍可以根据日志对数据加工，返回同步之后的结果。</p><p>通常我们不关闭自动事务。</p><h3 id="手动事务"><a href="#手动事务" class="headerlink" title="手动事务"></a>手动事务</h3><h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><p>从该语句开始，之后的语句都不会直接写入数据库，而是保存在事务日志中。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 有的数据库使用 begin transaction;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><p>执行需要在事务中执行的 SQL 指令。</p><h4 id="提交事务或回滚"><a href="#提交事务或回滚" class="headerlink" title="提交事务或回滚"></a>提交事务或回滚</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 提交</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 回滚</span><span class="token keyword">rollback</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="回滚点-savepoint"><a href="#回滚点-savepoint" class="headerlink" title="回滚点(savepoint)"></a>回滚点(savepoint)</h4><p>当有一系列事务操作，可以设置回滚点，使得当有事务操作失败时，可以回到该位置重新开始执行。<br>基本语法: savepoint {回滚点名};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 设置回滚点</span><span class="token keyword">savepoint</span> sp1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 回到回滚点</span><span class="token keyword">rollback</span> sp1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事务特点"><a href="#事务特点" class="headerlink" title="事务特点"></a>事务特点</h3><p>事务具有四个特性(ACID): </p><ol><li>原子性(Atomicity): 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚</li><li>一致性(Consistency): 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的</li><li>隔离性(Isolation): 一个事务所做的修改在最终提交以前，对其它事务是不可见的</li><li>持久性(Durability): 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失</li></ol><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/mysql/mysql1.jpg"></p><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系: </p><ul><li>只有满足一致性，事务的执行结果才是正确的</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性</li><li>事务满足持久化是为了能应对数据库崩溃的情况</li></ul><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><p>MySQL 中提供了两种封锁粒度: </p><ul><li>行级锁</li><li>表级锁</li></ul><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h4 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h4><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul><li>排它锁(Exclusive)，简写为 X 锁，又称写锁</li><li>共享锁(Shared)，简写为 S 锁，又称读锁</li></ul><p>有以下两个规定: </p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</li></ul><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。<br>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定: </p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><ol><li>一级封锁协议: 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖</li><li>二级封锁协议: 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据</li><li>三级封锁协议: 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们说说 MySQL 中的外键、视图以及事务安全等问题。&lt;/p&gt;
&lt;h2 id=&quot;外键&quot;&gt;&lt;a href=&quot;#外键&quot; class=&quot;headerlink&quot; title=&quot;外键&quot;&gt;&lt;/a&gt;外键&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;如果公共关键字在一个关系中是主关键字，那么这个公共关</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E4%B8%83)/"/>
    <id>https://1ess.github.io/MySQL(%E4%B8%83)/</id>
    <published>2021-07-14T06:47:45.453Z</published>
    <updated>2021-07-14T06:47:45.453Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是 MySQL 的最后一篇，我们最后讲讲变量、函数、存储过程和触发器。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr><p>MySQL 需要很多变量来保存数据。</p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>系统内部定义的变量，系统变量针对所有用户有效。</p><h4 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h4><p>基本语法: show variables [{模式匹配}];</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'autocommit'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看系统变量实际值"><a href="#查看系统变量实际值" class="headerlink" title="查看系统变量实际值"></a>查看系统变量实际值</h4><p>基本语法: select @@{变量名};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@autocommit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改系统变量"><a href="#修改系统变量" class="headerlink" title="修改系统变量"></a>修改系统变量</h4><h5 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h5><p>只针对当前客户端的本次连接。<br>基本语法: set {变量名} = {新变量值};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">set</span> autocommit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="全局修改"><a href="#全局修改" class="headerlink" title="全局修改"></a>全局修改</h5><p>针对”所有”客户端”所有”时刻。<br>基本语法: set global {变量名} = {新变量值}; 或者 set @@global.{变量名} = {新变量值};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> autocommit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 或者</span><span class="token keyword">set</span> @<span class="token variable">@global.autocommit</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意: 全局修改只针对新客户端有效。</p><h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><p>会话变量又称为用户变量，只针对当前用户使用的当前客户端有效。</p><h4 id="定义用户变量"><a href="#定义用户变量" class="headerlink" title="定义用户变量"></a>定义用户变量</h4><p>基本语法: set @{变量名} = {变量值};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token variable">@name</span> :<span class="token operator">=</span> <span class="token string">'Hello world'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意: 使用 := 是因为 MySQL 中 = 还有比较的含义，为了避免搞混，可以使用 := 来进行赋值操作。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量使用 declare 关键字声明，并且出现在 begin 和 end 语句之间。<br>基本语法: declare {变量名} {数据类型};</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><hr><p>所有函数都是使用: select 函数名(参数列表);</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>char_length(): 判断字符数</li><li>length(): 判断字节数(与字符集有关)</li><li>concat(): 连接字符串</li><li>instr(): 判断字符在目标字符串中是否存在，存在返回位置(从 1 开始)，不存在返回 0</li><li>lcase(): 全部小写</li><li>left(): 从左侧开始截取到指定位置字符串</li><li>ltrim(): 清除左侧空格</li><li>mid(): 从指定位置开始截取字符串到最后</li></ul><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>now(): 返回当前时间，日期和时间</li><li>curdate(): 返回当前日期</li><li>curtime(): 返回当前时间</li><li>datediff(): 判断两日期天数差距</li><li>date_add(): 进行时间增加</li><li>unix_timestamp(): 获取时间戳(10 位)</li><li>from_unixtime(): 从时间戳转为日期时间</li></ul><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><ul><li>abs(): 绝对值</li><li>ceiling(): 向上取整</li><li>floor(): 向下取整</li><li>pow(): 求指数</li><li>rand(): 取随机数</li><li>round(): 四舍五入</li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>简称过程(procedure)，是一组为了完成特定功能的 SQL 语句集。并且在一次编译之后无需再次编译，效率较高。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>基本语法:<br>create procedure {过程名}([参数列表])<br> begin<br>  {过程体}<br> end<br>{结束符};</p><p>如果过程体中只有一条语句，可以省略 begin 和 end。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">procedure</span> my_proc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> my_student<span class="token punctuation">;</span><span class="token keyword">delimiter</span> $$<span class="token keyword">create</span> <span class="token keyword">procedure</span> my_proc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">set</span> <span class="token variable">@sum</span> :<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span> <span class="token keyword">do</span>     <span class="token keyword">set</span> <span class="token variable">@sum</span> <span class="token operator">=</span> <span class="token variable">@sum</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>     <span class="token keyword">set</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span>     <span class="token keyword">select</span> <span class="token variable">@sum</span><span class="token punctuation">;</span><span class="token keyword">end</span>$$<span class="token keyword">delimiter</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看过程"><a href="#查看过程" class="headerlink" title="查看过程"></a>查看过程</h4><p>基本语法: show procedure stutas;</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">procedure</span> stutas<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>基本语法: call {过程名}([参数列表]);</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">call</span> my_proc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h4><p>基本语法: drop procedure {过程名};</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">procedure</span> my_proc<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><hr><p>触发器(trigger)是一种特殊类型的存储过程。触发器通过事件触发而被执行。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>在写入数据表之前，强制检验或转换数据</li><li>触发器发生错误，异动的结果会被撤销</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><ol><li>可以实现表的级联更改</li></ol><ul><li>缺点</li></ul><ol><li>对触发器过分依赖，会影响数据库结构，增加维护的复杂程度</li><li>造成数据在程序层面不可控</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇是 MySQL 的最后一篇，我们最后讲讲变量、函数、存储过程和触发器。&lt;/p&gt;
&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;MySQL 需要很多变量来保存数据。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E4%B9%9D%E4%B9%9D%E5%BD%92%E4%B8%80/"/>
    <id>https://1ess.github.io/%E4%B9%9D%E4%B9%9D%E5%BD%92%E4%B8%80/</id>
    <published>2021-07-14T06:47:45.453Z</published>
    <updated>2021-07-14T06:47:45.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Two things are infinite: the universe and human stupidity; and I’m not sure about the universe.</p></blockquote><p>最近离职了，说不上为什么，就是有一种感觉不能再这样下去了，我不想单纯的经历”吃饭-上班-吃饭-睡觉”这样浑浑噩噩的日子。我希望可以做些什么，我希望可以用我的技术、经验来为这个世界做些什么。</p><p>我一直信奉一句话，种一棵树最好的时间是十年前，其次是现在。很多人劝我年后离职等等，但是我不想也不愿意等，想做的事情我希望立马去做。也正好可以趁这段时间多想想多看看。</p><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/other/other4.jpg"></p><p><sub>在辞职之后的三天零五小时八分钟，我又路过了景江西路，只是这一次，没有下车。</sub></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Two things are infinite: the universe and human stupidity; and I’m not sure about the universe.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近离职了，说</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%BA%94)/"/>
    <id>https://1ess.github.io/C#(%E4%BA%94)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中的表达式和运算符。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr><p>运算符(操作符)是一个符号，表示返回单个结果的操作。<br>一个操作符: </p><ul><li>将操作数作为输入</li><li>执行某个操作</li><li>基于该操作返回一个值</li></ul><p>可以作为操作数的结构有: </p><ul><li>字面量</li><li>常量</li><li>变量</li><li>方法调用</li><li>元素访问器</li><li>其他表达式</li></ul><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>C# 中字面量有: </p><ul><li>整数字面量: 1024</li><li>双精度浮点数字面量: 3.1415</li><li>单精度浮点数字面量: 3.1415F</li><li>布尔值字面量: true，false</li><li>字符字面量: ‘x’</li><li>字符串字面量: “Hi 1ess”</li><li>空引用字面量: null</li></ul><p>根据不同后缀，每个常数能被编译成不同的整数类型: </p><ul><li>后缀 L，被编译成长整型</li><li>后缀 U，被编译成无符号整型</li></ul><p>整型字面量还可以写成十六进制形式，以 0x 或 0X 开头。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span> KernelPanic <span class="token operator">=</span> <span class="token number">0x12131992</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>与其它语言一样，C# 有加，减，乘，除，取余5种运算符。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>与其它语言一样，C# 有大于、大于等于、小于、小于等于、等于、不等于 6 种关系运算符。<br>需要注意的是: 与 Objective-C 和 JavaScript 中不同，C# 的数字不具有布尔含义。<br>对于比较相等时，除了 string 和 delegate 类型的比较是深比较，其他引用类型的比较都是浅比较，只要指向堆中的对象是同一个对象就相等。</p><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>与其它语言一样，也分为前自增和后自增，前自增先增加 1，在返回新值，后自增先返回原值，再增加 1。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>分为逻辑与，逻辑或和逻辑非。与其它语言一样，逻辑运算符也有<strong>短路特性</strong>。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>有位与、位或、位异或、位非、左移和右移操作符。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>分为简单赋值和复合赋值运算符。</p><h3 id="条件运算符-三目运算符"><a href="#条件运算符-三目运算符" class="headerlink" title="条件运算符(三目运算符)"></a>条件运算符(三目运算符)</h3><p>与其它语言一样，三目运算符是基于条件返回两个值中的一个。</p><h3 id="用户定义类型转换"><a href="#用户定义类型转换" class="headerlink" title="用户定义类型转换"></a>用户定义类型转换</h3><p>类型转换我们之后会详细说，这里我们说一下他作为运算符有哪些特点。<br>我们可以为自己的类或者结构定义隐式转换和显式转换: </p><ul><li>对于隐式转换，编译器会自动执行转换</li><li>对于显式转换，编译器只有在使用显式转换运算符时才会转换</li></ul><p>声明隐式转换的语法: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//一定要有 public static</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token function">TargetType</span><span class="token punctuation">(</span>SourceType Identifier<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>显式转换的语法一样，只是把 implicit 换成 explicit: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">LimitInt</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> TheValue <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span>Limit li<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> li<span class="token punctuation">.</span>TheValue<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token function">LimitInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        LimitInt li <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LimitInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        li<span class="token punctuation">.</span>TheValue <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">return</span> li<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        LimitInt li <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>        Int a <span class="token operator">=</span> li<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们声明的是显式转换运算符，那么我们就不得不使用强制类型转换: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">LimitInt</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> TheValue <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span>Limit li<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> li<span class="token punctuation">.</span>TheValue<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">LimitInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        LimitInt li <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LimitInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        li<span class="token punctuation">.</span>TheValue <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">return</span> li<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        LimitInt li <span class="token operator">=</span> <span class="token punctuation">(</span>LimitInt<span class="token punctuation">)</span><span class="token number">500</span><span class="token punctuation">;</span>        Int a <span class="token operator">=</span> <span class="token punctuation">(</span>Int<span class="token punctuation">)</span>li<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><p>typeof 运算符返回作为其参数的任何类型的 System.Type 对象。</p><pre class="line-numbers language-csharp"><code class="language-csharp">Type t <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>SomeClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>GetType 方法也会调用 typeof 运算符。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><hr><p>我们只介绍一下 C# 中比较特殊的语句。<br>C# 中 switch 语句比较特殊的地方在于: 每个 case 语句必须有控制跳转语句如 break，return 等，除非两个 case 语句中没有任何可执行语句: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">switch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">//...</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">//...</span>    <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">//...</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以使用 foreach 遍历数组中的元素，就像 Objective-C 中的 forin 一样。</p><p>对于某些非托管对象，有数量限制或很耗费系统资源，在使用完成之后，应该尽快释放他们，我们就应使用 using 语句简化该过程确保资源被适当处置(dispose)。<br><strong>资源是指实现了 System.IDisposable 接口的类或结构。</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//先分配资源，在使用资源</span><span class="token keyword">using</span> <span class="token punctuation">(</span>ResourceType Identifier <span class="token operator">=</span> Expression<span class="token punctuation">)</span> Statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中的表达式和运算符。&lt;/p&gt;
&lt;h2 id=&quot;运算符&quot;&gt;&lt;a href=&quot;#运算符&quot; class=&quot;headerlink&quot; title=&quot;运算符&quot;&gt;&lt;/a&gt;运算符&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;运算符(操作符)是一个符号，表示返回单个结果的操作。&lt;br&gt;一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%85%AD)/"/>
    <id>https://1ess.github.io/C#(%E5%85%AD)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，讲讲 C# 中的结构体类型和枚举类型。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><hr><p>结构与类类似，都是用户定义类型，都有数据成员和函数成员，但有两个最大的区别: </p><ul><li>类是引用类型而结构是值类型</li><li>结构是隐式密封的</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp">strcut StructName<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    MemberDeclarations<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构是值类型"><a href="#结构是值类型" class="headerlink" title="结构是值类型"></a>结构是值类型</h3><p>因此: </p><ul><li>结构类型的变量不能为 null</li><li>两个结构不能引用同一对象</li></ul><p>把一个结构赋值给另一个结构，就是将这个结构的值复制给另一个结构。需要注意与类的赋值的不同。</p><p>结构允许有实例构造函数和静态构造函数，但不允许有析构函数。</p><p>与类一样，编译器隐式的为结构提供一个无参构造，这个构造将每个成员设置为该类型的默认值。与类不同的是，这个无参构造函数不能被重定义，我们只能创建另外的有参构造，而不能重写无参构造，并且我们提供了有参构造，编译器提供给我们的无参构造依然存在。</p><p>我们也用 new 操作符调用构造函数，即使不从堆中分配内存。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">struct</span> Point<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> X<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> Y<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Point p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以不使用构造来创建结构的实例，但有一些限制: </p><ul><li>显式设置数据成员之后，才可以使用这些成员的值</li><li>对所有的数据成员赋值之后，才能调用任何函数成员</li></ul><p>结构的字段是不允许有初始化语句的。</p><p>之前说了，结构是隐式密封的，因此 protected，internal，abstruct，virtual 修饰符不可使用。</p><p>与 Swift 类似，C# 中的简单预定义类型在实现方式上是使用结构类型。所以可以调用一些方法，如: 所有类型都有的 GetType 方法。<br>另外说一句: JavaScript 中的简单类型如 string 也可以调用方法，他们是在使用值时被临时包装成一个对象。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><hr><p>枚举只有一个类型的成员: 命名的整数值常量。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">enum</span> TrafficLight<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Yellow<span class="token punctuation">,</span>    Green<span class="token punctuation">,</span>    Red<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>枚举的底层都是一个整数类型，默认是 int。<br>默认情况编译器把第一个值赋值为 0，之后的成员加 1。<br>我们把枚举值赋值成枚举对象: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    TrafficLight yellow <span class="token operator">=</span> TrafficLight<span class="token punctuation">.</span>Yellow<span class="token punctuation">;</span>    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>yellow<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//Yellow 打印成员名</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以显式的设置每个枚举成员的值和类型: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">enum</span> TrafficLight<span class="token punctuation">:</span> <span class="token keyword">uint</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Yellow <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span>    Green <span class="token operator">=</span>  <span class="token number">20</span><span class="token punctuation">,</span>    Red <span class="token operator">=</span> <span class="token number">20</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位标记"><a href="#位标记" class="headerlink" title="位标记"></a>位标记</h3><p>我们使用 Flags 特性实现位标记: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token punctuation">[</span>Flags<span class="token punctuation">]</span><span class="token keyword">enum</span> Setting <span class="token punctuation">:</span> <span class="token keyword">uint</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    A <span class="token operator">=</span> <span class="token number">0x0001</span><span class="token punctuation">,</span>    B <span class="token operator">=</span> <span class="token number">0x0010</span><span class="token punctuation">,</span>    C <span class="token operator">=</span> <span class="token number">0x0100</span><span class="token punctuation">,</span>    D <span class="token operator">=</span> <span class="token number">0x1000</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>Setting opts <span class="token operator">=</span> Setting<span class="token punctuation">.</span>A <span class="token operator">|</span> Setting<span class="token punctuation">.</span>B <span class="token operator">|</span> Setting<span class="token punctuation">.</span>C<span class="token punctuation">;</span>opts<span class="token punctuation">.</span><span class="token function">HasFlags</span><span class="token punctuation">(</span>Setting<span class="token punctuation">.</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C# 中的枚举与 Objective-C 的实现 NS_ENUM 和 NS_OPTIONS 类似。</p><p>注意: 枚举是一个独特的类型，比较不同类型的枚举对象会导致编译错误，即使他们的底层都是整数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，讲讲 C# 中的结构体类型和枚举类型。&lt;/p&gt;
&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;结构与类类似，都是用户定义类型，都有数据成员和函数成员，但有两个最大</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%B8%83)/"/>
    <id>https://1ess.github.io/C#(%E4%B8%83)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中的数组对象及其协变概念。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>数组是由变量名表示的一组同类型的数据元素，每个元素可以通过索引来访问。</p><p>C# 数组的特点: </p><ul><li>C# 不支持动态数组，也就是数组一旦创建，就不可以更改大小</li><li>索引从 0 开始</li></ul><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>C# 支持一维数组和多维数组，多维数组又分为矩形数组和交错数组。</p><h3 id="数组是对象"><a href="#数组是对象" class="headerlink" title="数组是对象"></a>数组是对象</h3><p>数组实例是从 System.Array 继承来的对象，继承了很多属性和方法: </p><ul><li>Rank 属性，返回数组的维数</li><li>Length 属性，返回数组的长度</li></ul><p>注意: 数组是引用类型，数组元素可以是值类型也可以是引用类型，这一点与 Ocjective-C 不同，Ocjective-C 中的数组元素不能是基本类型。</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>我们可以在类型和变量名之间加中括号来声明一维数组: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要实例化一维数组，我们使用数组创建表达式，使用 new 操作符，后跟基类名称和中括号，中括号里要有数组长度: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要访问数组元素，要使用索引: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> intVal <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>当数组创建后，每个元素会自动初始化默认值: </p><ul><li>整型: 0</li><li>浮点数: 0.0</li><li>布尔型: false</li><li>对象: null</li></ul><p>我们还可以使用初始化列表显式初始化数组元素: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当在一条语句声明并初始化数组时，可以使用快捷语法: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以使用 foreach 语句遍历数组元素: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">var</span> item <span class="token keyword">in</span> array<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...item</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组的协变"><a href="#数组的协变" class="headerlink" title="数组的协变"></a>数组的协变</h3><p>协变和逆变我们之后说泛型的时候会细讲，这里我们只是提一下数组中的协变。<br>协变是指: 即使某个对象不是数组的基类型，我们也可以把他赋值给数组元素。以下情况可以使用数组协变: </p><ul><li>数组是引用类型数组</li><li>赋值类型和数组基类类型存在显式或隐式转换</li></ul><p>由于基类和派生类总存在隐式转换，因此我们可以把派生类对象赋值给基类型数组元素: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">:</span> A <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        A<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中的数组对象及其协变概念。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;数组是由变量名表示的一组同类型的数据元素，每个元素可以通过索引来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%85%AB)/"/>
    <id>https://1ess.github.io/C#(%E5%85%AB)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中特殊的委托(delegate)。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>委托和类一样，都是用户定义类型。类表示数据和方法的集和，而委托则是持有一个或多个方法，以及一系列预定义操作。</p><p>我们通过以下步骤来使用委托: </p><ul><li>声明一个委托，委托的声明看上去和方法声明类似，只是没有实现块</li><li>使用委托类型声明一个委托变量</li><li>创建委托类型的变量，赋值为委托变量，这个委托类型变量指向方法的引用，这个方法和委托定义的签名和返回值类型一样</li><li>可以为委托对象增加其他方法</li><li>可以像调用方法一样调用委托，调用委托时，其包含的每一个方法都会被执行</li></ul><h3 id="声明委托"><a href="#声明委托" class="headerlink" title="声明委托"></a>声明委托</h3><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">delegate</span> <span class="token keyword">void</span> <span class="token function">MyDel</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建委托对象"><a href="#创建委托对象" class="headerlink" title="创建委托对象"></a>创建委托对象</h3><p>有两种方式创建委托对象: </p><ul><li>第一种是使用 new 操作符的创建表达式，参数是调用列表第一个方法的名字</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp">delVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDel</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>MyM1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//实例方法</span>dVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDel</span><span class="token punctuation">(</span>SClass<span class="token punctuation">.</span>OtherM2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//静态方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>我们还可以使用快捷语法，直接赋值为方法名即可</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp">delVal <span class="token operator">=</span> instance<span class="token punctuation">.</span>MyM1<span class="token punctuation">;</span>dVal <span class="token operator">=</span> SClass<span class="token punctuation">.</span>OtherM2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="为委托增加方法"><a href="#为委托增加方法" class="headerlink" title="为委托增加方法"></a>为委托增加方法</h3><p>我们使用 += 操作符为委托增加方法。</p><pre class="line-numbers language-csharp"><code class="language-csharp">MyDel  del <span class="token operator">=</span> inst<span class="token punctuation">.</span>M1<span class="token punctuation">;</span>del <span class="token operator">+</span><span class="token operator">=</span> SCl<span class="token punctuation">.</span>M3<span class="token punctuation">;</span>del <span class="token operator">+</span><span class="token operator">=</span> X<span class="token punctuation">.</span>Act<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同样使用 -= 从委托移除方法。</p><h3 id="调用委托"><a href="#调用委托" class="headerlink" title="调用委托"></a>调用委托</h3><p>我们可以像调用方法一样调用委托: </p><pre class="line-numbers language-csharp"><code class="language-csharp">MyDel  del <span class="token operator">=</span> inst<span class="token punctuation">.</span>M1<span class="token punctuation">;</span>del <span class="token operator">+</span><span class="token operator">=</span> SCl<span class="token punctuation">.</span>M3<span class="token punctuation">;</span>del <span class="token operator">+</span><span class="token operator">=</span> X<span class="token punctuation">.</span>Act<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//...</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token number">444</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调用带有返回值的委托"><a href="#调用带有返回值的委托" class="headerlink" title="调用带有返回值的委托"></a>调用带有返回值的委托</h3><ul><li>调用列表最后一个方法返回的值就是委托返回值</li><li>调用列表的其他方法返回值将被忽略</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">delegate</span> <span class="token keyword">int</span> <span class="token function">MyDel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyCls</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> IntVal <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> IntVal <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token keyword">return</span> IntVal<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Add3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> IntVal <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token keyword">return</span> IntVal<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        MyCls cls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyDel del <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDel</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span>Add2<span class="token punctuation">)</span><span class="token punctuation">;</span>        del <span class="token operator">+</span><span class="token operator">=</span> cls<span class="token punctuation">.</span>Add3<span class="token punctuation">;</span>        del <span class="token operator">+</span><span class="token operator">=</span> cls<span class="token punctuation">.</span>Add2<span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//12</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调用带引用参数的委托"><a href="#调用带引用参数的委托" class="headerlink" title="调用带引用参数的委托"></a>调用带引用参数的委托</h3><p>再调用方法列表的下一个方法时，参数的新值会传给下一个方法。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">delegate</span> <span class="token keyword">void</span> <span class="token function">MyDel</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyCls</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Add2</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Add3</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        MyCls cls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyDel del <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDel</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span>Add2<span class="token punctuation">)</span><span class="token punctuation">;</span>        del <span class="token operator">+</span><span class="token operator">=</span> cls<span class="token punctuation">.</span>Add3<span class="token punctuation">;</span>        del <span class="token operator">+</span><span class="token operator">=</span> cls<span class="token punctuation">.</span>Add2<span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token function">del</span><span class="token punctuation">(</span><span class="token keyword">ref</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//12</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>我们可以使用 Lambda 表达式创建委托对象。<br>C# 中的 Lambda 表达式与 JavaScript 中的很像。如果只有一个参数，可以省略括号，如果只有一个返回值语句，可以省略大括号和 reuturn 关键字。</p><pre class="line-numbers language-csharp"><code class="language-csharp">MyDel del <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//简写形式</span>MyDel del <span class="token operator">=</span> x <span class="token operator">=</span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中特殊的委托(delegate)。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;委托和类一样，都是用户定义类型。类表示数据和方法的集和，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%B9%9D)/"/>
    <id>https://1ess.github.io/C#(%E4%B9%9D)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>前几篇，我们都在讲类型，这一篇，我们来说说事件成员。</p><h2 id="发布者和订阅者"><a href="#发布者和订阅者" class="headerlink" title="发布者和订阅者"></a>发布者和订阅者</h2><hr><p>很多程序都会有一个需求: 当一个特定事件发生时，程序的其他部分可以得到这个事件发生的通知。<br>发布者/订阅者模式可以满足这个需求:<br>发布者定义了一系列事件，其他类可以注册某些事件，以便在事件发生时，订阅者可以收到通知响应事件。订阅者注册事件时提供的方法称为回调函数或者事件处理程序。</p><p>在 Objective-C 中，我们可以在某些类 addObserver 注册一些事件处理程序，当事件发生时，pushNotifacitation。在 JavaScript 中，我们同样可以 addEventListener 注册一些事件处理程序。</p><p>发布者: 发布某个事件的类或结构<br>订阅者: 注册并在事件发生时得到通知执行事件处理程序的类或结构<br>事件处理程序: 当事件发生时执行的回调函数</p><p><strong>事件包含了一个私有委托</strong>。<br>关于事件的私有委托: </p><ul><li>事件提供了对他的私有委托的结构化访问，我们无法直接访问私有委托</li><li>对于事件，我们只可以添加，删除和调用事件处理程序</li><li>事件触发时，会依次调用调用列表的方法</li></ul><h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><hr><p>发布者类必须提供事件对象。声明事件需要委托类型和事件名: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">MyCls</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//声明事件: event 关键字，EventHandler 委托类型，CountedADozen 事件名</span>    <span class="token keyword">public</span> <span class="token keyword">event</span> EventHandler CountedADozen<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: 事件是成员而不是类型，由于他是成员: </p><ul><li>我们不能在可执行代码中声明事件</li><li>必须声明在类或结构中</li><li>声明事件需要委托类型，我们可以声明一个委托或使用已存在的。</li></ul><p>BCL 声明了一个 EventHandler 的委托，专门处理系统事件。</p><h2 id="订阅事件"><a href="#订阅事件" class="headerlink" title="订阅事件"></a>订阅事件</h2><hr><p>订阅者向事件添加处理程序: </p><ul><li>使用 += 运算符为事件添加事件处理程序</li><li>事件处理程序可以是: <ol><li>实例方法名称</li><li>静态方法名称</li><li>匿名方法</li><li>Lambda 表达式</li></ol></li></ul><pre class="line-numbers language-csharp"><code class="language-csharp">cls<span class="token punctuation">.</span>CountedADozen <span class="token operator">+</span><span class="token operator">=</span> IncreatmentCountedADozen<span class="token punctuation">;</span>cls<span class="token punctuation">.</span>CountedADozen <span class="token operator">+</span><span class="token operator">=</span> ClassB<span class="token punctuation">.</span>CountedHandlerB<span class="token punctuation">;</span>cls<span class="token punctuation">.</span>CountedADozen <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> DozensCount <span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><hr><p>触发事件时要注意: </p><ul><li>触发前要与 null 比较，如果是 null，则不能执行</li><li>触发事件的语法与调用方法一样</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几篇，我们都在讲类型，这一篇，我们来说说事件成员。&lt;/p&gt;
&lt;h2 id=&quot;发布者和订阅者&quot;&gt;&lt;a href=&quot;#发布者和订阅者&quot; class=&quot;headerlink&quot; title=&quot;发布者和订阅者&quot;&gt;&lt;/a&gt;发布者和订阅者&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;很多程序都会有一个需求</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们再回来说说最后一种类型: 接口(interface)。</p><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>接口是指定一组函数成员而不实现他们的引用类型。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">interface</span> <span class="token class-name">IInfo</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">string</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">string</span> <span class="token function">GetAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以用类或结构来实现接口。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">MyCls</span><span class="token punctuation">:</span> IComparable<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> TheValue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span>  <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token keyword">object</span> obj<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        MyCls cls <span class="token operator">=</span> <span class="token punctuation">(</span>MyCls<span class="token punctuation">)</span>obj<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>TheValue <span class="token operator">></span> cls<span class="token punctuation">.</span>TheValue<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>TheValue <span class="token operator">&lt;</span> cls<span class="token punctuation">.</span>TheValue<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h3><ul><li><p>接口声明不能包含数据成员和静态成员</p></li><li><p>接口只能包含如下非静态成员: </p><ol><li>方法</li><li>属性</li><li>事件</li><li>索引器</li></ol></li><li><p>接口应该以大写字母 I 开始</p></li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IMyInterface</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//注意: 接口函数成员不能有访问修饰符</span>    <span class="token keyword">int</span> <span class="token function">DoStuff</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>要实现接口: </p><ul><li>与继承类似，类或结构后跟冒号，再跟接口名</li><li>为每一个接口成员提供实现</li></ul><p>注意: 如果有继承，并实现接口，基类名必须出现在接口之前: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> BaseClass<span class="token punctuation">,</span> IIfc1<span class="token punctuation">,</span> IIfc2<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><ul><li>类或结构可以实现任意数量的接口</li><li>所有实现的接口，必须列在基类列表以逗号分隔</li></ul><h3 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h3><p>与类的继承不同，接口可以多继承。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">interface</span> <span class="token class-name">IData</span> <span class="token punctuation">:</span> IDataR<span class="token punctuation">,</span> IDataS<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们再回来说说最后一种类型: 接口(interface)。&lt;/p&gt;
&lt;h3 id=&quot;什么是接口&quot;&gt;&lt;a href=&quot;#什么是接口&quot; class=&quot;headerlink&quot; title=&quot;什么是接口&quot;&gt;&lt;/a&gt;什么是接口&lt;/h3&gt;&lt;p&gt;接口是指定一组函数成员而不实现他们</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%B8%80)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%B8%80)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们再来看看 C# 中的显式转换以及隐式转换。</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>有些类型的转换不会丢失数据或精度: </p><ul><li>C# 会自动做这些转换，称为隐式转换</li><li>从位数少的源转换为位数更多的源，目标多出来的位使用 0 或 1 补充</li><li>当从小的无符号类型转换为更大的无符号类型，多出来的位以 0 进行填充，称为 0 扩展</li><li>对于有符号类型，额外的高位使用符号位进行扩展，称为符号扩展</li></ul><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>对于源类型的任意值在被转换为目标类型时会丢失的情况，C# 语言是不提供两种类型的自动转换，如果我们希望这两种类型进行转换，就必须使用显式转换，这叫做强制转换表达式。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">ushort</span> var1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">sbyte</span> var2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">sbyte</span><span class="token punctuation">)</span>var1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>C# 所有类型都继承自 object 类型，然而，值类型是高效轻量的类型，但是当我们需要对象组件，可以使用装箱。<br>装箱是一种隐式转换，接受值类型的值，在堆上创建一个引用类型对象，返回该引用。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token keyword">object</span> oi <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>oi <span class="token operator">=</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是: 装箱操作的时一个副本，装箱之后，原始值和引用副本可以独立操作。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">object</span> oi <span class="token operator">=</span> i<span class="token punctuation">;</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"i: &amp;#123;0&amp;#125;, oi: &amp;#123;1&amp;#125;"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> oi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10, 10</span>i <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>oi <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"i: &amp;#123;0&amp;#125;, oi: &amp;#123;1&amp;#125;"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> oi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 12, 15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h3><p>拆箱是将装箱后的引用返回值类型的操作。<br>注意: 拆箱是显式转换。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">object</span> oi <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>oi<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>拆箱非值类型会抛出异常。</p><h3 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h3><p>我们可以使用 is 运算符检测转换是否会成功，避免盲目转换。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">:</span> Person <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token operator">=</span> <span class="token string">"1ess"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> Age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Employee emp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>emp <span class="token keyword">is</span> Person p<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果转换失败，返回 false</span>            <span class="token comment" spellcheck="true">//如果转换成功，返回 true，并赋值给 p</span>            <span class="token comment" spellcheck="true">//...</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="as-运算符"><a href="#as-运算符" class="headerlink" title="as 运算符"></a>as 运算符</h3><p>as 运算符和强制转换类似，只是他不会抛出异常。如果转换失败，会返回 null。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">:</span> Person <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token operator">=</span> <span class="token string">"1ess"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> Age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Employee emp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person p <span class="token operator">=</span> emp <span class="token keyword">as</span> Person<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//...</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们再来看看 C# 中的显式转换以及隐式转换。&lt;/p&gt;
&lt;h3 id=&quot;隐式转换&quot;&gt;&lt;a href=&quot;#隐式转换&quot; class=&quot;headerlink&quot; title=&quot;隐式转换&quot;&gt;&lt;/a&gt;隐式转换&lt;/h3&gt;&lt;p&gt;有些类型的转换不会丢失数据或精度: &lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%BA%8C)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%BA%8C)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>理想有两种: 一种，我实现了我的理想；另一种: 理想通过我而实现。</p></blockquote><p>这一篇，讲讲泛型。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>没有泛型的时候，我们封装的行为都是作用在特定类型上的，但是，很多时候如果我们把行为提取或重构出来，使其可以应用到很多类型上去的话，那么就会更有意义。这也是泛型出现的原因。</p><p>我们可以额外增加一层抽象，这样类型就不用再硬编码了，这样就可以使得多段代码在不同类型执行相同的指令成为可能。</p><p>之前写 Objective-C 的时候，感觉他的泛型太弱了，现在写 C#，感觉他的泛型系统太好用了！</p><h3 id="无泛型栈示例"><a href="#无泛型栈示例" class="headerlink" title="无泛型栈示例"></a>无泛型栈示例</h3><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">MyIntStack</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> StackPoint <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> StackArray<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果希望将相同的功能应用于 float 类型，我们就必须复制粘贴上面的代码再改成 float。<br>这样做可行，但是缺点明显: </p><ul><li>我们要仔细检查类型的修改</li><li>每当新增类型，就要复制粘贴修改</li><li>调试维护这些类似的代码易出错</li></ul><h3 id="C-中的泛型"><a href="#C-中的泛型" class="headerlink" title="C# 中的泛型"></a>C# 中的泛型</h3><p>泛型(generic)提供了更优雅的解决方案，让多个类型共享一组代码。我们可以使用类型占位符书写代码，在创建实例时指明实际类型即可。</p><p>C# 提供了 5 种泛型可用在的地方: 类、结构、接口、委托、方法。前四种是类型，最后一种是成员。</p><h3 id="泛型栈示例"><a href="#泛型栈示例" class="headerlink" title="泛型栈示例"></a>泛型栈示例</h3><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> StackPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    T<span class="token punctuation">[</span><span class="token punctuation">]</span> StackArray<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> T <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="声明泛型类"><a href="#声明泛型类" class="headerlink" title="声明泛型类"></a>声明泛型类</h3><p>上面我们已经展示了一个示例来演示泛型类，这里我们具体介绍一下，看看如何创建并使用泛型类。<br>创建使用非泛型类有两步: 声明类和创建类的实例。<br>但是泛型类不是实际类，而是类的模板，所以我们必须先从模板构建出实际类型，然后创建这个构建后的类型的实例。</p><p>声明步骤: </p><ul><li>在类名后放置一对尖括号&lt;&gt;</li><li>在尖括号中用逗号分隔占位字符串来表示希望提供的类型，这叫做类型参数(type parameters)</li><li>在泛型类的主体使用类型参数代替实际类型</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> T1 SomeVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> T2 OtherVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建构造类型"><a href="#创建构造类型" class="headerlink" title="创建构造类型"></a>创建构造类型</h3><p>列出类名并在尖括号中提供真实类型代替类型参数，我们将替代类型参数的真实类型称为类型实参(type argument)。</p><pre class="line-numbers language-csharp"><code class="language-csharp">SomeClass<span class="token operator">&lt;</span><span class="token keyword">short</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>非泛型类创建实例: </p><pre class="line-numbers language-csharp"><code class="language-csharp">MyNonGenClass myNGC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyNonGenClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>泛型类创建实例: </p><pre class="line-numbers language-csharp"><code class="language-csharp">SomeClass<span class="token operator">&lt;</span><span class="token keyword">short</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mySc1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SomeClass</span><span class="token operator">&lt;</span><span class="token keyword">short</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="类型参数约束"><a href="#类型参数约束" class="headerlink" title="类型参数约束"></a>类型参数约束</h3><p>为了让泛型变得更有用，我们需要提供额外信息让编译器知道 type parameter 可以接受哪些类型。<br>这些额外信息称为约束(constraint)。</p><h4 id="Where-子句"><a href="#Where-子句" class="headerlink" title="Where 子句"></a>Where 子句</h4><ul><li>每个 type parameter 都有自己的 where 子句</li><li>如果有多个约束，在约束列表用逗号分隔</li></ul><p>where 子句使用要点: </p><ul><li>在关闭尖括号后列出</li><li>where 子句之间不用逗号分隔</li><li>子句之间可以以任何顺序列出</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> T3<span class="token operator">></span>                      <span class="token keyword">where</span> T2<span class="token punctuation">:</span> Customer                      <span class="token keyword">where</span> T3<span class="token punctuation">:</span> IComparable<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="约束类型和次序"><a href="#约束类型和次序" class="headerlink" title="约束类型和次序"></a>约束类型和次序</h4><p>共有 5 种类型的约束: </p><ul><li>类名: 某种类或类的子类才能做 type argument</li><li>class: 任何引用类型才能做 type argument</li><li>struct: 任何值类型才能做 type argument</li><li>接口名: 只有这个接口或实现这个接口的类型才能做 type argument</li><li>new(): 任何带有无参构造的类型才能做 type argument</li></ul><p>顺序: </p><ul><li>主约束必须放在第一位且只有一个: 主约束只能是类名、class 或者 struct</li><li>接口名约束可以有任意多个</li><li>如果存在构造约束，必须放在最后</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">SortedList</span><span class="token operator">&lt;</span>S<span class="token operator">></span>                         <span class="token keyword">where</span> S<span class="token punctuation">:</span> IComparable<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>M<span class="token punctuation">,</span> N<span class="token operator">></span>                         <span class="token keyword">where</span> M<span class="token punctuation">:</span> IComparable<span class="token operator">&lt;</span>M<span class="token operator">></span>                         <span class="token keyword">where</span> N<span class="token punctuation">:</span> ICloneable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyDictionary</span><span class="token operator">&lt;</span>KeyType<span class="token punctuation">,</span> ValueType<span class="token operator">></span>                              <span class="token keyword">where</span> KeyType<span class="token punctuation">:</span> IEnumerable<span class="token punctuation">,</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>与其他的泛型不同，泛型方法是成员而不是类型，它可以用于泛型、非泛型类、结构或接口。</p><h4 id="声明泛型方法"><a href="#声明泛型方法" class="headerlink" title="声明泛型方法"></a>声明泛型方法</h4><p>泛型方法具有类型参数和可选的约束。<br>泛型方法有两个参数列表: </p><ul><li>封闭在圆括号内的方法参数列表</li><li>封闭在尖括号内的类型参数列表</li></ul><p>要声明泛型方法: </p><ul><li>在方法名之后，方法参数之前放置类型参数列表</li><li>在方法参数之后放置可选的约束子句</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token generic-method function">PrintData<span class="token punctuation">&lt;</span>S<span class="token punctuation">,</span> T<span class="token punctuation">></span> </span><span class="token punctuation">(</span>S s<span class="token punctuation">,</span> T t<span class="token punctuation">)</span> <span class="token keyword">where</span> S<span class="token punctuation">:</span> Person<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调用泛型方法"><a href="#调用泛型方法" class="headerlink" title="调用泛型方法"></a>调用泛型方法</h4><p>要调用泛型方法，需要在调用时提供类型实参: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token generic-method function">MyMethod<span class="token punctuation">&lt;</span><span class="token keyword">short</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们在调用泛型方法时，可以从方法参数推断出类型实参，则可以省略类型实参: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token generic-method function">MyMethod<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span> </span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> IntVal <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">MyMethod</span><span class="token punctuation">(</span>IntVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型结构"><a href="#泛型结构" class="headerlink" title="泛型结构"></a>泛型结构</h3><p>与泛型类一样，泛型结构也有类型参数和约束子句。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">struct</span> PieceOfData <span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> T _Data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">PieceOfData</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        _data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> T Data     <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">set</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> _data <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">get</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> _data<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> intData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PieceOfData</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"&amp;#123;intData.Data&amp;#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h3><p>泛型委托与非泛型委托类似，要声明泛型委托，需要在委托名称之后，委托参数列表之前放置类型参数列表: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">delegate</span> R <span class="token generic-method function">MyDelegate <span class="token punctuation">&lt;</span>T<span class="token punctuation">,</span> R<span class="token punctuation">></span></span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C# 中有两个常用的预定义的泛型委托: Func 和 Action: </p><ul><li>Action 是无返回值的泛型委托，有 16 个重载(即最多 16 个参数)</li><li>Func 是有返回值的泛型委托，有 17 个重载(即最多 16 个参数和 1 个返回值)</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">delegate</span> TR <span class="token generic-method function">Func <span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> TR<span class="token punctuation">></span></span><span class="token punctuation">(</span>T1 p1<span class="token punctuation">,</span> T2 p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Simple</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">string</span> <span class="token function">PrintString</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> total <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>        <span class="token keyword">return</span> total<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> myDel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Func</span> <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">(</span>Simple<span class="token punctuation">.</span>PrintString<span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"&amp;#123;myDel(2, 3)&amp;#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 5</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口允许我们编写参数和返回值是泛型类型参数的接口。我们需要在接口名之后用尖括号放置类型参数列表。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">interface</span> <span class="token class-name">IMyIfc</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    T <span class="token function">ReturnIt</span><span class="token punctuation">(</span>T val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Simple</span><span class="token operator">&lt;</span>S<span class="token operator">></span><span class="token punctuation">:</span> IMyIfc<span class="token operator">&lt;</span>S<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> S <span class="token function">ReturnIt</span><span class="token punctuation">(</span>S s<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> simple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Simple</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"&amp;#123;simple.ReturnIt(3)&amp;#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 3</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;理想有两种: 一种，我实现了我的理想；另一种: 理想通过我而实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一篇，讲讲泛型。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%B8%89)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%B8%89)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们看看 C# 中的枚举器和迭代器的基本概念。<br>之前我们说过可以使用 foreach 来遍历数组元素，本篇来讨论为什么数组可以使用 foreach 语句处理，我们可以还使用迭代器来使得自定义类型也可以使用 foreach。</p><h2 id="枚举器和可枚举类型"><a href="#枚举器和可枚举类型" class="headerlink" title="枚举器和可枚举类型"></a>枚举器和可枚举类型</h2><hr><p>为什么数组可以使用 foreach 呢？因为数组可以提供一个枚举器(enumerator)对象。枚举器对象可以依次返回数组元素。<br>获取一个对象的枚举器可以调用对象的 GetEnumerator 方法。实现了 GetEnumerator 方法的对象称为可枚举(enumerable)对象。</p><p>foreach 语句就是用来配合可枚举类型一起使用的，他会执行下列行为: </p><ul><li>调用 GetEnumerator 方法获取对象的枚举器</li><li>从枚举器请求每一项作为迭代变量(iteration variable)，我们可以读取该变量但不能改变</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">foreach</span> <span class="token punctuation">(</span>Type ValName <span class="token keyword">in</span> EnumerableObject<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h3><p>实现 IEnumerator 接口的枚举器包含三个函数成员: </p><ul><li>Current: 返回当前位置项的属性，只读</li><li>MoveNext: 把枚举器位置前进到集合下一项的方法，返回布尔值，位置有效返回 true，无效(到达尾部)返回 false。枚举器原始位置在第一项之前，因此在使用 Current 之前必须先调用 MoveNext</li><li>Reset: 位置重置为原始状态</li></ul><p>下面代码与直接使用 foreach 产生的结果是一样的: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> MyArr <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        IEnumerator ie <span class="token operator">=</span> MyArr<span class="token punctuation">.</span><span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>ie<span class="token punctuation">.</span><span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ie<span class="token punctuation">.</span>Current<span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h3><p>可枚举类型是指实现了 IEnumerable 接口的类。IEnumerable 只有一个函数成员: </p><ul><li>GetEnumerator: 获取可枚举类型的枚举器</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">:</span> IEnumerable<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> IEnumerator <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用-IEnumerator-和-IEnumerable-示例"><a href="#使用-IEnumerator-和-IEnumerable-示例" class="headerlink" title="使用 IEnumerator 和 IEnumerable 示例"></a>使用 IEnumerator 和 IEnumerable 示例</h3><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ColorEnumerator</span> <span class="token punctuation">:</span> IEnumerator<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _colors<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> _position <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ColorEnumerator</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> colors<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        _colors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">[</span>colors<span class="token punctuation">.</span>Length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> colors<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            _colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">object</span> Current <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">get</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_position <span class="token operator">&lt;=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> _position <span class="token operator">>=</span> _colors<span class="token punctuation">.</span>Length<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> _colors<span class="token punctuation">[</span>_position<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>_position <span class="token operator">&lt;</span> _colors<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            _position<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        _position <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Colors</span> <span class="token punctuation">:</span> IEnumerable<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _colors<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Colors</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> colors<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        _colors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">[</span>colors<span class="token punctuation">.</span>Length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> colors<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            _colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> IEnumerator <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ColorEnumerator</span><span class="token punctuation">(</span>_colors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Progeam</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Colors colors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Colors</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">string</span> color <span class="token keyword">in</span> colors<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h3><p>之前我们写的都是非泛型版本，实际工作中，我们基本都使用泛型版本的 IEnumerator<T> 和 IEnumerable<T> 。非泛型版本只是兼任 2.0 版本之前无泛型的遗留代码。</p><p>泛型与非泛型版本的主要区别是: </p><ul><li>IEnumerable<T> 接口的 GetEnumerator 方法要返回实现 IEnumerator<T> 接口的枚举器实例</li><li>泛型版本的 Current 属性返回的不是 object 类型，而是实际类型的对象</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>C# 2.0 之后，提供了更简单的创建枚举器和可枚举类型的方式。这种结构称为迭代器(iterator)。</p><ul><li>迭代器返回一个泛型的枚举器</li><li>yield return 语句声明这是枚举的下一项</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> IEnumerator<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span> <span class="token function">BlackAndWhite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token string">"black"</span><span class="token punctuation">;</span>    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token string">"gray"</span><span class="token punctuation">;</span>    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token string">"white"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们看看 C# 中的枚举器和迭代器的基本概念。&lt;br&gt;之前我们说过可以使用 foreach 来遍历数组元素，本篇来讨论为什么数组可以使用 foreach 语句处理，我们可以还使用迭代器来使得自定义类型也可以使用 foreach。&lt;/p&gt;
&lt;h2 id=&quot;枚举器和可枚</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E5%9B%9B)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E5%9B%9B)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，讲讲 LINQ。<br>LINQ(发音同 link，不要读成 lin-q)代表语言集成查询(Language Integrated Query)，他是 .Net 的扩展，允许我们很轻松的操作对象集合。<br>LINQ 的出现也就意味着允许我们在 C# 中使用函数式编程的思想。</p><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>创建匿名对象与创建具名对象类似，只是没有类名和构造函数: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">new</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> FieldProp <span class="token operator">=</span> InitExpr<span class="token punctuation">;</span> FieldProp <span class="token operator">=</span> InitExpr<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意: </p><ul><li>匿名对象只能用于局部变量，不能用于成员</li><li>必须是由 var 作为类型</li><li>不能设置属性，匿名对象的属性是只读的</li></ul><h3 id="方法语法和查询语法"><a href="#方法语法和查询语法" class="headerlink" title="方法语法和查询语法"></a>方法语法和查询语法</h3><p>我们再写 LINQ 可以使用两种语法: </p><ul><li>方法语法</li><li>查询语法</li></ul><p>微软推荐使用查询语法，但是我更习惯方法语法。<br><strong>更新: 查询语法真香！</strong></p><h3 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h3><p>LINQ 查询返回两种类型的结果: </p><ul><li>可枚举的类型</li><li>单一标量</li></ul><h3 id="标准查询运算符"><a href="#标准查询运算符" class="headerlink" title="标准查询运算符"></a>标准查询运算符</h3><p>标准查询运算符由一系列 API 方法组成，标准查询运算符特性如下: </p><ul><li>被查询的集合对象称为序列，必须实现 IEnumerable<T> 接口</li><li>标准查询运算符使用方法语法</li><li>一些运算符返回 IEnumerable<T> 对象，一些则返回标量</li><li>很多操作都以谓词作为参数，谓词是一个方法，以对象作为参数，根据是否满足条件返回 true 或 false</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 6</span>        <span class="token keyword">int</span> howMany <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C# 中的序列包括 Array、List<T>、Dictionary&lt;T1, T2&gt; 等。LINQ 可以以非常强大的方式来操纵这些对象。</p><p>共有 47 个标准查询运算符，常用的如: Where(类似于 filter)、Select(类似于 map)、toList<T>、First、FirstOrDefault、Last、LastOrDefault、Take、Skip 等，当我们需要使用高级用法时，我们可以在查询文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，讲讲 LINQ。&lt;br&gt;LINQ(发音同 link，不要读成 lin-q)代表语言集成查询(Language Integrated Query)，他是 .Net 的扩展，允许我们很轻松的操作对象集合。&lt;br&gt;LINQ 的出现也就意味着允许我们在 C# 中使用函数式编</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%BA%94)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%BA%94)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 网络编程中比较重要的概念 —— 异步。</p><h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><p>当程序启动时，系统就会在内存创建一个新进程。进程是构成程序的资源的集合，资源包括虚拟地址、文件句柄等。</p><p>在进程内部，系统还创建了称为线程的内核对象。也就是说一旦进程创建，系统就会在 Main 方法的第一行语句开始线程执行。</p><p>关于线程: </p><ul><li>默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束</li><li>线程可以派生其他线程</li><li>如果一个进程包含多个线程，他们将共享进程资源</li><li>系统为处理器执行所规划的基本单元是线程而不是进程</li></ul><p>在 C# 5.0 引入了一个非常好的特性 —— async/await。在 JavaScript 和即将到来的 Swift 5.0 中都存在引入了此特性，虽然实现的底层原理并不相同。<br>这个特性是 .Net 框架的一部分，但是没有嵌入 C# 中。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>如果程序调用某个方法，等待其执行所有处理之后才继续执行，我们称这样的方法为同步方法。<br>相反的，异步方法就是在处理完成之前就返回到调用方法。我们使用 async/await 特性可以很方便的创建异步方法。<br>该特性有三部分组成: </p><ul><li>调用方法: 调用异步方法的方法，在异步方法执行任务时继续执行</li><li>异步方法: 该方法异步执行其工作，然后立即返回到调用方法</li><li>await 表达式: 用于异步方法内，指明需要异步执行的任务，一个异步方法可以包含多个 await 表达式，如果一个都不包含，则该方法将同步执行，编译器会报警告</li></ul><p>async 关键字是一个专门给编译器的提示，意思是该函数的实现可能会出现 await 表达式。</p><ul><li>在 Debug 模式下，对于 async 方法，生成一个 class 状态机</li><li>在 Release 模式下，对于 async 方法，生成一个 struct 状态机</li></ul><h3 id="什么是异步方法"><a href="#什么是异步方法" class="headerlink" title="什么是异步方法"></a>什么是异步方法</h3><p>异步方法的特点: </p><ul><li>方法头包含 async 方法修饰符</li><li>包含一个或多个 await 表达式表示异步完成的任务</li><li>返回值只能是 void，Task 或 Task&lt;T&gt;</li><li>异步方法参数不能有 out 或 ref 修饰</li><li>按照约定，异步方法以 Async 结尾</li><li>Lambda 表达式也可以作为异步对象</li><li>调用方法读取 Task 的 Result 属性获取 T 类型的值</li><li>任何返回 Task&lt;T&gt; 的异步方法必须返回 T 类型的值</li></ul><p>需要注意: </p><ul><li>不要使用 void 作为 async 方法的返回值类型，async 方法可以返回 void，仅限于编写事件处理程序，如果是普通方法没有返回值，需要返回 Task</li><li>避免使用 Task.Wait 和 Task.Result 方法，可能会导致死锁</li><li>当第一次遇到 await 表达式所返回的类型就是方法头的返回值类型，与 await 表达式的返回值类型没关系</li><li>异步方法的 return 语句并没有真正返回值，而只是退出了</li></ul><h3 id="在调用方法同步等待任务"><a href="#在调用方法同步等待任务" class="headerlink" title="在调用方法同步等待任务"></a>在调用方法同步等待任务</h3><p>我们可能需要在调用方法中同步等待某个任务完成，Task&lt;T&gt; 实例提供了 Wait 方法，来等待某个特殊的 Task 完成。<br>还可以使用 Task 的静态方法 WaitAll 和 WaitAny 方法同步等待多个任务完成。参数为 Task[]。</p><h3 id="在异步方法异步等待任务"><a href="#在异步方法异步等待任务" class="headerlink" title="在异步方法异步等待任务"></a>在异步方法异步等待任务</h3><p>我们可以使用 await 和 Task 的静态方法 WhenAll 和 WhenAny 方法异步等待多个任务完成。参数为 List&lt;Task&lt;T&gt;&gt;。</p><p>注意: async 和 await 都没有新开线程，新开线程是 Task.Run() 做的事情。如果自己编写异步方法，注意要自己编写 Task.Run()。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 网络编程中比较重要的概念 —— 异步。&lt;/p&gt;
&lt;h3 id=&quot;什么是异步&quot;&gt;&lt;a href=&quot;#什么是异步&quot; class=&quot;headerlink&quot; title=&quot;什么是异步&quot;&gt;&lt;/a&gt;什么是异步&lt;/h3&gt;&lt;p&gt;当程序启动时，系统就会在内存创建一个新</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E5%85%AD)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E5%85%AD)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中的异常处理 —— try、catch、finially。</p><h3 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h3><p>异常是程序运行时错误，出现正常操作时未预料的情况。当发生时，系统会捕获这个错误并抛出异常。<br>在编写 iOS 程序时，我们可能很少使用异常，通常我们使用 NSError **error 这样的二级指针来获取错误对象，处理不同的错误。</p><h3 id="try-语句"><a href="#try-语句" class="headerlink" title="try 语句"></a>try 语句</h3><p>try 语句是为了避免出现异常而被保护的代码段，在出现异常时提供异常处理。<br>try 语句由三部分组成: </p><ul><li>try 包含为避免出现异常而被保护的代码</li><li>catch 是异常处理程序</li><li>finally 是在所有情况都会执行的代码块，不论有没有异常</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>有许多不同类型的异常可能在程序中发生。BCL 定义了许多异常类。当一个异常发生时，我们应: </p><ul><li>创建该类型的异常对象</li><li>在适当的 catch 子句处理</li></ul><p>所有的异常类都继承自 System.Exception。异常对象含有只读属性: </p><ul><li>Message: 包含异常原因</li><li>StackTrace: 调用栈</li></ul><h3 id="catch-子句"><a href="#catch-子句" class="headerlink" title="catch 子句"></a>catch 子句</h3><p>catch 子句有三种形式: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">catch</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//没有参数，匹配 try 中发生的任何异常</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionType</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//异常类型作为参数，匹配该类型的异常</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionType</span> Exp<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//特定异常对象作为参数，匹配该类型的异常，在代码块中可以使用异常对象</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="finally-子句"><a href="#finally-子句" class="headerlink" title="finally 子句"></a>finally 子句</h3><p>如果程序进入了一个带有 finally 块的 try 语句，那么 finally 块总会执行。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>我们可以使用 throw 语句显式触发一个异常，语法如下: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">throw</span> ExceptionObject<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>throw 还可以不带异常对象使用，只能用在 catch 块内部。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中的异常处理 —— try、catch、finially。&lt;/p&gt;
&lt;h3 id=&quot;什么是异常&quot;&gt;&lt;a href=&quot;#什么是异常&quot; class=&quot;headerlink&quot; title=&quot;什么是异常&quot;&gt;&lt;/a&gt;什么是异常&lt;/h3&gt;&lt;p&gt;异常是程序运行时错</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%B8%83)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%B8%83)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，介绍一些 C# 中的比较常见的预处理指令。</p><p>C 和 C++ 都有实际的预处理阶段，而在 C# 中是没有的，预处理指令是由编译器来处理。<br>在 Objective-C 中预处理指令也特别常用。</p><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>下面是预处理指令的主要规则: </p><ul><li>预处理指令必须与 C# 代码处于不同行</li><li>包含预处理指令的行必须以 # 开头<ol><li># 字符前可以有空格</li><li># 字符与预处理指令之间可以有空格</li></ol></li><li>允许行尾有单行注释，不可以有多行注释</li></ul><h3 id="define-和-undef-指令"><a href="#define-和-undef-指令" class="headerlink" title="#define 和 #undef 指令"></a>#define 和 #undef 指令</h3><p>编译符号是只有两种状态的标识符。要么被定义，要么未被定义。<br>编译符号有如下特性: </p><ul><li>可以是除了 true 和 false 之外的任何标识符，包括 C# 关键字，以及在 C# 中声明的标识符</li><li>他没有值，与 C 不同，他不表示字符串</li></ul><p>#define 指令声明一个编译符号，#undef 指令取消声明一个编译符号。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#<span class="token directive keyword">define</span> PremiumVersion</span><span class="token preprocessor property">#<span class="token directive keyword">define</span> EconomyVersion</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">undef</span> PremiumVersion</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: #define 和 #undef 指令只能用于任何 C# 代码之前，在 C# 代码开始之后，这两个指令就都不可以使用了。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> System<span class="token punctuation">;</span><span class="token preprocessor property">#<span class="token directive keyword">define</span> PremiumVersion    </span><span class="token comment" spellcheck="true">//错误，必须出现在所有 C# 代码之前</span><span class="token keyword">namespace</span> Eagle<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token preprocessor property">#<span class="token directive keyword">define</span> PremiumVersion    </span><span class="token comment" spellcheck="true">//错误</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重复定义编译符号也是允许的。</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>条件编译允许我们根据某个编译符号是否被定义来标注一段代码被编译或跳过。<br>有4个指令用来指定条件编译: </p><ul><li>#if</li><li>#else</li><li>#elif</li><li>#endif</li></ul><p>如下: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#<span class="token directive keyword">if</span> PremiumVersion</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span><span class="token preprocessor property">#<span class="token directive keyword">if</span> (PremiumVersion &amp;&amp; LeftHanded)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span><span class="token preprocessor property">#<span class="token directive keyword">if</span> true  </span><span class="token comment" spellcheck="true">//总被编译</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条件编译的结构"><a href="#条件编译的结构" class="headerlink" title="条件编译的结构"></a>条件编译的结构</h3><p>如下: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#<span class="token directive keyword">if</span> Cond1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">elif</span> Cond2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">elif</span> Cond3</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span><span class="token preprocessor property">#<span class="token directive keyword">if</span> Cond1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">else</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="诊断指令"><a href="#诊断指令" class="headerlink" title="诊断指令"></a>诊断指令</h3><p>下面是诊断指令的语法，注意与 C# 普通字符串不同，Message 无需引号包裹: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#<span class="token directive keyword">warning</span> Message</span><span class="token preprocessor property">#<span class="token directive keyword">error</span> Message</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="区域指令"><a href="#区域指令" class="headerlink" title="区域指令"></a>区域指令</h3><p>区域指令允许我们命名一段代码，#region 指令特性如下: </p><ul><li>放置在希望标注的代码段之上</li><li>在该指令后放置可选字符串作为名字</li><li>之后的代码由 #endregion 指令终止</li></ul><p>VisualStudio 可以显式和隐藏由区域指令包裹的代码段。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#<span class="token directive keyword">region</span> Constructor</span><span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">string</span> s<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pragma-warning"><a href="#pragma-warning" class="headerlink" title="#pragma warning"></a>#pragma warning</h3><p>该指令允许我们关闭和开启警告信息: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property">#<span class="token directive keyword">pragma</span> warning disable 618, 414</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token preprocessor property">#<span class="token directive keyword">pragma</span> warning restore 618</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，介绍一些 C# 中的比较常见的预处理指令。&lt;/p&gt;
&lt;p&gt;C 和 C++ 都有实际的预处理阶段，而在 C# 中是没有的，预处理指令是由编译器来处理。&lt;br&gt;在 Objective-C 中预处理指令也特别常用。&lt;/p&gt;
&lt;h3 id=&quot;基本规则&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E5%85%AB)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E5%85%AB)/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中非常重要的概念 —— 反射和特性。</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>很多程序语言中有元数据(matedata)的概念，其实元数据就是描述数据的数据。<br>一个运行的程序查看本身元数据或其他程序元数据的行为就叫做反射(reflection)。<br>要使用反射，我们必须引入 System.Reflection 命名空间。</p><h3 id="Type-类"><a href="#Type-类" class="headerlink" title="Type 类"></a>Type 类</h3><p>BCL 声明了一个 Type 的抽象类，他被设计用来包含类型的特性。使用这个类的对象可以让我们获得程序使用的类型信息。<br>我们需要了解的是: </p><ul><li>对于程序中的每一个类型，CLR 都会创建一个包含这个类型信息的 Type 类型的对象</li><li>程序中用到的每一个类型都会关联到独立的 Type 类型的实例</li><li>不管创建的类型有多少个实例，只有一个 Type 对象会关联到多有的这些实例</li></ul><p>我们可以从 Type 类型的实例获取几乎所有关于类型的信息，Type 类有很多有用的成员，如: </p><ul><li>Name 属性，返回类型名</li><li>NameSapce 属性，返回类型声明的命名空间</li><li>Assembly 属性，返回程序集</li><li>GetFields 方法，返回字段列表</li><li>GetProperties 方法，返回属性列表</li><li>GetMethods 方法，返回方法列表</li></ul><h3 id="获取-Type-对象的实例"><a href="#获取-Type-对象的实例" class="headerlink" title="获取 Type 对象的实例"></a>获取 Type 对象的实例</h3><p>我们可以使用 GetType 方法和 typeof 运算符获取 Type 对象。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> System<span class="token punctuation">.</span>Reflection<span class="token punctuation">;</span>Type t1 <span class="token operator">=</span> myInstance<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Type t2 <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token punctuation">(</span>DerivedClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>特性(attribute)是一种允许我们向程序集添加元数据的语言结构。<br>按照惯例，特性以 Pascal 命名法，并以 Attribute 为后缀命名。当应用特性时，可以不加 Attribute 后缀。<br>应用特性要被方括号包裹，其中是特性名和参数列表。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token punctuation">[</span>Serializable<span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token function">MyAttribute</span><span class="token punctuation">(</span><span class="token string">"Simple String"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyOtherClas</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="预定义特性"><a href="#预定义特性" class="headerlink" title="预定义特性"></a>预定义特性</h3><h4 id="Obsolete-特性"><a href="#Obsolete-特性" class="headerlink" title="Obsolete 特性"></a>Obsolete 特性</h4><p>我们可以使用 Obsolete 特性标注方法过期: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token function">Obsolete</span><span class="token punctuation">(</span><span class="token string">"Use Method SuperPrint"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们依旧可以使用过期方法，可以成功编译并执行，但是编译器会报警告。我们可以使用第二个布尔参数，使得编译错误。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token function">Obsolete</span><span class="token punctuation">(</span><span class="token string">"Use Method SuperPrint"</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//调用会发生编译错误</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Conditional-特性"><a href="#Conditional-特性" class="headerlink" title="Conditional 特性"></a>Conditional 特性</h4><p>Conditional 特性允许我们包含或排斥特定方法的所有调用。<br>如果定义了编译符号参数，则标记为 Conditional 特性的方法与普通方法一样，如果未定义编译符号，则所有的 Conditional 方法都不会调用: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token function">Conditional</span><span class="token punctuation">(</span><span class="token string">"DoTrace"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">TraceMessage</span><span class="token punctuation">(</span><span class="token keyword">string</span> str<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ASP.Net MVC 有很多重要的特性，我们会在学习 MVC 时再具体学习。</p><h3 id="其他特性相关"><a href="#其他特性相关" class="headerlink" title="其他特性相关"></a>其他特性相关</h3><p>我们可以为单个结构应用多个特性，可以使用多层结构，也可以使用逗号分隔: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token punctuation">[</span>Serializable<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">MyAttribute</span><span class="token punctuation">(</span><span class="token string">"Simple String"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>Serializable<span class="token punctuation">,</span> <span class="token function">MyAttribute</span><span class="token punctuation">(</span><span class="token string">"Simple String"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>除了类，特性还可以应用于字段，属性和方法等。</p><h3 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h3><p>所有的特性要派生自 System.Attribute。<br>要声明一个自定义特性: </p><ul><li>声明一个派生自 System.Attribute 的类</li><li>给他起一个 Attribute 后缀的名字</li><li>通常将该类声明为密封 sealed</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">MyAttribute</span> <span class="token punctuation">:</span> System<span class="token punctuation">.</span>Attribute<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意: 特性类的成员只能是: </p><ul><li>字段</li><li>属性</li><li>构造函数</li></ul><p>每个特性至少有一个公共构造函数。我们在应用特性传入参数列表时，其实是在使用不同的构造函数。<br>关于特性构造函数: </p><ul><li>应用特性时，构造函数的实参必须是在编译期可以确定的常量表达式</li><li>如果构造函数没有参数，可以省略圆括号</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中非常重要的概念 —— 反射和特性。&lt;/p&gt;
&lt;h3 id=&quot;元数据&quot;&gt;&lt;a href=&quot;#元数据&quot; class=&quot;headerlink&quot; title=&quot;元数据&quot;&gt;&lt;/a&gt;元数据&lt;/h3&gt;&lt;p&gt;很多程序语言中有元数据(matedata)的概念，其实元</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E8%81%8A%E8%81%8A%E6%9C%80%E8%BF%91%EF%BC%8C%E8%81%8A%E8%81%8A%E7%94%9F%E6%B4%BB/"/>
    <id>https://1ess.github.io/%E8%81%8A%E8%81%8A%E6%9C%80%E8%BF%91%EF%BC%8C%E8%81%8A%E8%81%8A%E7%94%9F%E6%B4%BB/</id>
    <published>2021-07-14T06:47:45.449Z</published>
    <updated>2021-07-14T06:47:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇聊聊最近的生活吧。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>最近好多之前离职的小伙伴希望我去他们的新公司去看看，可能的话可以去他们的公司工作，还是有些开心的，最起码是对我的认可。但还是因为各种原因婉拒了。</p><p>首先，就是最近过的有点忙，10.1 那天去办理新房入户，之后还要装修。<br>其二，希望在现在这个公司越干越好吧，入职已经两年多，有些不舍。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>生活中也完成了人生中的一件大事 —— 买房。在 2017 年 12 月 13 日贷款下来了，巧的是那一天正是我的生日。10 月 1 日这天房子也终于下来了，吃完午饭溜达着去办理新房入户。办理入户的时候才第一次进门看看，检查了一圈还算满意吧，虽然之前觉得不想背负这么大的压力，但第一次踏进属于自己的家门，还是有些不一样的感觉。之后匆匆赶回老家去参加老哥 10 月 3 号的婚礼，很圆满。可能自己 1 年之后也会结婚吧，不知道又会是什么样子。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>最近把 C# 基础知识详细复习完毕，之后会把精力先放在 ASP.Net Core MVC 上，学习一下最佳实践。现在 .Net Core 已经是 2.1 了，基础设施已经比较完善。<br>计划路线: </p><ul><li>ASP.Net MVC</li><li>ASP.Net API</li><li>ASP.Net Core</li></ul><p>还是决定把之前想好好学习的数据库知识先放一放，确实是个大工程，把 ASP.Net 搞的透彻一些再开始吧。<br>最后说一句，ReSharper 插件确实是个好东西，谁用谁知道！</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之前在京东云买了个服务器，又在腾讯云买的域名，最近想把个人网站好好搞搞，这个 ICP 备案真是中国特色。哎！</p><blockquote><p>最后我想说，几十年以后，或者几个世纪以后，回顾这段历史的时候，大家会觉得网站备案、GFW、绿坝软件、诸如此类的事情，都是好事，因为它们让许多中国青年认清了这个社会的本质，不再对旧制度抱有幻想，开始期盼新制度的到来，从而大大加快了社会变革的速度。要是没有它们，许多人也许要过许多年才会对现行制度产生怀疑，从而进行彻底的反思，新制度就会因此少了许多支持者。统治者越是凶恶，其实越表明他的恐慌和虚弱，而历史就像印度诗人泰戈尔所说，”总是在耐心地等待被侮辱和被压迫者的胜利”。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/other/other1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇聊聊最近的生活吧。&lt;/p&gt;
&lt;h3 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h3&gt;&lt;p&gt;最近好多之前离职的小伙伴希望我去他们的新公司去看看，可能的话可以去他们的公司工作，还是有些开心的，最</summary>
      
    
    
    
    
  </entry>
  
</feed>
