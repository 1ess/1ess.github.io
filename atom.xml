<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Sort Of A Blog</title>
  
  
  <link href="https://1ess.github.io/atom.xml" rel="self"/>
  
  <link href="https://1ess.github.io/"/>
  <updated>2022-02-14T09:21:29.045Z</updated>
  <id>https://1ess.github.io/</id>
  
  <author>
    <name>Stephen Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-装饰器</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2022-02-22T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;装饰器模式(Decorator Pattern)是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-组合</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88/</id>
    <published>2022-02-21T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;组合模式(Composite Pattern)是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-桥接</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5/</id>
    <published>2022-02-20T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;桥接模式(Bridge Pattern)是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-适配器</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/</id>
    <published>2022-02-19T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;适配器模式(Adapter Pattern)是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-单例</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/</id>
    <published>2022-02-18T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;单例模式(Singleton Pattern)是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-原型</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B/</id>
    <published>2022-02-17T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;原型模式(Prototype Pattern)是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-生成器</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2022-02-16T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;生成器模式(Builder Pattern)是一种创建型设计模式，使你能够&lt;strong&gt;分步骤创建复杂对象&lt;/strong&gt;。该模式允许你&lt;strong&gt;使用相同的创建代码生成不同类型和形式&lt;/strong&gt;的对象。&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-抽象工厂</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</id>
    <published>2022-02-15T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;抽象工厂模式(Abstract Factory Pattern)是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。&lt;/p&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-工厂方法</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</id>
    <published>2022-02-14T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;创建型模式是为了绕开 new 来避免对象创建过程中所导致的紧耦合(依赖具体类)，从而支持对象创建的稳定。他是接口抽象之后的第一步工作。&lt;/p&gt;
&lt;p&gt;工厂方法模式(Factory Method</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-概述</title>
    <link href="https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/"/>
    <id>https://1ess.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/</id>
    <published>2022-02-13T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;设计模式是软件设计中常见问题的典型解决方案。设计模式与方法或库的使用方式不同，你很难直接在自己的程序中套用某个设计模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模式并不是一段特定的代码，而是解决特定问题的一般性概念。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以根据模式来实现符合自己程序</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Synchronous and Asynchronous Blocking and Non-Blocking</title>
    <link href="https://1ess.github.io/Synchronous%20and%20Asynchronous%20Blocking%20and%20Non-Blocking/"/>
    <id>https://1ess.github.io/Synchronous%20and%20Asynchronous%20Blocking%20and%20Non-Blocking/</id>
    <published>2022-02-12T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;概念解释&quot;&gt;&lt;a href=&quot;#概念解释&quot; class=&quot;headerlink&quot; title=&quot;概念解释&quot;&gt;&lt;/a&gt;概念解释&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在软件开发中，这两对概念是非常容易搞混的。我们再此给其做一个明确的解释，用以区分:</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL 经典练习题</title>
    <link href="https://1ess.github.io/SQL%20%E7%BB%8F%E5%85%B8%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://1ess.github.io/SQL%20%E7%BB%8F%E5%85%B8%E7%BB%83%E4%B9%A0%E9%A2%98/</id>
    <published>2022-02-10T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;数据准备&quot;&gt;&lt;a href=&quot;#数据准备&quot; class=&quot;headerlink&quot; title=&quot;数据准备&quot;&gt;&lt;/a&gt;数据准备&lt;/h3&gt;&lt;p&gt;1.学生表&lt;br&gt;2.课程表&lt;br&gt;3.教师表&lt;br&gt;4.成绩表&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『数据密集型应用系统设计』读书笔记(十一)</title>
    <link href="https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)/"/>
    <id>https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)/</id>
    <published>2022-02-05T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;上一章讨论了批处理技术，它是读取一组文件作为输入并生成一组新的输出文件的技术，其中始终存在一个重要的假设即&lt;strong&gt;输入是有界的&lt;/strong&gt;。而本章中，我们将转向流处理，其中输入是无界的。也就是说，作业的输入是永无止境的数据流。&lt;/p&gt;
&lt;h2</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『数据密集型应用系统设计』读书笔记(十)</title>
    <link href="https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%8D%81)/"/>
    <id>https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%8D%81)/</id>
    <published>2022-02-04T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Web 和越来越多基于 HTTP/REST 的 API 使得请求/响应的交互模式变得普遍，但是这并不是系统的唯一类型。存在三种不同类型的系统: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在线服务(在线系统):</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『数据密集型应用系统设计』读书笔记(九)</title>
    <link href="https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B9%9D)/"/>
    <id>https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B9%9D)/</id>
    <published>2022-02-03T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;本章我们将讨论构建容错式分布式系统的相关算法和协议。为了构建容错系统，最好先建立一套通用的抽象机制和与之对应的技术保证，这样只需实现一次，其上的各种应用程序都可以安全地信赖底层的保证。&lt;/p&gt;
&lt;p&gt;分布式系统最重要的抽象之一就是&lt;strong&gt;共识&lt;/strong&gt;，也就</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『数据密集型应用系统设计』读书笔记(八)</title>
    <link href="https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%85%AB)/"/>
    <id>https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%85%AB)/</id>
    <published>2022-02-02T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.045Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;分布式系统与在单节点上的软件有着非常显著的区别，你会碰到五花八门、千奇百怪的问题所导致的各种故障。本章我们将了解这些实践中所出现的问题，充分认识眼前的挑战。&lt;/p&gt;
&lt;p&gt;作为开发者，我们的核心任务是&lt;strong&gt;构建可靠的系统&lt;/strong&gt;，即使系统面临各种出错可能</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『数据密集型应用系统设计』读书笔记(七)</title>
    <link href="https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%83)/"/>
    <id>https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%83)/</id>
    <published>2022-01-30T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.041Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在一个苛刻的数据存储环境中，会有许多可能出错的情况:</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『数据密集型应用系统设计』读书笔记(六)</title>
    <link href="https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%85%AD)/"/>
    <id>https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%85%AD)/</id>
    <published>2022-01-28T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.041Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前一章我们讨论了复制技术，即在不同节点上保存相同数据的多个副本。然而，面对一些海量数据集或非常高的查询压力，复制技术还不够，我们还需要将数据拆分成为&lt;strong&gt;分区&lt;/strong&gt;(也称为分片)。&lt;/p&gt;
&lt;p&gt;注意: 关于分区，在不同系统有不同称呼。例如</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『数据密集型应用系统设计』读书笔记(五)</title>
    <link href="https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%94)/"/>
    <id>https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%94)/</id>
    <published>2021-12-26T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.041Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在前面几章，我们讨论了数据系统的各个方面，但仅限于数据存储在单台机器上的情况。现在我们进入更高的层次，在接下来的几章讨论将数据库分布到多台机器的情况。&lt;/p&gt;
&lt;h2 id=&quot;复制&quot;&gt;&lt;a href=&quot;#复制&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『数据密集型应用系统设计』读书笔记(四)</title>
    <link href="https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>https://1ess.github.io/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E5%9B%9B)/</id>
    <published>2021-12-20T00:00:00.000Z</published>
    <updated>2022-02-14T09:21:29.041Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;编码与演化&quot;&gt;&lt;a href=&quot;#编码与演化&quot; class=&quot;headerlink&quot; title=&quot;编码与演化&quot;&gt;&lt;/a&gt;编码与演化&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在大多数情况下，修改应用程序的功能也意味着需要更改其存储的数据:</summary>
        
      
    
    
    
    
  </entry>
  
</feed>
