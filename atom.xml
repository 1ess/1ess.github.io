<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Sort Of A Blog</title>
  
  
  <link href="https://1ess.github.io/atom.xml" rel="self"/>
  
  <link href="https://1ess.github.io/"/>
  <updated>2021-07-14T12:51:57.447Z</updated>
  <id>https://1ess.github.io/</id>
  
  <author>
    <name>Stephen Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%85%AD)/"/>
    <id>https://1ess.github.io/C#(%E5%85%AD)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，讲讲 C# 中的结构体类型和枚举类型。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><hr><p>结构与类类似，都是用户定义类型，都有数据成员和函数成员，但有两个最大的区别: </p><ul><li>类是引用类型而结构是值类型</li><li>结构是隐式密封的</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">strcut StructName<br>&#123;<br>    MemberDeclarations;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="结构是值类型"><a href="#结构是值类型" class="headerlink" title="结构是值类型"></a>结构是值类型</h3><p>因此: </p><ul><li>结构类型的变量不能为 null</li><li>两个结构不能引用同一对象</li></ul><p>把一个结构赋值给另一个结构，就是将这个结构的值复制给另一个结构。需要注意与类的赋值的不同。</p><p>结构允许有实例构造函数和静态构造函数，但不允许有析构函数。</p><p>与类一样，编译器隐式的为结构提供一个无参构造，这个构造将每个成员设置为该类型的默认值。与类不同的是，这个无参构造函数不能被重定义，我们只能创建另外的有参构造，而不能重写无参构造，并且我们提供了有参构造，编译器提供给我们的无参构造依然存在。</p><p>我们也用 new 操作符调用构造函数，即使不从堆中分配内存。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Point p = <span class="hljs-keyword">new</span> Point();<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Point p = <span class="hljs-keyword">new</span> Point();<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们也可以不使用构造来创建结构的实例，但有一些限制: </p><ul><li>显式设置数据成员之后，才可以使用这些成员的值</li><li>对所有的数据成员赋值之后，才能调用任何函数成员</li></ul><p>结构的字段是不允许有初始化语句的。</p><p>之前说了，结构是隐式密封的，因此 protected，internal，abstruct，virtual 修饰符不可使用。</p><p>与 Swift 类似，C# 中的简单预定义类型在实现方式上是使用结构类型。所以可以调用一些方法，如: 所有类型都有的 GetType 方法。<br>另外说一句: JavaScript 中的简单类型如 string 也可以调用方法，他们是在使用值时被临时包装成一个对象。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><hr><p>枚举只有一个类型的成员: 命名的整数值常量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-built_in">enum</span> TrafficLight<br>&#123;<br>    Yellow,<br>    Green,<br>    Red<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>枚举的底层都是一个整数类型，默认是 int。<br>默认情况编译器把第一个值赋值为 0，之后的成员加 1。<br>我们把枚举值赋值成枚举对象: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    TrafficLight yellow = TrafficLight.Yellow;<br>    Console.WriteLine(yellow);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    TrafficLight yellow = TrafficLight.Yellow;<br>    Console.WriteLine(yellow);  <span class="hljs-comment">//Yellow 打印成员名</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们也可以显式的设置每个枚举成员的值和类型: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">enum</span> TrafficLight: <span class="hljs-built_in">uint</span><br>&#123;<br>    Yellow = <span class="hljs-number">15</span>,<br>    Green =  <span class="hljs-number">20</span>,<br>    Red = <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">enum</span> TrafficLight: <span class="hljs-built_in">uint</span><br>&#123;<br>    Yellow = <span class="hljs-number">15</span>,<br>    Green =  <span class="hljs-number">20</span>,<br>    Red = <span class="hljs-number">20</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="位标记"><a href="#位标记" class="headerlink" title="位标记"></a>位标记</h3><p>我们使用 Flags 特性实现位标记: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">Flags</span>]<br><span class="hljs-built_in">enum</span> Setting : <span class="hljs-built_in">uint</span><br>&#123;<br>    A = <span class="hljs-number">0x0001</span>,<br>    B = <span class="hljs-number">0x0010</span>,<br>    C = <span class="hljs-number">0x0100</span>,<br>    D = <span class="hljs-number">0x1000</span><br>&#125;<br><br>Setting opts = Setting.A | Setting.B | Setting.C;<br>opts.HasFlags(Setting.D);  <span class="hljs-comment"><code class="language-hljs csharp">[<span class="hljs-meta">Flags</span>]<br><span class="hljs-built_in">enum</span> Setting : <span class="hljs-built_in">uint</span><br>&#123;<br>    A = <span class="hljs-number">0x0001</span>,<br>    B = <span class="hljs-number">0x0010</span>,<br>    C = <span class="hljs-number">0x0100</span>,<br>    D = <span class="hljs-number">0x1000</span><br>&#125;<br><br>Setting opts = Setting.A | Setting.B | Setting.C;<br>opts.HasFlags(Setting.D);  <span class="hljs-comment">//false</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>C# 中的枚举与 Objective-C 的实现 NS_ENUM 和 NS_OPTIONS 类似。</p><p>注意: 枚举是一个独特的类型，比较不同类型的枚举对象会导致编译错误，即使他们的底层都是整数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，讲讲 C# 中的结构体类型和枚举类型。&lt;/p&gt;
&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;结构与类类似，都是用户定义类型，都有数据成员和函数成员，但有两个最大</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%B8%83)/"/>
    <id>https://1ess.github.io/C#(%E4%B8%83)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中的数组对象及其协变概念。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>数组是由变量名表示的一组同类型的数据元素，每个元素可以通过索引来访问。</p><p>C# 数组的特点: </p><ul><li>C# 不支持动态数组，也就是数组一旦创建，就不可以更改大小</li><li>索引从 0 开始</li></ul><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>C# 支持一维数组和多维数组，多维数组又分为矩形数组和交错数组。</p><h3 id="数组是对象"><a href="#数组是对象" class="headerlink" title="数组是对象"></a>数组是对象</h3><p>数组实例是从 System.Array 继承来的对象，继承了很多属性和方法: </p><ul><li>Rank 属性，返回数组的维数</li><li>Length 属性，返回数组的长度</li></ul><p>注意: 数组是引用类型，数组元素可以是值类型也可以是引用类型，这一点与 Ocjective-C 不同，Ocjective-C 中的数组元素不能是基本类型。</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>我们可以在类型和变量名之间加中括号来声明一维数组: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-built_in">long</span>[] array;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>要实例化一维数组，我们使用数组创建表达式，使用 new 操作符，后跟基类名称和中括号，中括号里要有数组长度: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>要访问数组元素，要使用索引: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br>array[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> intVal = array[<span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br>array[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> intVal = array[<span class="hljs-number">2</span>];<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>当数组创建后，每个元素会自动初始化默认值: </p><ul><li>整型: 0</li><li>浮点数: 0.0</li><li>布尔型: false</li><li>对象: null</li></ul><p>我们还可以使用初始化列表显式初始化数组元素: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>当在一条语句声明并初始化数组时，可以使用快捷语法: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们可以使用 foreach 语句遍历数组元素: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array) <br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> array) <br>&#123;<br>    <span class="hljs-comment">//...item</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="数组的协变"><a href="#数组的协变" class="headerlink" title="数组的协变"></a>数组的协变</h3><p>协变和逆变我们之后说泛型的时候会细讲，这里我们只是提一下数组中的协变。<br>协变是指: 即使某个对象不是数组的基类型，我们也可以把他赋值给数组元素。以下情况可以使用数组协变: </p><ul><li>数组是引用类型数组</li><li>赋值类型和数组基类类型存在显式或隐式转换</li></ul><p>由于基类和派生类总存在隐式转换，因此我们可以把派生类对象赋值给基类型数组元素: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        A[] array = <span class="hljs-keyword">new</span> A[<span class="hljs-number">3</span>];<br>        A[<span class="hljs-number">0</span>] = <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        A[] array = <span class="hljs-keyword">new</span> A[<span class="hljs-number">3</span>];<br>        A[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> B();<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中的数组对象及其协变概念。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;数组是由变量名表示的一组同类型的数据元素，每个元素可以通过索引来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%85%AB)/"/>
    <id>https://1ess.github.io/C#(%E5%85%AB)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中特殊的委托(delegate)。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>委托和类一样，都是用户定义类型。类表示数据和方法的集和，而委托则是持有一个或多个方法，以及一系列预定义操作。</p><p>我们通过以下步骤来使用委托: </p><ul><li>声明一个委托，委托的声明看上去和方法声明类似，只是没有实现块</li><li>使用委托类型声明一个委托变量</li><li>创建委托类型的变量，赋值为委托变量，这个委托类型变量指向方法的引用，这个方法和委托定义的签名和返回值类型一样</li><li>可以为委托对象增加其他方法</li><li>可以像调用方法一样调用委托，调用委托时，其包含的每一个方法都会被执行</li></ul><h3 id="声明委托"><a href="#声明委托" class="headerlink" title="声明委托"></a>声明委托</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"><span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="创建委托对象"><a href="#创建委托对象" class="headerlink" title="创建委托对象"></a>创建委托对象</h3><p>有两种方式创建委托对象: </p><ul><li>第一种是使用 new 操作符的创建表达式，参数是调用列表第一个方法的名字</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">delVal = <span class="hljs-keyword">new</span> MyDel(instance.MyM1);  <span class="hljs-comment">//实例方法</span><br>dVal = <span class="hljs-keyword">new</span> MyDel(SClass.OtherM2);  <span class="hljs-comment"><code class="language-hljs csharp">delVal = <span class="hljs-keyword">new</span> MyDel(instance.MyM1);  <span class="hljs-comment">//实例方法</span><br>dVal = <span class="hljs-keyword">new</span> MyDel(SClass.OtherM2);  <span class="hljs-comment">//静态方法</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>我们还可以使用快捷语法，直接赋值为方法名即可</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">delVal = instance.MyM1;<br>dVal = SClass.OtherM2;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="为委托增加方法"><a href="#为委托增加方法" class="headerlink" title="为委托增加方法"></a>为委托增加方法</h3><p>我们使用 += 操作符为委托增加方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">MyDel  del = inst.M1;<br>del += SCl.M3;<br>del += X.Act;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>同样使用 -= 从委托移除方法。</p><h3 id="调用委托"><a href="#调用委托" class="headerlink" title="调用委托"></a>调用委托</h3><p>我们可以像调用方法一样调用委托: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">MyDel  del = inst.M1;<br>del += SCl.M3;<br>del += X.Act;<br><span class="hljs-comment">//...</span><br>del(<span class="hljs-number"><code class="language-hljs csharp">MyDel  del = inst.M1;<br>del += SCl.M3;<br>del += X.Act;<br><span class="hljs-comment">//...</span><br>del(<span class="hljs-number">444</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="调用带有返回值的委托"><a href="#调用带有返回值的委托" class="headerlink" title="调用带有返回值的委托"></a>调用带有返回值的委托</h3><ul><li>调用列表最后一个方法返回的值就是委托返回值</li><li>调用列表的其他方法返回值将被忽略</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"></span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IntVal = <span class="hljs-number">5</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add2</span>(<span class="hljs-params"></span>)</span> &#123; IntVal += <span class="hljs-number">2</span>; <span class="hljs-keyword">return</span> IntVal; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add3</span>(<span class="hljs-params"></span>)</span> &#123; IntVal += <span class="hljs-number">3</span>; <span class="hljs-keyword">return</span> IntVal; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyCls cls = <span class="hljs-keyword">new</span> MyCls();<br>        MyDel del = <span class="hljs-keyword">new</span> MyDel(cls.Add2);<br>        del += cls.Add3;<br>        del += cls.Add2;<br><br>        Console.WriteLine(del());  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"></span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IntVal = <span class="hljs-number">5</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add2</span>(<span class="hljs-params"></span>)</span> &#123; IntVal += <span class="hljs-number">2</span>; <span class="hljs-keyword">return</span> IntVal; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add3</span>(<span class="hljs-params"></span>)</span> &#123; IntVal += <span class="hljs-number">3</span>; <span class="hljs-keyword">return</span> IntVal; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyCls cls = <span class="hljs-keyword">new</span> MyCls();<br>        MyDel del = <span class="hljs-keyword">new</span> MyDel(cls.Add2);<br>        del += cls.Add3;<br>        del += cls.Add2;<br><br>        Console.WriteLine(del());  <span class="hljs-comment">//12</span><br>    &#123;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="调用带引用参数的委托"><a href="#调用带引用参数的委托" class="headerlink" title="调用带引用参数的委托"></a>调用带引用参数的委托</h3><p>再调用方法列表的下一个方法时，参数的新值会传给下一个方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add2</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; x += <span class="hljs-number">2</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add3</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; x += <span class="hljs-number">3</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyCls cls = <span class="hljs-keyword">new</span> MyCls();<br>        MyDel del = <span class="hljs-keyword">new</span> MyDel(cls.Add2);<br>        del += cls.Add3;<br>        del += cls.Add2;<br><br>        <span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>;<br>        del(<span class="hljs-keyword">ref</span> x);<br>        Console.WriteLine(x);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDel</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add2</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; x += <span class="hljs-number">2</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add3</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; x += <span class="hljs-number">3</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        MyCls cls = <span class="hljs-keyword">new</span> MyCls();<br>        MyDel del = <span class="hljs-keyword">new</span> MyDel(cls.Add2);<br>        del += cls.Add3;<br>        del += cls.Add2;<br><br>        <span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>;<br>        del(<span class="hljs-keyword">ref</span> x);<br>        Console.WriteLine(x);  <span class="hljs-comment">//12</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>我们可以使用 Lambda 表达式创建委托对象。<br>C# 中的 Lambda 表达式与 JavaScript 中的很像。如果只有一个参数，可以省略括号，如果只有一个返回值语句，可以省略大括号和 reuturn 关键字。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">MyDel del = (<span class="hljs-built_in">int</span> x) =&gt; &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-comment">//简写形式</span><br>MyDel del = x =&gt; x + <span class="hljs-number"><code class="language-hljs csharp">MyDel del = (<span class="hljs-built_in">int</span> x) =&gt; &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-comment">//简写形式</span><br>MyDel del = x =&gt; x + <span class="hljs-number">1</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中特殊的委托(delegate)。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;委托和类一样，都是用户定义类型。类表示数据和方法的集和，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E4%B9%9D)/"/>
    <id>https://1ess.github.io/C#(%E4%B9%9D)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>前几篇，我们都在讲类型，这一篇，我们来说说事件成员。</p><h2 id="发布者和订阅者"><a href="#发布者和订阅者" class="headerlink" title="发布者和订阅者"></a>发布者和订阅者</h2><hr><p>很多程序都会有一个需求: 当一个特定事件发生时，程序的其他部分可以得到这个事件发生的通知。<br>发布者/订阅者模式可以满足这个需求:<br>发布者定义了一系列事件，其他类可以注册某些事件，以便在事件发生时，订阅者可以收到通知响应事件。订阅者注册事件时提供的方法称为回调函数或者事件处理程序。</p><p>在 Objective-C 中，我们可以在某些类 addObserver 注册一些事件处理程序，当事件发生时，pushNotifacitation。在 JavaScript 中，我们同样可以 addEventListener 注册一些事件处理程序。</p><p>发布者: 发布某个事件的类或结构<br>订阅者: 注册并在事件发生时得到通知执行事件处理程序的类或结构<br>事件处理程序: 当事件发生时执行的回调函数</p><p><strong>事件包含了一个私有委托</strong>。<br>关于事件的私有委托: </p><ul><li>事件提供了对他的私有委托的结构化访问，我们无法直接访问私有委托</li><li>对于事件，我们只可以添加，删除和调用事件处理程序</li><li>事件触发时，会依次调用调用列表的方法</li></ul><h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><hr><p>发布者类必须提供事件对象。声明事件需要委托类型和事件名: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-comment">//声明事件: event 关键字，EventHandler 委托类型，CountedADozen 事件名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span><br>&#123;<br>    <span class="hljs-comment">//声明事件: event 关键字，EventHandler 委托类型，CountedADozen 事件名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler CountedADozen;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 事件是成员而不是类型，由于他是成员: </p><ul><li>我们不能在可执行代码中声明事件</li><li>必须声明在类或结构中</li><li>声明事件需要委托类型，我们可以声明一个委托或使用已存在的。</li></ul><p>BCL 声明了一个 EventHandler 的委托，专门处理系统事件。</p><h2 id="订阅事件"><a href="#订阅事件" class="headerlink" title="订阅事件"></a>订阅事件</h2><hr><p>订阅者向事件添加处理程序: </p><ul><li>使用 += 运算符为事件添加事件处理程序</li><li>事件处理程序可以是: <ol><li>实例方法名称</li><li>静态方法名称</li><li>匿名方法</li><li>Lambda 表达式</li></ol></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">cls.CountedADozen += IncreatmentCountedADozen;<br>cls.CountedADozen += ClassB.CountedHandlerB;<br>cls.CountedADozen += () => DozensCount ++;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><hr><p>触发事件时要注意: </p><ul><li>触发前要与 null 比较，如果是 null，则不能执行</li><li>触发事件的语法与调用方法一样</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几篇，我们都在讲类型，这一篇，我们来说说事件成员。&lt;/p&gt;
&lt;h2 id=&quot;发布者和订阅者&quot;&gt;&lt;a href=&quot;#发布者和订阅者&quot; class=&quot;headerlink&quot; title=&quot;发布者和订阅者&quot;&gt;&lt;/a&gt;发布者和订阅者&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;很多程序都会有一个需求</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们再回来说说最后一种类型: 接口(interface)。</p><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>接口是指定一组函数成员而不实现他们的引用类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IInfo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetName</span>(<span class="hljs-params"></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetAge</span>(<span class="hljs-params"><code class="language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IInfo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetName</span>(<span class="hljs-params"></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetAge</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们可以用类或结构来实现接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span>: <span class="hljs-title">IComparable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TheValue;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  <span class="hljs-title">CompareTo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>    &#123;<br>        MyCls cls = (MyCls)obj;<br>        <span class="hljs-keyword">if</span> (TheValue &gt; cls.TheValue) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (TheValue &lt; cls.TheValue) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCls</span>: <span class="hljs-title">IComparable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TheValue;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  <span class="hljs-title">CompareTo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>    &#123;<br>        MyCls cls = (MyCls)obj;<br>        <span class="hljs-keyword">if</span> (TheValue &gt; cls.TheValue) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (TheValue &lt; cls.TheValue) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h3><ul><li><p>接口声明不能包含数据成员和静态成员</p></li><li><p>接口只能包含如下非静态成员: </p><ol><li>方法</li><li>属性</li><li>事件</li><li>索引器</li></ol></li><li><p>接口应该以大写字母 I 开始</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-comment">//注意: 接口函数成员不能有访问修饰符</span><br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"><span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-comment">//注意: 接口函数成员不能有访问修饰符</span><br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> val</span>)</span>;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>要实现接口: </p><ul><li>与继承类似，类或结构后跟冒号，再跟接口名</li><li>为每一个接口成员提供实现</li></ul><p>注意: 如果有继承，并实现接口，基类名必须出现在接口之前: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IIfc1</span>, <span class="hljs-title">IIfc2</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IIfc1</span>, <span class="hljs-title">IIfc2</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><ul><li>类或结构可以实现任意数量的接口</li><li>所有实现的接口，必须列在基类列表以逗号分隔</li></ul><h3 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h3><p>与类的继承不同，接口可以多继承。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IData</span> : <span class="hljs-title">IDataR</span>, <span class="hljs-title">IDataS</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IData</span> : <span class="hljs-title">IDataR</span>, <span class="hljs-title">IDataS</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们再回来说说最后一种类型: 接口(interface)。&lt;/p&gt;
&lt;h3 id=&quot;什么是接口&quot;&gt;&lt;a href=&quot;#什么是接口&quot; class=&quot;headerlink&quot; title=&quot;什么是接口&quot;&gt;&lt;/a&gt;什么是接口&lt;/h3&gt;&lt;p&gt;接口是指定一组函数成员而不实现他们</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%B8%80)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%B8%80)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们再来看看 C# 中的显式转换以及隐式转换。</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>有些类型的转换不会丢失数据或精度: </p><ul><li>C# 会自动做这些转换，称为隐式转换</li><li>从位数少的源转换为位数更多的源，目标多出来的位使用 0 或 1 补充</li><li>当从小的无符号类型转换为更大的无符号类型，多出来的位以 0 进行填充，称为 0 扩展</li><li>对于有符号类型，额外的高位使用符号位进行扩展，称为符号扩展</li></ul><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>对于源类型的任意值在被转换为目标类型时会丢失的情况，C# 语言是不提供两种类型的自动转换，如果我们希望这两种类型进行转换，就必须使用显式转换，这叫做强制转换表达式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">ushort</span> var1 = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">sbyte</span> var2 = (<span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-built_in">ushort</span> var1 = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">sbyte</span> var2 = (<span class="hljs-built_in">sbyte</span>)var1;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>C# 所有类型都继承自 object 类型，然而，值类型是高效轻量的类型，但是当我们需要对象组件，可以使用装箱。<br>装箱是一种隐式转换，接受值类型的值，在堆上创建一个引用类型对象，返回该引用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">object</span> oi = <span class="hljs-literal"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">object</span> oi = <span class="hljs-literal">null</span>;<br>oi = i;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>需要注意的是: 装箱操作的时一个副本，装箱之后，原始值和引用副本可以独立操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">object</span> oi = i;<br>Console.WriteLine(<span class="hljs-string">&quot;i: &#123;0&#125;, oi: &#123;1&#125;&quot;</span>, i, oi); <span class="hljs-comment">// 10, 10</span><br><br>i = <span class="hljs-number">12</span>;<br>oi = <span class="hljs-number">15</span>;<br>Console.WriteLine(<span class="hljs-string">&quot;i: &#123;0&#125;, oi: &#123;1&#125;&quot;</span>, i, oi); <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">object</span> oi = i;<br>Console.WriteLine(<span class="hljs-string">&quot;i: &#123;0&#125;, oi: &#123;1&#125;&quot;</span>, i, oi); <span class="hljs-comment">// 10, 10</span><br><br>i = <span class="hljs-number">12</span>;<br>oi = <span class="hljs-number">15</span>;<br>Console.WriteLine(<span class="hljs-string">&quot;i: &#123;0&#125;, oi: &#123;1&#125;&quot;</span>, i, oi); <span class="hljs-comment">// 12, 15</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h3><p>拆箱是将装箱后的引用返回值类型的操作。<br>注意: 拆箱是显式转换。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">object</span> oi = i;<br><br><span class="hljs-built_in">int</span> j = (<span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">object</span> oi = i;<br><br><span class="hljs-built_in">int</span> j = (<span class="hljs-built_in">int</span>)oi;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>拆箱非值类型会抛出异常。</p><h3 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h3><p>我们可以使用 is 运算符检测转换是否会成功，避免盲目转换。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;1ess&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Employee emp = <span class="hljs-keyword">new</span> Employee();<br>        <span class="hljs-keyword">if</span> (emp <span class="hljs-keyword">is</span> Person p) &#123;<br>            <span class="hljs-comment">//如果转换失败，返回 false</span><br>            <span class="hljs-comment">//如果转换成功，返回 true，并赋值给 p</span><br>            <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;1ess&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Employee emp = <span class="hljs-keyword">new</span> Employee();<br>        <span class="hljs-keyword">if</span> (emp <span class="hljs-keyword">is</span> Person p) &#123;<br>            <span class="hljs-comment">//如果转换失败，返回 false</span><br>            <span class="hljs-comment">//如果转换成功，返回 true，并赋值给 p</span><br>            <span class="hljs-comment">//...</span><br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="as-运算符"><a href="#as-运算符" class="headerlink" title="as 运算符"></a>as 运算符</h3><p>as 运算符和强制转换类似，只是他不会抛出异常。如果转换失败，会返回 null。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;1ess&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Employee emp = <span class="hljs-keyword">new</span> Employee();<br>        Person p = emp <span class="hljs-keyword">as</span> Person;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> : <span class="hljs-title">Person</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name = <span class="hljs-string">&quot;1ess&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Employee emp = <span class="hljs-keyword">new</span> Employee();<br>        Person p = emp <span class="hljs-keyword">as</span> Person;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//...</span><br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们再来看看 C# 中的显式转换以及隐式转换。&lt;/p&gt;
&lt;h3 id=&quot;隐式转换&quot;&gt;&lt;a href=&quot;#隐式转换&quot; class=&quot;headerlink&quot; title=&quot;隐式转换&quot;&gt;&lt;/a&gt;隐式转换&lt;/h3&gt;&lt;p&gt;有些类型的转换不会丢失数据或精度: &lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%BA%8C)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%BA%8C)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>理想有两种: 一种，我实现了我的理想；另一种: 理想通过我而实现。</p></blockquote><p>这一篇，讲讲泛型。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>没有泛型的时候，我们封装的行为都是作用在特定类型上的，但是，很多时候如果我们把行为提取或重构出来，使其可以应用到很多类型上去的话，那么就会更有意义。这也是泛型出现的原因。</p><p>我们可以额外增加一层抽象，这样类型就不用再硬编码了，这样就可以使得多段代码在不同类型执行相同的指令成为可能。</p><p>之前写 Objective-C 的时候，感觉他的泛型太弱了，现在写 C#，感觉他的泛型系统太好用了！</p><h3 id="无泛型栈示例"><a href="#无泛型栈示例" class="headerlink" title="无泛型栈示例"></a>无泛型栈示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIntStack</span><br>&#123;<br>    <span class="hljs-built_in">int</span> StackPoint = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span>[] StackArray;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIntStack</span><br>&#123;<br>    <span class="hljs-built_in">int</span> StackPoint = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span>[] StackArray;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果希望将相同的功能应用于 float 类型，我们就必须复制粘贴上面的代码再改成 float。<br>这样做可行，但是缺点明显: </p><ul><li>我们要仔细检查类型的修改</li><li>每当新增类型，就要复制粘贴修改</li><li>调试维护这些类似的代码易出错</li></ul><h3 id="C-中的泛型"><a href="#C-中的泛型" class="headerlink" title="C# 中的泛型"></a>C# 中的泛型</h3><p>泛型(generic)提供了更优雅的解决方案，让多个类型共享一组代码。我们可以使用类型占位符书写代码，在创建实例时指明实际类型即可。</p><p>C# 提供了 5 种泛型可用在的地方: 类、结构、接口、委托、方法。前四种是类型，最后一种是成员。</p><h3 id="泛型栈示例"><a href="#泛型栈示例" class="headerlink" title="泛型栈示例"></a>泛型栈示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-built_in">int</span> StackPointer = <span class="hljs-number">0</span>;<br>    T[] StackArray;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params">T x</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-built_in">int</span> StackPointer = <span class="hljs-number">0</span>;<br>    T[] StackArray;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params">T x</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="声明泛型类"><a href="#声明泛型类" class="headerlink" title="声明泛型类"></a>声明泛型类</h3><p>上面我们已经展示了一个示例来演示泛型类，这里我们具体介绍一下，看看如何创建并使用泛型类。<br>创建使用非泛型类有两步: 声明类和创建类的实例。<br>但是泛型类不是实际类，而是类的模板，所以我们必须先从模板构建出实际类型，然后创建这个构建后的类型的实例。</p><p>声明步骤: </p><ul><li>在类名后放置一对尖括号&lt;&gt;</li><li>在尖括号中用逗号分隔占位字符串来表示希望提供的类型，这叫做类型参数(type parameters)</li><li>在泛型类的主体使用类型参数代替实际类型</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> &lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T1 SomeVal = <span class="hljs-keyword">new</span> T1();<br>    <span class="hljs-keyword">public</span> T2 OtherVal = <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> &lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T1 SomeVal = <span class="hljs-keyword">new</span> T1();<br>    <span class="hljs-keyword">public</span> T2 OtherVal = <span class="hljs-keyword">new</span> T2();<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="创建构造类型"><a href="#创建构造类型" class="headerlink" title="创建构造类型"></a>创建构造类型</h3><p>列出类名并在尖括号中提供真实类型代替类型参数，我们将替代类型参数的真实类型称为类型实参(type argument)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in"><code class="language-hljs csharp">SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>非泛型类创建实例: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">MyNonGenClass myNGC = <span class="hljs-keyword"><code class="language-hljs csharp">MyNonGenClass myNGC = <span class="hljs-keyword">new</span> MyNonGenClass();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>泛型类创建实例: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>&gt; mySc1 = <span class="hljs-keyword">new</span> SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in"><code class="language-hljs csharp">SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>&gt; mySc1 = <span class="hljs-keyword">new</span> SomeClass&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>>();<br><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="类型参数约束"><a href="#类型参数约束" class="headerlink" title="类型参数约束"></a>类型参数约束</h3><p>为了让泛型变得更有用，我们需要提供额外信息让编译器知道 type parameter 可以接受哪些类型。<br>这些额外信息称为约束(constraint)。</p><h4 id="Where-子句"><a href="#Where-子句" class="headerlink" title="Where 子句"></a>Where 子句</h4><ul><li>每个 type parameter 都有自己的 where 子句</li><li>如果有多个约束，在约束列表用逗号分隔</li></ul><p>where 子句使用要点: </p><ul><li>在关闭尖括号后列出</li><li>where 子句之间不用逗号分隔</li><li>子句之间可以以任何顺序列出</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, <span class="hljs-title">T3</span>&gt;<br>                      <span class="hljs-keyword">where</span> <span class="hljs-title">T2</span>: <span class="hljs-title">Customer</span><br>                      <span class="hljs-keyword">where</span> <span class="hljs-title">T3</span>: <span class="hljs-title">IComparable</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, <span class="hljs-title">T3</span>&gt;<br>                      <span class="hljs-keyword">where</span> <span class="hljs-title">T2</span>: <span class="hljs-title">Customer</span><br>                      <span class="hljs-keyword">where</span> <span class="hljs-title">T3</span>: <span class="hljs-title">IComparable</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="约束类型和次序"><a href="#约束类型和次序" class="headerlink" title="约束类型和次序"></a>约束类型和次序</h4><p>共有 5 种类型的约束: </p><ul><li>类名: 某种类或类的子类才能做 type argument</li><li>class: 任何引用类型才能做 type argument</li><li>struct: 任何值类型才能做 type argument</li><li>接口名: 只有这个接口或实现这个接口的类型才能做 type argument</li><li>new(): 任何带有无参构造的类型才能做 type argument</li></ul><p>顺序: </p><ul><li>主约束必须放在第一位且只有一个: 主约束只能是类名、class 或者 struct</li><li>接口名约束可以有任意多个</li><li>如果存在构造约束，必须放在最后</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedList</span>&lt;<span class="hljs-title">S</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">S</span>: <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">S</span>&gt; &#123; ... &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">M</span>, <span class="hljs-title">N</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">M</span>: <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">M</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">N</span>: <span class="hljs-title">ICloneable</span> &#123; ... &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyDictionary</span>&lt;<span class="hljs-title">KeyType</span>, <span class="hljs-title">ValueType</span>&gt;<br>                              <span class="hljs-keyword">where</span> <span class="hljs-title">KeyType</span>: <span class="hljs-title">IEnumerable</span>, <span class="hljs-title"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedList</span>&lt;<span class="hljs-title">S</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">S</span>: <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">S</span>&gt; &#123; ... &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">M</span>, <span class="hljs-title">N</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">M</span>: <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">M</span>&gt;<br>                         <span class="hljs-keyword">where</span> <span class="hljs-title">N</span>: <span class="hljs-title">ICloneable</span> &#123; ... &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyDictionary</span>&lt;<span class="hljs-title">KeyType</span>, <span class="hljs-title">ValueType</span>&gt;<br>                              <span class="hljs-keyword">where</span> <span class="hljs-title">KeyType</span>: <span class="hljs-title">IEnumerable</span>, <span class="hljs-title">new</span>() &#123; ... &#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>与其他的泛型不同，泛型方法是成员而不是类型，它可以用于泛型、非泛型类、结构或接口。</p><h4 id="声明泛型方法"><a href="#声明泛型方法" class="headerlink" title="声明泛型方法"></a>声明泛型方法</h4><p>泛型方法具有类型参数和可选的约束。<br>泛型方法有两个参数列表: </p><ul><li>封闭在圆括号内的方法参数列表</li><li>封闭在尖括号内的类型参数列表</li></ul><p>要声明泛型方法: </p><ul><li>在方法名之后，方法参数之前放置类型参数列表</li><li>在方法参数之后放置可选的约束子句</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintData</span>&lt;<span class="hljs-title">S</span>, <span class="hljs-title">T</span>&gt; (<span class="hljs-params">S s, T t</span>) <span class="hljs-keyword">where</span> S: Person</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintData</span>&lt;<span class="hljs-title">S</span>, <span class="hljs-title">T</span>&gt; (<span class="hljs-params">S s, T t</span>) <span class="hljs-keyword">where</span> S: Person</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="调用泛型方法"><a href="#调用泛型方法" class="headerlink" title="调用泛型方法"></a>调用泛型方法</h4><p>要调用泛型方法，需要在调用时提供类型实参: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">MyMethod&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in"><code class="language-hljs csharp">MyMethod&lt;<span class="hljs-built_in">short</span>, <span class="hljs-built_in">int</span>>();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果我们在调用泛型方法时，可以从方法参数推断出类型实参，则可以省略类型实参: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>&lt;<span class="hljs-title">T</span>&gt; (<span class="hljs-params">T t</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-built_in">int</span> IntVal = <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>&lt;<span class="hljs-title">T</span>&gt; (<span class="hljs-params">T t</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-built_in">int</span> IntVal = <span class="hljs-number">10</span>;<br>MyMethod(IntVal);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型结构"><a href="#泛型结构" class="headerlink" title="泛型结构"></a>泛型结构</h3><p>与泛型类一样，泛型结构也有类型参数和约束子句。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">struct</span> PieceOfData &lt;T&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T _Data;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PieceOfData</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        _data = data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T Data <br>    &#123;<br>        <span class="hljs-keyword">set</span> &#123; _data = <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _data; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> intData = <span class="hljs-keyword">new</span> PieceOfData&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">10</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst"><code class="language-hljs csharp"><span class="hljs-keyword">struct</span> PieceOfData &lt;T&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T _Data;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PieceOfData</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        _data = data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T Data <br>    &#123;<br>        <span class="hljs-keyword">set</span> &#123; _data = <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _data; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> intData = <span class="hljs-keyword">new</span> PieceOfData&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">10</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;intData.Data&#125;</span>"</span>);<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h3><p>泛型委托与非泛型委托类似，要声明泛型委托，需要在委托名称之后，委托参数列表之前放置类型参数列表: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> R <span class="hljs-title">MyDelegate</span> &lt;T, R&gt;(<span class="hljs-params"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> R <span class="hljs-title">MyDelegate</span> &lt;T, R&gt;(<span class="hljs-params">T t</span>)</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>C# 中有两个常用的预定义的泛型委托: Func 和 Action: </p><ul><li>Action 是无返回值的泛型委托，有 16 个重载(即最多 16 个参数)</li><li>Func 是有返回值的泛型委托，有 17 个重载(即最多 16 个参数和 1 个返回值)</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TR <span class="hljs-title">Func</span> &lt;T1, T2, TR&gt;(<span class="hljs-params">T1 p1, T2 p2</span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">PrintString</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> total = a + b;<br>        <span class="hljs-keyword">return</span> total.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> myDel = <span class="hljs-keyword">new</span> Func &lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;(Simple.PrintString);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;myDel(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)&#125;</span>&quot;</span>);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TR <span class="hljs-title">Func</span> &lt;T1, T2, TR&gt;(<span class="hljs-params">T1 p1, T2 p2</span>)</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">PrintString</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> total = a + b;<br>        <span class="hljs-keyword">return</span> total.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> myDel = <span class="hljs-keyword">new</span> Func &lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;(Simple.PrintString);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;myDel(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)&#125;</span>&quot;</span>);  <span class="hljs-comment">// 5</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口允许我们编写参数和返回值是泛型类型参数的接口。我们需要在接口名之后用尖括号放置类型参数列表。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMyIfc</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">ReturnIt</span>(<span class="hljs-params">T val</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span>&lt;<span class="hljs-title">S</span>&gt;: <span class="hljs-title">IMyIfc</span>&lt;<span class="hljs-title">S</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">ReturnIt</span>(<span class="hljs-params">S s</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> simple = <span class="hljs-keyword">new</span> Simple&lt;<span class="hljs-built_in">int</span>&gt;();<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;simple.ReturnIt(<span class="hljs-number">3</span>)&#125;</span>&quot;</span>);  <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMyIfc</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">ReturnIt</span>(<span class="hljs-params">T val</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span>&lt;<span class="hljs-title">S</span>&gt;: <span class="hljs-title">IMyIfc</span>&lt;<span class="hljs-title">S</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">ReturnIt</span>(<span class="hljs-params">S s</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> simple = <span class="hljs-keyword">new</span> Simple&lt;<span class="hljs-built_in">int</span>&gt;();<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;simple.ReturnIt(<span class="hljs-number">3</span>)&#125;</span>&quot;</span>);  <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;理想有两种: 一种，我实现了我的理想；另一种: 理想通过我而实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一篇，讲讲泛型。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%B8%89)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%B8%89)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们看看 C# 中的枚举器和迭代器的基本概念。<br>之前我们说过可以使用 foreach 来遍历数组元素，本篇来讨论为什么数组可以使用 foreach 语句处理，我们可以还使用迭代器来使得自定义类型也可以使用 foreach。</p><h2 id="枚举器和可枚举类型"><a href="#枚举器和可枚举类型" class="headerlink" title="枚举器和可枚举类型"></a>枚举器和可枚举类型</h2><hr><p>为什么数组可以使用 foreach 呢？因为数组可以提供一个枚举器(enumerator)对象。枚举器对象可以依次返回数组元素。<br>获取一个对象的枚举器可以调用对象的 GetEnumerator 方法。实现了 GetEnumerator 方法的对象称为可枚举(enumerable)对象。</p><p>foreach 语句就是用来配合可枚举类型一起使用的，他会执行下列行为: </p><ul><li>调用 GetEnumerator 方法获取对象的枚举器</li><li>从枚举器请求每一项作为迭代变量(iteration variable)，我们可以读取该变量但不能改变</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">foreach</span> (Type ValName <span class="hljs-keyword">in</span> EnumerableObject) &#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">foreach</span> (Type ValName <span class="hljs-keyword">in</span> EnumerableObject) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h3><p>实现 IEnumerator 接口的枚举器包含三个函数成员: </p><ul><li>Current: 返回当前位置项的属性，只读</li><li>MoveNext: 把枚举器位置前进到集合下一项的方法，返回布尔值，位置有效返回 true，无效(到达尾部)返回 false。枚举器原始位置在第一项之前，因此在使用 Current 之前必须先调用 MoveNext</li><li>Reset: 位置重置为原始状态</li></ul><p>下面代码与直接使用 foreach 产生的结果是一样的: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] MyArr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;;<br>        IEnumerator ie = MyArr.GetEnumerator();<br>        <span class="hljs-keyword">while</span> (ie.MoveNext())<br>        &#123;<br>            <span class="hljs-built_in">int</span> current = (<span class="hljs-built_in"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] MyArr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;;<br>        IEnumerator ie = MyArr.GetEnumerator();<br>        <span class="hljs-keyword">while</span> (ie.MoveNext())<br>        &#123;<br>            <span class="hljs-built_in">int</span> current = (<span class="hljs-built_in">int</span>)ie.Current;<br>            Console.WriteLine(current);<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h3><p>可枚举类型是指实现了 IEnumerable 接口的类。IEnumerable 只有一个函数成员: </p><ul><li>GetEnumerator: 获取可枚举类型的枚举器</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="使用-IEnumerator-和-IEnumerable-示例"><a href="#使用-IEnumerator-和-IEnumerable-示例" class="headerlink" title="使用 IEnumerator 和 IEnumerable 示例"></a>使用 IEnumerator 和 IEnumerable 示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ColorEnumerator</span> : <span class="hljs-title">IEnumerator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] _colors;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _position = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorEnumerator</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] colors</span>)</span><br>    &#123;<br>        _colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[colors.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++) &#123;<br>            _colors[i] = colors[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> (_position &lt;= <span class="hljs-number">-1</span> || _position &gt;= _colors.Length) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>            &#125;<br>            <span class="hljs-keyword">return</span> _colors[_position];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>(<span class="hljs-params">(</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (_position &lt; _colors.Length - <span class="hljs-number">1</span>) &#123;<br>            _position++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>(<span class="hljs-params"></span>)</span> <br>    &#123;<br>        _position = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Colors</span> : <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] _colors;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colors</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] colors</span>)</span><br>    &#123;<br>        _colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[colors.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++) &#123;<br>            _colors[i] = colors[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorEnumerator(_colors);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Progeam</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Colors colors = <span class="hljs-keyword">new</span> Colors(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>&#125;);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> color <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ColorEnumerator</span> : <span class="hljs-title">IEnumerator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] _colors;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _position = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorEnumerator</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] colors</span>)</span><br>    &#123;<br>        _colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[colors.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++) &#123;<br>            _colors[i] = colors[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> (_position &lt;= <span class="hljs-number">-1</span> || _position &gt;= _colors.Length) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>            &#125;<br>            <span class="hljs-keyword">return</span> _colors[_position];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>(<span class="hljs-params">(</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (_position &lt; _colors.Length - <span class="hljs-number">1</span>) &#123;<br>            _position++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>(<span class="hljs-params"></span>)</span> <br>    &#123;<br>        _position = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Colors</span> : <span class="hljs-title">IEnumerable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] _colors;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colors</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] colors</span>)</span><br>    &#123;<br>        _colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[colors.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++) &#123;<br>            _colors[i] = colors[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorEnumerator(_colors);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Progeam</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        Colors colors = <span class="hljs-keyword">new</span> Colors(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>&#125;);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> color <span class="hljs-keyword">in</span> colors) &#123;<br>            Console.WriteLine(color);<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h3><p>之前我们写的都是非泛型版本，实际工作中，我们基本都使用泛型版本的 IEnumerator<T> 和 IEnumerable<T> 。非泛型版本只是兼任 2.0 版本之前无泛型的遗留代码。</p><p>泛型与非泛型版本的主要区别是: </p><ul><li>IEnumerable<T> 接口的 GetEnumerator 方法要返回实现 IEnumerator<T> 接口的枚举器实例</li><li>泛型版本的 Current 属性返回的不是 object 类型，而是实际类型的对象</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>C# 2.0 之后，提供了更简单的创建枚举器和可枚举类型的方式。这种结构称为迭代器(iterator)。</p><ul><li>迭代器返回一个泛型的枚举器</li><li>yield return 语句声明这是枚举的下一项</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">BlackAndWhite</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;black&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gray&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">BlackAndWhite</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;black&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gray&quot;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">"white"</span>;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们看看 C# 中的枚举器和迭代器的基本概念。&lt;br&gt;之前我们说过可以使用 foreach 来遍历数组元素，本篇来讨论为什么数组可以使用 foreach 语句处理，我们可以还使用迭代器来使得自定义类型也可以使用 foreach。&lt;/p&gt;
&lt;h2 id=&quot;枚举器和可枚</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E5%9B%9B)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E5%9B%9B)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，讲讲 LINQ。<br>LINQ(发音同 link，不要读成 lin-q)代表语言集成查询(Language Integrated Query)，他是 .Net 的扩展，允许我们很轻松的操作对象集合。<br>LINQ 的出现也就意味着允许我们在 C# 中使用函数式编程的思想。</p><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>创建匿名对象与创建具名对象类似，只是没有类名和构造函数: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">new</span> &#123; FieldProp = InitExpr; FieldProp = InitExpr, ... &#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: </p><ul><li>匿名对象只能用于局部变量，不能用于成员</li><li>必须是由 var 作为类型</li><li>不能设置属性，匿名对象的属性是只读的</li></ul><h3 id="方法语法和查询语法"><a href="#方法语法和查询语法" class="headerlink" title="方法语法和查询语法"></a>方法语法和查询语法</h3><p>我们再写 LINQ 可以使用两种语法: </p><ul><li>方法语法</li><li>查询语法</li></ul><p>微软推荐使用查询语法，但是我更习惯方法语法。<br><strong>更新: 查询语法真香！</strong></p><h3 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h3><p>LINQ 查询返回两种类型的结果: </p><ul><li>可枚举的类型</li><li>单一标量</li></ul><h3 id="标准查询运算符"><a href="#标准查询运算符" class="headerlink" title="标准查询运算符"></a>标准查询运算符</h3><p>标准查询运算符由一系列 API 方法组成，标准查询运算符特性如下: </p><ul><li>被查询的集合对象称为序列，必须实现 IEnumerable<T> 接口</li><li>标准查询运算符使用方法语法</li><li>一些运算符返回 IEnumerable<T> 对象，一些则返回标量</li><li>很多操作都以谓词作为参数，谓词是一个方法，以对象作为参数，根据是否满足条件返回 true 或 false</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> total = numbers.Sum();  <span class="hljs-comment">// 6</span><br>        <span class="hljs-built_in">int</span> howMany = numbers.Count(); <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> total = numbers.Sum();  <span class="hljs-comment">// 6</span><br>        <span class="hljs-built_in">int</span> howMany = numbers.Count(); <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>C# 中的序列包括 Array、List<T>、Dictionary&lt;T1, T2&gt; 等。LINQ 可以以非常强大的方式来操纵这些对象。</p><p>共有 47 个标准查询运算符，常用的如: Where(类似于 filter)、Select(类似于 map)、toList<T>、First、FirstOrDefault、Last、LastOrDefault、Take、Skip 等，当我们需要使用高级用法时，我们可以在查询文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，讲讲 LINQ。&lt;br&gt;LINQ(发音同 link，不要读成 lin-q)代表语言集成查询(Language Integrated Query)，他是 .Net 的扩展，允许我们很轻松的操作对象集合。&lt;br&gt;LINQ 的出现也就意味着允许我们在 C# 中使用函数式编</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%BA%94)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%BA%94)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 网络编程中比较重要的概念 —— 异步。</p><h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><p>当程序启动时，系统就会在内存创建一个新进程。进程是构成程序的资源的集合，资源包括虚拟地址、文件句柄等。</p><p>在进程内部，系统还创建了称为线程的内核对象。也就是说一旦进程创建，系统就会在 Main 方法的第一行语句开始线程执行。</p><p>关于线程: </p><ul><li>默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束</li><li>线程可以派生其他线程</li><li>如果一个进程包含多个线程，他们将共享进程资源</li><li>系统为处理器执行所规划的基本单元是线程而不是进程</li></ul><p>在 C# 5.0 引入了一个非常好的特性 —— async/await。在 JavaScript 和即将到来的 Swift 5.0 中都存在引入了此特性，虽然实现的底层原理并不相同。<br>这个特性是 .Net 框架的一部分，但是没有嵌入 C# 中。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>如果程序调用某个方法，等待其执行所有处理之后才继续执行，我们称这样的方法为同步方法。<br>相反的，异步方法就是在处理完成之前就返回到调用方法。我们使用 async/await 特性可以很方便的创建异步方法。<br>该特性有三部分组成: </p><ul><li>调用方法: 调用异步方法的方法，在异步方法执行任务时继续执行</li><li>异步方法: 该方法异步执行其工作，然后立即返回到调用方法</li><li>await 表达式: 用于异步方法内，指明需要异步执行的任务，一个异步方法可以包含多个 await 表达式，如果一个都不包含，则该方法将同步执行，编译器会报警告</li></ul><p>async 关键字是一个专门给编译器的提示，意思是该函数的实现可能会出现 await 表达式。</p><ul><li>在 Debug 模式下，对于 async 方法，生成一个 class 状态机</li><li>在 Release 模式下，对于 async 方法，生成一个 struct 状态机</li></ul><h3 id="什么是异步方法"><a href="#什么是异步方法" class="headerlink" title="什么是异步方法"></a>什么是异步方法</h3><p>异步方法的特点: </p><ul><li>方法头包含 async 方法修饰符</li><li>包含一个或多个 await 表达式表示异步完成的任务</li><li>返回值只能是 void，Task 或 Task&lt;T&gt;</li><li>异步方法参数不能有 out 或 ref 修饰</li><li>按照约定，异步方法以 Async 结尾</li><li>Lambda 表达式也可以作为异步对象</li><li>调用方法读取 Task 的 Result 属性获取 T 类型的值</li><li>任何返回 Task&lt;T&gt; 的异步方法必须返回 T 类型的值</li></ul><p>需要注意: </p><ul><li>不要使用 void 作为 async 方法的返回值类型，async 方法可以返回 void，仅限于编写事件处理程序，如果是普通方法没有返回值，需要返回 Task</li><li>避免使用 Task.Wait 和 Task.Result 方法，可能会导致死锁</li><li>当第一次遇到 await 表达式所返回的类型就是方法头的返回值类型，与 await 表达式的返回值类型没关系</li><li>异步方法的 return 语句并没有真正返回值，而只是退出了</li></ul><h3 id="在调用方法同步等待任务"><a href="#在调用方法同步等待任务" class="headerlink" title="在调用方法同步等待任务"></a>在调用方法同步等待任务</h3><p>我们可能需要在调用方法中同步等待某个任务完成，Task&lt;T&gt; 实例提供了 Wait 方法，来等待某个特殊的 Task 完成。<br>还可以使用 Task 的静态方法 WaitAll 和 WaitAny 方法同步等待多个任务完成。参数为 Task[]。</p><h3 id="在异步方法异步等待任务"><a href="#在异步方法异步等待任务" class="headerlink" title="在异步方法异步等待任务"></a>在异步方法异步等待任务</h3><p>我们可以使用 await 和 Task 的静态方法 WhenAll 和 WhenAny 方法异步等待多个任务完成。参数为 List&lt;Task&lt;T&gt;&gt;。</p><p>注意: async 和 await 都没有新开线程，新开线程是 Task.Run() 做的事情。如果自己编写异步方法，注意要自己编写 Task.Run()。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 网络编程中比较重要的概念 —— 异步。&lt;/p&gt;
&lt;h3 id=&quot;什么是异步&quot;&gt;&lt;a href=&quot;#什么是异步&quot; class=&quot;headerlink&quot; title=&quot;什么是异步&quot;&gt;&lt;/a&gt;什么是异步&lt;/h3&gt;&lt;p&gt;当程序启动时，系统就会在内存创建一个新</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E5%85%AD)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E5%85%AD)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中的异常处理 —— try、catch、finially。</p><h3 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h3><p>异常是程序运行时错误，出现正常操作时未预料的情况。当发生时，系统会捕获这个错误并抛出异常。<br>在编写 iOS 程序时，我们可能很少使用异常，通常我们使用 NSError **error 这样的二级指针来获取错误对象，处理不同的错误。</p><h3 id="try-语句"><a href="#try-语句" class="headerlink" title="try 语句"></a>try 语句</h3><p>try 语句是为了避免出现异常而被保护的代码段，在出现异常时提供异常处理。<br>try 语句由三部分组成: </p><ul><li>try 包含为避免出现异常而被保护的代码</li><li>catch 是异常处理程序</li><li>finally 是在所有情况都会执行的代码块，不论有没有异常</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>catch () &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>catch () &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>catch () &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br>catch () &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>有许多不同类型的异常可能在程序中发生。BCL 定义了许多异常类。当一个异常发生时，我们应: </p><ul><li>创建该类型的异常对象</li><li>在适当的 catch 子句处理</li></ul><p>所有的异常类都继承自 System.Exception。异常对象含有只读属性: </p><ul><li>Message: 包含异常原因</li><li>StackTrace: 调用栈</li></ul><h3 id="catch-子句"><a href="#catch-子句" class="headerlink" title="catch 子句"></a>catch 子句</h3><p>catch 子句有三种形式: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">catch &#123;<br>    <span class="hljs-comment">//没有参数，匹配 try 中发生的任何异常</span><br>&#125;<br><br>catch (ExceptionType) &#123;<br>    <span class="hljs-comment">//异常类型作为参数，匹配该类型的异常</span><br>&#125;<br><br>catch (ExceptionType Exp) &#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp">catch &#123;<br>    <span class="hljs-comment">//没有参数，匹配 try 中发生的任何异常</span><br>&#125;<br><br>catch (ExceptionType) &#123;<br>    <span class="hljs-comment">//异常类型作为参数，匹配该类型的异常</span><br>&#125;<br><br>catch (ExceptionType Exp) &#123;<br>    <span class="hljs-comment">//特定异常对象作为参数，匹配该类型的异常，在代码块中可以使用异常对象</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="finally-子句"><a href="#finally-子句" class="headerlink" title="finally 子句"></a>finally 子句</h3><p>如果程序进入了一个带有 finally 块的 try 语句，那么 finally 块总会执行。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>我们可以使用 throw 语句显式触发一个异常，语法如下: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">throw</span> ExceptionObject;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>throw 还可以不带异常对象使用，只能用在 catch 块内部。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中的异常处理 —— try、catch、finially。&lt;/p&gt;
&lt;h3 id=&quot;什么是异常&quot;&gt;&lt;a href=&quot;#什么是异常&quot; class=&quot;headerlink&quot; title=&quot;什么是异常&quot;&gt;&lt;/a&gt;什么是异常&lt;/h3&gt;&lt;p&gt;异常是程序运行时错</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E4%B8%83)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E4%B8%83)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，介绍一些 C# 中的比较常见的预处理指令。</p><p>C 和 C++ 都有实际的预处理阶段，而在 C# 中是没有的，预处理指令是由编译器来处理。<br>在 Objective-C 中预处理指令也特别常用。</p><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>下面是预处理指令的主要规则: </p><ul><li>预处理指令必须与 C# 代码处于不同行</li><li>包含预处理指令的行必须以 # 开头<ol><li># 字符前可以有空格</li><li># 字符与预处理指令之间可以有空格</li></ol></li><li>允许行尾有单行注释，不可以有多行注释</li></ul><h3 id="define-和-undef-指令"><a href="#define-和-undef-指令" class="headerlink" title="#define 和 #undef 指令"></a>#define 和 #undef 指令</h3><p>编译符号是只有两种状态的标识符。要么被定义，要么未被定义。<br>编译符号有如下特性: </p><ul><li>可以是除了 true 和 false 之外的任何标识符，包括 C# 关键字，以及在 C# 中声明的标识符</li><li>他没有值，与 C 不同，他不表示字符串</li></ul><p>#define 指令声明一个编译符号，#undef 指令取消声明一个编译符号。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PremiumVersion</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EconomyVersion</span><br>...<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword"><code class="language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PremiumVersion</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EconomyVersion</span><br>...<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> PremiumVersion</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: #define 和 #undef 指令只能用于任何 C# 代码之前，在 C# 代码开始之后，这两个指令就都不可以使用了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PremiumVersion    //错误，必须出现在所有 C# 代码之前</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Eagle</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PremiumVersion    //错误，必须出现在所有 C# 代码之前</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Eagle</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PremiumVersion    //错误</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>重复定义编译符号也是允许的。</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>条件编译允许我们根据某个编译符号是否被定义来标注一段代码被编译或跳过。<br>有4个指令用来指定条件编译: </p><ul><li>#if</li><li>#else</li><li>#elif</li><li>#endif</li></ul><p>如下: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> PremiumVersion</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (PremiumVersion &amp;&amp; LeftHanded)</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> true  //总被编译</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword"><code class="language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> PremiumVersion</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (PremiumVersion &amp;&amp; LeftHanded)</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> true  //总被编译</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="条件编译的结构"><a href="#条件编译的结构" class="headerlink" title="条件编译的结构"></a>条件编译的结构</h3><p>如下: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> Cond1</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> Cond2</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> Cond3</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> Cond1</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword"><code class="language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> Cond1</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> Cond2</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> Cond3</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> Cond1</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="诊断指令"><a href="#诊断指令" class="headerlink" title="诊断指令"></a>诊断指令</h3><p>下面是诊断指令的语法，注意与 C# 普通字符串不同，Message 无需引号包裹: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">warning</span> Message</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword"><code class="language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">warning</span> Message</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> Message</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="区域指令"><a href="#区域指令" class="headerlink" title="区域指令"></a>区域指令</h3><p>区域指令允许我们命名一段代码，#region 指令特性如下: </p><ul><li>放置在希望标注的代码段之上</li><li>在该指令后放置可选字符串作为名字</li><li>之后的代码由 #endregion 指令终止</li></ul><p>VisualStudio 可以显式和隐藏由区域指令包裹的代码段。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> Constructor</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>&#123;<br><br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword"><code class="language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> Constructor</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>&#123;<br><br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="pragma-warning"><a href="#pragma-warning" class="headerlink" title="#pragma warning"></a>#pragma warning</h3><p>该指令允许我们关闭和开启警告信息: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span> disable 618, 414</span><br>...<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword"><code class="language-hljs csharp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span> disable 618, 414</span><br>...<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span> restore 618</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，介绍一些 C# 中的比较常见的预处理指令。&lt;/p&gt;
&lt;p&gt;C 和 C++ 都有实际的预处理阶段，而在 C# 中是没有的，预处理指令是由编译器来处理。&lt;br&gt;在 Objective-C 中预处理指令也特别常用。&lt;/p&gt;
&lt;h3 id=&quot;基本规则&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/C#(%E5%8D%81%E5%85%AB)/"/>
    <id>https://1ess.github.io/C#(%E5%8D%81%E5%85%AB)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 C# 中非常重要的概念 —— 反射和特性。</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>很多程序语言中有元数据(matedata)的概念，其实元数据就是描述数据的数据。<br>一个运行的程序查看本身元数据或其他程序元数据的行为就叫做反射(reflection)。<br>要使用反射，我们必须引入 System.Reflection 命名空间。</p><h3 id="Type-类"><a href="#Type-类" class="headerlink" title="Type 类"></a>Type 类</h3><p>BCL 声明了一个 Type 的抽象类，他被设计用来包含类型的特性。使用这个类的对象可以让我们获得程序使用的类型信息。<br>我们需要了解的是: </p><ul><li>对于程序中的每一个类型，CLR 都会创建一个包含这个类型信息的 Type 类型的对象</li><li>程序中用到的每一个类型都会关联到独立的 Type 类型的实例</li><li>不管创建的类型有多少个实例，只有一个 Type 对象会关联到多有的这些实例</li></ul><p>我们可以从 Type 类型的实例获取几乎所有关于类型的信息，Type 类有很多有用的成员，如: </p><ul><li>Name 属性，返回类型名</li><li>NameSapce 属性，返回类型声明的命名空间</li><li>Assembly 属性，返回程序集</li><li>GetFields 方法，返回字段列表</li><li>GetProperties 方法，返回属性列表</li><li>GetMethods 方法，返回方法列表</li></ul><h3 id="获取-Type-对象的实例"><a href="#获取-Type-对象的实例" class="headerlink" title="获取 Type 对象的实例"></a>获取 Type 对象的实例</h3><p>我们可以使用 GetType 方法和 typeof 运算符获取 Type 对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">using</span> System.Reflection;<br><br>Type t1 = myInstance.GetType();<br>Type t2 = <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">using</span> System.Reflection;<br><br>Type t1 = myInstance.GetType();<br>Type t2 = <span class="hljs-keyword">typeof</span> (DerivedClass);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>特性(attribute)是一种允许我们向程序集添加元数据的语言结构。<br>按照惯例，特性以 Pascal 命名法，并以 Attribute 为后缀命名。当应用特性时，可以不加 Attribute 后缀。<br>应用特性要被方括号包裹，其中是特性名和参数列表。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br><br>&#125;<br><br>[<span class="hljs-meta">MyAttribute(<span class="hljs-meta-string">&quot;Simple String&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs csharp">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br><br>&#125;<br><br>[<span class="hljs-meta">MyAttribute(<span class="hljs-meta-string">&quot;Simple String&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyOtherClas</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="预定义特性"><a href="#预定义特性" class="headerlink" title="预定义特性"></a>预定义特性</h3><h4 id="Obsolete-特性"><a href="#Obsolete-特性" class="headerlink" title="Obsolete 特性"></a>Obsolete 特性</h4><p>我们可以使用 Obsolete 特性标注方法过期: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-meta-string">&quot;Use Method SuperPrint&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"><code class="language-hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-meta-string">&quot;Use Method SuperPrint&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>&#123;<br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们依旧可以使用过期方法，可以成功编译并执行，但是编译器会报警告。我们可以使用第二个布尔参数，使得编译错误。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-meta-string">&quot;Use Method SuperPrint&quot;</span>, true)</span>] <span class="hljs-comment">//调用会发生编译错误</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"><code class="language-hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-meta-string">&quot;Use Method SuperPrint&quot;</span>, true)</span>] <span class="hljs-comment">//调用会发生编译错误</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span><br>&#123;<br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="Conditional-特性"><a href="#Conditional-特性" class="headerlink" title="Conditional 特性"></a>Conditional 特性</h4><p>Conditional 特性允许我们包含或排斥特定方法的所有调用。<br>如果定义了编译符号参数，则标记为 Conditional 特性的方法与普通方法一样，如果未定义编译符号，则所有的 Conditional 方法都不会调用: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">Conditional(<span class="hljs-meta-string">&quot;DoTrace&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TraceMessage</span>(<span class="hljs-params"><span class="hljs-built_in"><code class="language-hljs csharp">[<span class="hljs-meta">Conditional(<span class="hljs-meta-string">&quot;DoTrace&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TraceMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>&#123;<br>    Console.WriteLine(str);<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>ASP.Net MVC 有很多重要的特性，我们会在学习 MVC 时再具体学习。</p><h3 id="其他特性相关"><a href="#其他特性相关" class="headerlink" title="其他特性相关"></a>其他特性相关</h3><p>我们可以为单个结构应用多个特性，可以使用多层结构，也可以使用逗号分隔: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">Serializable</span>]<br>[<span class="hljs-meta">MyAttribute(<span class="hljs-meta-string">&quot;Simple String&quot;</span>)</span>]<br><br>[<span class="hljs-meta">Serializable, MyAttribute(<span class="hljs-meta-string"><code class="language-hljs csharp">[<span class="hljs-meta">Serializable</span>]<br>[<span class="hljs-meta">MyAttribute(<span class="hljs-meta-string">&quot;Simple String&quot;</span>)</span>]<br><br>[<span class="hljs-meta">Serializable, MyAttribute(<span class="hljs-meta-string">"Simple String"</span>)</span>]<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>除了类，特性还可以应用于字段，属性和方法等。</p><h3 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h3><p>所有的特性要派生自 System.Attribute。<br>要声明一个自定义特性: </p><ul><li>声明一个派生自 System.Attribute 的类</li><li>给他起一个 Attribute 后缀的名字</li><li>通常将该类声明为密封 sealed</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyAttribute</span> : <span class="hljs-title"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyAttribute</span> : <span class="hljs-title">System.Attribute</span><br>&#123;<br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 特性类的成员只能是: </p><ul><li>字段</li><li>属性</li><li>构造函数</li></ul><p>每个特性至少有一个公共构造函数。我们在应用特性传入参数列表时，其实是在使用不同的构造函数。<br>关于特性构造函数: </p><ul><li>应用特性时，构造函数的实参必须是在编译期可以确定的常量表达式</li><li>如果构造函数没有参数，可以省略圆括号</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 C# 中非常重要的概念 —— 反射和特性。&lt;/p&gt;
&lt;h3 id=&quot;元数据&quot;&gt;&lt;a href=&quot;#元数据&quot; class=&quot;headerlink&quot; title=&quot;元数据&quot;&gt;&lt;/a&gt;元数据&lt;/h3&gt;&lt;p&gt;很多程序语言中有元数据(matedata)的概念，其实元</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E8%81%8A%E8%81%8A%E6%9C%80%E8%BF%91%EF%BC%8C%E8%81%8A%E8%81%8A%E7%94%9F%E6%B4%BB/"/>
    <id>https://1ess.github.io/%E8%81%8A%E8%81%8A%E6%9C%80%E8%BF%91%EF%BC%8C%E8%81%8A%E8%81%8A%E7%94%9F%E6%B4%BB/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇聊聊最近的生活吧。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>最近好多之前离职的小伙伴希望我去他们的新公司去看看，可能的话可以去他们的公司工作，还是有些开心的，最起码是对我的认可。但还是因为各种原因婉拒了。</p><p>首先，就是最近过的有点忙，10.1 那天去办理新房入户，之后还要装修。<br>其二，希望在现在这个公司越干越好吧，入职已经两年多，有些不舍。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>生活中也完成了人生中的一件大事 —— 买房。在 2017 年 12 月 13 日贷款下来了，巧的是那一天正是我的生日。10 月 1 日这天房子也终于下来了，吃完午饭溜达着去办理新房入户。办理入户的时候才第一次进门看看，检查了一圈还算满意吧，虽然之前觉得不想背负这么大的压力，但第一次踏进属于自己的家门，还是有些不一样的感觉。之后匆匆赶回老家去参加老哥 10 月 3 号的婚礼，很圆满。可能自己 1 年之后也会结婚吧，不知道又会是什么样子。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>最近把 C# 基础知识详细复习完毕，之后会把精力先放在 ASP.Net Core MVC 上，学习一下最佳实践。现在 .Net Core 已经是 2.1 了，基础设施已经比较完善。<br>计划路线: </p><ul><li>ASP.Net MVC</li><li>ASP.Net API</li><li>ASP.Net Core</li></ul><p>还是决定把之前想好好学习的数据库知识先放一放，确实是个大工程，把 ASP.Net 搞的透彻一些再开始吧。<br>最后说一句，ReSharper 插件确实是个好东西，谁用谁知道！</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之前在京东云买了个服务器，又在腾讯云买的域名，最近想把个人网站好好搞搞，这个 ICP 备案真是中国特色。哎！</p><blockquote><p>最后我想说，几十年以后，或者几个世纪以后，回顾这段历史的时候，大家会觉得网站备案、GFW、绿坝软件、诸如此类的事情，都是好事，因为它们让许多中国青年认清了这个社会的本质，不再对旧制度抱有幻想，开始期盼新制度的到来，从而大大加快了社会变革的速度。要是没有它们，许多人也许要过许多年才会对现行制度产生怀疑，从而进行彻底的反思，新制度就会因此少了许多支持者。统治者越是凶恶，其实越表明他的恐慌和虚弱，而历史就像印度诗人泰戈尔所说，”总是在耐心地等待被侮辱和被压迫者的胜利”。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/other/other1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇聊聊最近的生活吧。&lt;/p&gt;
&lt;h3 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h3&gt;&lt;p&gt;最近好多之前离职的小伙伴希望我去他们的新公司去看看，可能的话可以去他们的公司工作，还是有些开心的，最</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E7%BC%96%E7%A8%8B%E4%B8%89%E5%B9%B4/"/>
    <id>https://1ess.github.io/%E7%BC%96%E7%A8%8B%E4%B8%89%E5%B9%B4/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章，也算是给自己毕业三年的编程生涯做个总结。<br>时间如白驹过隙，满打满算毕业也已经三年有余，也早就想写一篇文章来回忆一下自己毕业后的工作生活。</p><h3 id="南下"><a href="#南下" class="headerlink" title="南下"></a>南下</h3><p>2015 年的 7 月，从票贩子手中接过去往广州的火车票，头也不回的踏上火车，三天两夜，憧憬着也迷茫着。<br>下了火车，天就像漏了一样下着瓢泼大雨，一个人拖着行李箱在肯德基等到接我的大学室友，像一对难兄难弟。<br>广州的生活不用多说，上班写码，下班逛街。走过了广州的大街小巷，逛过了羊城八景。生活有苦有乐，苦中作乐。</p><p>转眼到了 15 年的春节，望着卡中的余额，再看看飞机票的价格，还是放弃了回家的念头，也是至今唯一一个没陪在父母身边过的第一个春节。印象最深的也就是陪着我过节的兰州拉面了。</p><p>之后的日子也不紧不慢地过着，晚上也越来越愿意去珠江边走走，望着一座座的高楼大厦，有时候也会问自己我属于这里吗？离开的想法也越来越强烈。</p><h3 id="北归"><a href="#北归" class="headerlink" title="北归"></a>北归</h3><p>一旦有了离开的念头，确实蛮难回头，一段时间后终于也下定决心，在 16 年的 9 月，再次回到了离开一年的家乡，刚回来的感觉是那么的熟悉，亲切。也希望在这里实现自己的理想。<br>在 10 月 7 日加入新公司直到现在。<br>之后的日子感觉过的飞快，与女朋友一起租房，在父母支持下买房，努力地工作去证明自己。<br>回来工作的两年，从南方到北方给我的感觉确实是从大环境到个人素质确实有差距，哈尔滨的技术风气确实有些奇怪。但是个人的力量太渺小，做好自己就好。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这三年从一个代码写得不怎么样的渣、到会写点渣代码、再到终于能写点代码。心里还是有些欣慰，感觉自己的努力可以看到点成果。<br>身边的同事来来往往，看着新人同事专注 Coding、Google、Debug 的样子，倒也是想起了那个从哈尔滨跑到广州，秋天，一个人拎着皮箱，坐在肯德基中的自己。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写这篇文章，也算是给自己毕业三年的编程生涯做个总结。&lt;br&gt;时间如白驹过隙，满打满算毕业也已经三年有余，也早就想写一篇文章来回忆一下自己毕业后的工作生活。&lt;/p&gt;
&lt;h3 id=&quot;南下&quot;&gt;&lt;a href=&quot;#南下&quot; class=&quot;headerlink&quot; title=&quot;南下&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/ASP.Net%20MVC(%E4%B8%80)/"/>
    <id>https://1ess.github.io/ASP.Net%20MVC(%E4%B8%80)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>从这篇开始，我们来谈谈 ASP.Net MVC，我们将会介绍 ASP.Net MVC 的方方面面(包括基础以及高级特性)。</p><h2 id="MVC-架构"><a href="#MVC-架构" class="headerlink" title="MVC 架构"></a>MVC 架构</h2><hr><p>MVC 架构以及在软件工程出现很长时间了，几乎所有语言都有 MVC 以及变种形式。</p><h3 id="iOS-中的-MVC"><a href="#iOS-中的-MVC" class="headerlink" title="iOS 中的 MVC"></a>iOS 中的 MVC</h3><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/MVC/1/iOSMVC.jpg"></p><p>图中绿色箭头表示直接引用，只有 Controller 直接持有 Model 和 View 的引用，<br>View 向 Controller 的通信有三种形式: </p><ul><li>target-action</li><li>delegate</li><li>data source</li></ul><p>Model 向 Controller 的通信则通过 Notification &amp; KVO。</p><p>在 iOS 的 MVC 严格实现中，Model 和 View 是绝对不能直接通信的，即互相之间不能持有对方。这也是区别于 Android 和 .Net 最大的地方。<br>虽然耦合度会减少，但是会造成 Controller 巨大，这也是现在 MVVM，MVP 等其他架构出现的原因。</p><h3 id="Net-中的-MVC"><a href="#Net-中的-MVC" class="headerlink" title=".Net 中的 MVC"></a>.Net 中的 MVC</h3><p>下面我们在具体看看 .Net MVC 是怎样实现的。<br>MVC 中: </p><ul><li>M 指的就是 Model: 它是一种数据以及业务逻辑</li><li>V 指的就是 View: 它是用户界面，利用模型展示界面给用户，也允许用户修改数据</li><li>C 指的就是 Controller: 它可以处理用户请求，通常，用户与界面交互，发起一个网络请求，这个请求就被 Controller 处理，利用模型数据渲染恰当的界面作为响应</li></ul><p>在 .Net 中的 MVC，Model 会从 Controller 传递给 View。</p><h2 id="ASP-Net-MVC-历史版本"><a href="#ASP-Net-MVC-历史版本" class="headerlink" title="ASP.Net MVC 历史版本"></a>ASP.Net MVC 历史版本</h2><hr><h3 id="MVC-1-0-特性"><a href="#MVC-1-0-特性" class="headerlink" title="MVC 1.0 特性"></a>MVC 1.0 特性</h3><ul><li>使用 WebForm 引擎</li><li>路由</li><li>HTML Helpers</li><li>Ajax Helpers</li></ul><h3 id="MVC-2-0-特性"><a href="#MVC-2-0-特性" class="headerlink" title="MVC 2.0 特性"></a>MVC 2.0 特性</h3><ul><li>Area</li><li>异步 Controller</li><li>客户端验证</li><li>自定义模板</li></ul><h3 id="MVC-3-0-特性"><a href="#MVC-3-0-特性" class="headerlink" title="MVC 3.0 特性"></a>MVC 3.0 特性</h3><ul><li>Razor 视图引擎</li><li>Global filters</li><li>远程验证</li><li>ViewBag</li></ul><h3 id="MVC-4-0-特性"><a href="#MVC-4-0-特性" class="headerlink" title="MVC 4.0 特性"></a>MVC 4.0 特性</h3><ul><li>Bundling 和 minification</li></ul><h3 id="MVC-5-0-特性"><a href="#MVC-5-0-特性" class="headerlink" title="MVC 5.0 特性"></a>MVC 5.0 特性</h3><ul><li>Authentication filters</li><li>支持 Bootstrap</li><li>ASP.Net Identity</li></ul><h3 id="MVC-5-2-特性"><a href="#MVC-5-2-特性" class="headerlink" title="MVC 5.2 特性"></a>MVC 5.2 特性</h3><ul><li>Attribute based routing</li></ul><p>注意: MVC 5 项目 默认包含 bootstrap 3.0 的 css 和 js 文件. </p><h2 id="ASP-Net-MVC-项目文件夹结构"><a href="#ASP-Net-MVC-项目文件夹结构" class="headerlink" title="ASP.Net MVC 项目文件夹结构"></a>ASP.Net MVC 项目文件夹结构</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/MVC/1/FolderStructure.png"></p><h3 id="App-Data"><a href="#App-Data" class="headerlink" title="App_Data"></a>App_Data</h3><p>App_Data 文件夹可以容纳 localDB，XML，日志文件等应用数据文件。</p><h3 id="App-Start"><a href="#App-Start" class="headerlink" title="App_Start"></a>App_Start</h3><p>App_Start 文件夹当程序已启动就会被执行的类文件。例如: AuthConfig.cs，BundleConfig.cs，FilterConfig.cs，RouteConfig.cs 等。<br>在 MVC 5 默认包含 BundleConfig.cs，FilterConfig.cs 以及 RouteConfig.cs 三个配置类文件。</p><h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>Content 文件夹容纳静态文件如 css，image 以及 favicon 等。在 MVC 5 默认包含 bootstrap.css，bootstrap.min.css 以及 Site.css 文件。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller 文件夹容纳 controller 类文件，MVC 要求 controller 文件名以 Controller 结尾</p><h3 id="fonts"><a href="#fonts" class="headerlink" title="fonts"></a>fonts</h3><p>fonts 文件夹容纳自定义字体文件。</p><h3 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h3><p>Models 文件夹容纳模型类文件。</p><h3 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h3><p>Scripts 文件夹容纳 JavaScript 文件。MVC 5 默认包含 bootstrap，jquery3.3.1 以及 modernizr2.8.3。</p><h3 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h3><p>Views 文件夹容纳应用的 html 文件以 .cshtml 作为后缀。.cshtml 文件允许你同时写 C# 代码和 html 标签。<br>Views 文件夹包含每个控制器的单独的文件夹，例如 HomeController 对于 Views/Home 文件夹。</p><p>Shared 文件夹用来容纳不同控制器共享的视图。如: _Layout.cshtml。</p><h3 id="Global-asax"><a href="#Global-asax" class="headerlink" title="Global.asax"></a>Global.asax</h3><p>Global.asax 允许编写应用级事件，如: Application_BeginRequest，Application_Start，Application_Error，Session_Start，Session_End 等。</p><h3 id="Packages-config"><a href="#Packages-config" class="headerlink" title="Packages.config"></a>Packages.config</h3><p>NuGet 的包管理文件。</p><h3 id="Web-config"><a href="#Web-config" class="headerlink" title="Web.config"></a>Web.config</h3><p>Web.config 包含应用级的配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从这篇开始，我们来谈谈 ASP.Net MVC，我们将会介绍 ASP.Net MVC 的方方面面(包括基础以及高级特性)。&lt;/p&gt;
&lt;h2 id=&quot;MVC-架构&quot;&gt;&lt;a href=&quot;#MVC-架构&quot; class=&quot;headerlink&quot; title=&quot;MVC 架构&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/ASP.Net%20MVC(%E4%BA%8C)/"/>
    <id>https://1ess.github.io/ASP.Net%20MVC(%E4%BA%8C)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们来详细讲讲关于 ASP.Net MVC 中的路由。</p><h2 id="ASP-Net-MVC-中的路由"><a href="#ASP-Net-MVC-中的路由" class="headerlink" title="ASP.Net MVC 中的路由"></a>ASP.Net MVC 中的路由</h2><hr><p>在 Web Form 应用，每个 URL 必须匹配一个 .aspx 物理文件，如: <a href="http://domain/bar.aspx">http://domain/bar.aspx</a> 必须有一个用于响应渲染的文件 bar.aspx。<br>ASP.Net MVC 则通过引入 Routing 来消除必须使用物理文件映射 URL 的弊端。<br>路由使我们能够定义映射到请求处理程序的 URL 模式。请求处理程序在 WebForm 中是 .aspx 文件，在 MVC 中是 Controller 以及 Action 方法。<br>例如: <a href="http://domain/foo">http://domain/foo</a> </p><ul><li>在 WebForm 中映射为 foo.aspx 文件</li><li>在 MVC 中映射为 FooController 以及 Index 方法。</li></ul><h2 id="路由处理过程"><a href="#路由处理过程" class="headerlink" title="路由处理过程"></a>路由处理过程</h2><hr><p>Route 定义了 URL 模式，应用所有的配置路由存储在 RouteTable ，然后通过路由引擎确定传入请求的适当处理程序类。</p><p>处理过程:<br>URL Request 经过 Route Engine，判断 URL 是否匹配 RouteTable 中 URL 模式，如果不匹配，直接返回 404 Error，如果匹配，则经过对应的 Controller 和 Action 处理，返回响应。</p><h2 id="配置一个路由"><a href="#配置一个路由" class="headerlink" title="配置一个路由"></a>配置一个路由</h2><hr><p>每个应用至少配置或者说注册一个路由(MVC 默认为我们注册了一个)，我们可以在 App_Start 文件夹下的 RouteConfig 类中注册路由: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RouteConfig</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterRoutes</span>(<span class="hljs-params">RouteCollection routes</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//忽略路由</span><br>        routes.IgnoreRoute(<span class="hljs-string">&quot;&#123;resource&#125;.axd/&#123;*pathInfo&#125;&quot;</span>);<br>            <br>        routes.MapRoute(<br>            name: <span class="hljs-string">&quot;Default&quot;</span>,  <span class="hljs-comment">//路由名称</span><br>            url: <span class="hljs-string">&quot;&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;&quot;</span>, <span class="hljs-comment">//URL 模式</span><br>            defaults: <span class="hljs-keyword">new</span> &#123; controller = <span class="hljs-string">&quot;Home&quot;</span>, action = <span class="hljs-string">&quot;Index&quot;</span>, id = UrlParameter.Optional &#125; <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RouteConfig</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterRoutes</span>(<span class="hljs-params">RouteCollection routes</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//忽略路由</span><br>        routes.IgnoreRoute(<span class="hljs-string">&quot;&#123;resource&#125;.axd/&#123;*pathInfo&#125;&quot;</span>);<br>            <br>        routes.MapRoute(<br>            name: <span class="hljs-string">&quot;Default&quot;</span>,  <span class="hljs-comment">//路由名称</span><br>            url: <span class="hljs-string">&quot;&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;&quot;</span>, <span class="hljs-comment">//URL 模式</span><br>            defaults: <span class="hljs-keyword">new</span> &#123; controller = <span class="hljs-string">&quot;Home&quot;</span>, action = <span class="hljs-string">&quot;Index&quot;</span>, id = UrlParameter.Optional &#125; <span class="hljs-comment">//默认路由</span><br>        );<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="URL-模式"><a href="#URL-模式" class="headerlink" title="URL 模式"></a>URL 模式</h3><p>我们上面一直说 URL 模式，那什么是 URL 模式呢?<br>URL 模式指域名及端口之后的 URL 部分。<br>如果域名之后什么都没有，那么默认路由将会处理请求。</p><h3 id="多路由"><a href="#多路由" class="headerlink" title="多路由"></a>多路由</h3><p>我们可以使用 RouteCollection 的扩展方法 MapRoute()，来配置其他路由。<br>name 和 url 参数是必须的，defaults 参数是可选的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RouteConfig</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterRoutes</span>(<span class="hljs-params">RouteCollection routes</span>)</span><br>    &#123;<br>        routes.IgnoreRoute(<span class="hljs-string">&quot;&#123;resource&#125;.axd/&#123;*pathInfo&#125;&quot;</span>);<br><br>        routes.MapRoute(<br>            name: <span class="hljs-string">&quot;Foo&quot;</span>,<br>            url: <span class="hljs-string">&quot;foo/&#123;id&#125;&quot;</span>,<br>            defaults: <span class="hljs-keyword">new</span> &#123; controller = <span class="hljs-string">&quot;Foo&quot;</span>, action = <span class="hljs-string">&quot;Index&quot;</span>&#125;<br>        );<br><br>        routes.MapRoute(<br>            name: <span class="hljs-string">&quot;Default&quot;</span>,<br>            url: <span class="hljs-string">&quot;&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;&quot;</span>,<br>            defaults: <span class="hljs-keyword">new</span> &#123; controller = <span class="hljs-string">&quot;Home&quot;</span>, action = <span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RouteConfig</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterRoutes</span>(<span class="hljs-params">RouteCollection routes</span>)</span><br>    &#123;<br>        routes.IgnoreRoute(<span class="hljs-string">&quot;&#123;resource&#125;.axd/&#123;*pathInfo&#125;&quot;</span>);<br><br>        routes.MapRoute(<br>            name: <span class="hljs-string">&quot;Foo&quot;</span>,<br>            url: <span class="hljs-string">&quot;foo/&#123;id&#125;&quot;</span>,<br>            defaults: <span class="hljs-keyword">new</span> &#123; controller = <span class="hljs-string">&quot;Foo&quot;</span>, action = <span class="hljs-string">&quot;Index&quot;</span>&#125;<br>        );<br><br>        routes.MapRoute(<br>            name: <span class="hljs-string">&quot;Default&quot;</span>,<br>            url: <span class="hljs-string">&quot;&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;&quot;</span>,<br>            defaults: <span class="hljs-keyword">new</span> &#123; controller = <span class="hljs-string">&quot;Home&quot;</span>, action = <span class="hljs-string">"Index"</span>, id = UrlParameter.Optional &#125;<br>        );<br>    &#125;<br>&#125; <br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>上面的代码显示: 以 domain/foo 开头的 url 必须经过 FooController 处理，并且这个模式无须指定 action，因为总要使用 index 方法。<br>MVC 会评估每个路由，从第一个配置路由开始，如果传入的 URL 不满足 URL 模式，将会开始评估第二个路由，直到找到匹配路由。</p><p>注意:<br><a href="http://localhost/foo/123">http://localhost/foo/123</a> 和 <a href="http://localhost/foo?Id=123">http://localhost/foo?Id=123</a> 都将匹配 Foo 路由。</p><h2 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h2><hr><p>我们在 RouteConfig 配置路由之后，需要在 Global.asax 文件的 Application_Start 方法注册路由: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Application_Start</span>(<span class="hljs-params"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Application_Start</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    RouteConfig.RegisterRoutes(RouteTable.Routes);<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们来详细讲讲关于 ASP.Net MVC 中的路由。&lt;/p&gt;
&lt;h2 id=&quot;ASP-Net-MVC-中的路由&quot;&gt;&lt;a href=&quot;#ASP-Net-MVC-中的路由&quot; class=&quot;headerlink&quot; title=&quot;ASP.Net MVC 中的路由&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/ASP.Net%20MVC(%E4%B8%89)/"/>
    <id>https://1ess.github.io/ASP.Net%20MVC(%E4%B8%89)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们具体说说 Controller、Model 和 View。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><hr><p>在 MVC 中，Controller 是用来处理用户请求的。Controller 是一个类，继承自 System.Web.Mvc.Controller。<br>控制器类中访问修饰符为 public 的方法称为 Action 方法。<br>Controller 和 Action 方法一起，用来处理来自客户端的请求，检索必要的模型数据并返回适当的响应。<br>在 ASP.Net MVC 中，每个控制器类名称必须以 Controller 结尾，此外，每个控制器类必须位于 MVC 文件夹结构的 Controllers 文件夹中。</p><h3 id="Action-方法"><a href="#Action-方法" class="headerlink" title="Action 方法"></a>Action 方法</h3><p>Action 方法的特征: </p><ul><li>Action 方法必须是 public，不能是 private 或 protected</li><li>Action 方法不能 overloaded</li><li>Action 方法不能是 static 方法</li></ul><h3 id="默认-Action-方法"><a href="#默认-Action-方法" class="headerlink" title="默认 Action 方法"></a>默认 Action 方法</h3><p>每个 Controller 都有默认的 Action 方法定义在 RouteConfig 类中。</p><h3 id="ActionResult-类型"><a href="#ActionResult-类型" class="headerlink" title="ActionResult 类型"></a>ActionResult 类型</h3><p>Action 方法一般需要返回 ActionResult 类型的返回值。<br>View() 方法就是定义在基类中 Controller 中，返回 ActionResult 类型。<br>MVC 框架包括各种可以被 Action 方法返回的 result 类型。result 类型表示不同类型的响应，如: HTML，file，string，Json，JavaScript 等。</p><table><thead><tr><th>Result 类型</th><th>描述</th><th>Base Controller 方法</th></tr></thead><tbody><tr><td>ViewResult</td><td>返回 HTML</td><td>View()</td></tr><tr><td>EmptyResult</td><td>什么都不返回</td><td></td></tr><tr><td>ContentResult</td><td>返回字符串</td><td>Content()</td></tr><tr><td>FileContentResult</td><td>返回文件内容</td><td>File()</td></tr><tr><td>JavaScriptResult</td><td>返回 JS</td><td>JavaScript()</td></tr><tr><td>JsonResult</td><td>返回 JSON</td><td>Json()</td></tr><tr><td>RedirectResult</td><td>重定向新的 url</td><td>Redirect()</td></tr><tr><td>RedirectToRouteResult</td><td>重定向其他的 Action</td><td>RedirectToAction()</td></tr><tr><td>HttpUnauthorizedResult</td><td>返回 HTTP 403 status</td><td></td></tr></tbody></table><p>ActionResult 类是所有上述结果类的基类。</p><h3 id="Action-Selectors"><a href="#Action-Selectors" class="headerlink" title="Action Selectors"></a>Action Selectors</h3><p>Action Selectors 是应用于 Action 方法的 attribute。<br>Action Selectors 有助于路由引擎选择正确的操作方法来处理特定请求。<br>MVC 5 包括如下 action selector attributes:</p><ul><li>ActionName</li><li>NonAction</li><li>ActionVerbs</li></ul><h4 id="ActionName"><a href="#ActionName" class="headerlink" title="ActionName"></a>ActionName</h4><p>ActionName 允许我们指定与 Action 的名称不同的操作名称。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooController</span> : <span class="hljs-title">Controller</span><br>&#123;<br>    [<span class="hljs-meta">ActionName(<span class="hljs-meta-string">&quot;bar&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooController</span> : <span class="hljs-title">Controller</span><br>&#123;<br>    [<span class="hljs-meta">ActionName(<span class="hljs-meta-string">&quot;bar&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> View();<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>上面的例子，我们应发送 <a href="http://localhost/foo/bar/1">http://localhost/foo/bar/1</a> 而不是 <a href="http://localhost/foo/foo/1%E3%80%82">http://localhost/foo/foo/1。</a></p><h4 id="NonAction"><a href="#NonAction" class="headerlink" title="NonAction"></a>NonAction</h4><p>NonAction selector attribute 指示 Controller 的公共方法不是 Action 方法。<br>如果需要控制器中的公共方法但不希望将其视为 Action 方法，就需要使用 NonAction attribute。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooController</span> : <span class="hljs-title">Controller</span><br>&#123;  <br>    [<span class="hljs-meta">NonAction</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bar <span class="hljs-title">GetBar</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123; <br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooController</span> : <span class="hljs-title">Controller</span><br>&#123;  <br>    [<span class="hljs-meta">NonAction</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bar <span class="hljs-title">GetBar</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123; <br>        <span class="hljs-keyword">return</span> barList.FirstOrDefault(s => s.Id == id);<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="ActionVerbs-行为动词"><a href="#ActionVerbs-行为动词" class="headerlink" title="ActionVerbs(行为动词)"></a>ActionVerbs(行为动词)</h4><p>控制 Action 方法所使用的 HTTP 方法，需要使用 ActionVerbs。<br>如: 我们可以使用相同的 ActionName 定义两个不同的操作方法，一个操作方法响应 HTTP Get 请求，另一个操作方法响应 HTTP Post 请求。</p><p>ActionVerbs 包括:<br>HttpGet，HttpPost，HttpPut，HttpDelete，HttpPatch，HttpOptions，HttpHead<br>我们也可以使用 AcceptVerbs attribute 接受多个 HttpVerbs，如: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">AcceptVerbs(HttpVerbs.Post | HttpVerbs.Get)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">GetAndPostMethod</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> RedirectToAction(<span class="hljs-string"><code class="language-hljs csharp">[<span class="hljs-meta">AcceptVerbs(HttpVerbs.Post | HttpVerbs.Get)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">GetAndPostMethod</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> RedirectToAction(<span class="hljs-string">"Index"</span>);<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><hr><p>Model 表示 MVC 架构中的域特定数据和业务逻辑。<br>模型类在公共属性中保存数据。所有 Model 类都保存在 Models 文件夹中。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><hr><p>View 是一个用户界面。 View 将模型中的数据显示给用户，并使他们能够修改数据。<br>视图存储在 Views文件夹中。</p><p>单个控制器类的不同 Action 方法可以呈现不同的视图，因此 Views 文件夹包含每个控制器的单独文件夹，其名称与控制器相同。View 文件名与 Action 方法同名。</p><h3 id="Razor-View-Engine"><a href="#Razor-View-Engine" class="headerlink" title="Razor View Engine"></a>Razor View Engine</h3><p>Microsoft 在 MVC 3 中推出了 Razor 视图引擎，我们可以在 Razor 视图混合写服务端代码和 html 标签 。<br>Razor 使用 @ 字符来编写服务端代码， Razor 视图以 .cshtml 作为后缀。</p><p>之后我们会详细介绍 Razor 语法，这里我们先看看其他重要的概念。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>最佳实践是使得视图名与 Action 方法同名，使得当我们返回 View 时无需传递路径作为参数。<br>ASP.NET MVC 中的每个视图都派生自 System.Web.Mvc 命名空间中的 WebViewPage 类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们具体说说 Controller、Model 和 View。&lt;/p&gt;
&lt;h2 id=&quot;Controller&quot;&gt;&lt;a href=&quot;#Controller&quot; class=&quot;headerlink&quot; title=&quot;Controller&quot;&gt;&lt;/a&gt;Controller&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/ASP.Net%20MVC(%E5%9B%9B)/"/>
    <id>https://1ess.github.io/ASP.Net%20MVC(%E5%9B%9B)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们来详细说说 ASP.Net MVC 中特别重要的 Model Binding。</p><p>传统的 ASP.Net MVC 中，如果我们想在 Action 方法中获取请求参数，我们使用 Request.QueryString 和 Request 对象。非常笨重!</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">//Get /Foo/Bar?id=1</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> id = Request.QueryString[<span class="hljs-string">&quot;id&quot;</span>];<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> View();<br>&#125;<br><br><span class="hljs-comment">// Post /Foo/Bar</span><br>[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> id = Request[<span class="hljs-string">&quot;id&quot;</span>];<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment">//Get /Foo/Bar?id=1</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> id = Request.QueryString[<span class="hljs-string">&quot;id&quot;</span>];<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> View();<br>&#125;<br><br><span class="hljs-comment">// Post /Foo/Bar</span><br>[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> id = Request[<span class="hljs-string">&quot;id&quot;</span>];<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> View();<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>通过模型绑定，MVC 将 http 请求值(从查询字符串或表单集合)转换为 Action 方法的参数。这些参数可以是原始类型或复杂类型。</p><h3 id="基本类型的绑定"><a href="#基本类型的绑定" class="headerlink" title="基本类型的绑定"></a>基本类型的绑定</h3><p>Get 请求的将数据嵌入 QueryString，MVC 自动将 QueryString 转换为 Action 方法参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">// 以下 Get 请求中的 QueryString  id 将自动映射到 Bar 方法的 id 参数</span><br><span class="hljs-comment">// /Foo/Bar?id=1</span><br><span class="hljs-comment">// /Foo/Bar/1</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-comment">// 以下 Get 请求中的 QueryString  id 将自动映射到 Bar 方法的 id 参数</span><br><span class="hljs-comment">// /Foo/Bar?id=1</span><br><span class="hljs-comment">// /Foo/Bar/1</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们还可以在 Action 方法中使用不同数据类型的多个参数。QueryString 的值将根据匹配名称转换为参数。<br>注意: 绑定是不区分大小写的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">// /Foo/Bar?id=1&amp;name=1ess 或者(/Foo/Bar?Id=1&amp;Name=1ess)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> name</span>)</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-comment">// /Foo/Bar?id=1&amp;name=1ess 或者(/Foo/Bar?Id=1&amp;Name=1ess)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> name</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="复杂类型的绑定"><a href="#复杂类型的绑定" class="headerlink" title="复杂类型的绑定"></a>复杂类型的绑定</h3><p>MVC 中的模型绑定自动将 Post 请求的表单字段数据转换为 Action 方法的复杂类型参数的属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Guid id &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>&#125;<br>[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params">Person person</span>)</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Guid id &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>&#125;<br>[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params">Person person</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们还可以使用 Bind attribute 指定模型在绑定中应包含或排除的确切属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params">[Bind(Include = <span class="hljs-string">&quot;id, name&quot;</span></span>)] Person person)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br>[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Foo</span>(<span class="hljs-params">[Bind(Exclude= <span class="hljs-string">&quot;id&quot;</span></span>)] Person person)</span><br>&#123;<br>    <span class="hljs-comment"><code class="language-hljs csharp">[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Bar</span>(<span class="hljs-params">[Bind(Include = <span class="hljs-string">&quot;id, name&quot;</span></span>)] Person person)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br>[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Foo</span>(<span class="hljs-params">[Bind(Exclude= <span class="hljs-string">&quot;id&quot;</span></span>)] Person person)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>Bind attribute 可以提高性能。<br>.Net Framework MVC 的模型绑定只要记住如下原则: </p><ul><li>Get 请求总在 Query 绑定</li><li>Post 请求总在 Body 绑定</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们来详细说说 ASP.Net MVC 中特别重要的 Model Binding。&lt;/p&gt;
&lt;p&gt;传统的 ASP.Net MVC 中，如果我们想在 Action 方法中获取请求参数，我们使用 Request.QueryString 和 Request 对象。非常笨重</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/ASP.Net%20MVC(%E4%BA%94)/"/>
    <id>https://1ess.github.io/ASP.Net%20MVC(%E4%BA%94)/</id>
    <published>2021-07-14T12:51:57.447Z</published>
    <updated>2021-07-14T12:51:57.447Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们再来详细说说 ASP.Net MVC 中的 Razor 语法。</p><h3 id="什么是-Razor"><a href="#什么是-Razor" class="headerlink" title="什么是 Razor"></a>什么是 Razor</h3><p>Razor 是 ASP.Net MVC 中支持的视图引擎，它允许我们混写服务端代码如 C#、VB 等和 HTML 标签，如果使用 C#，那么文件以 .cshtml 作为后缀。</p><p>下面我们具体来讲解 C# Razor 语法。</p><h3 id="单行表达式"><a href="#单行表达式" class="headerlink" title="单行表达式"></a>单行表达式</h3><p>以 @ 符号开始，在 .cshtml 文件中开始写服务端代码。如下: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp"><h2>Razor Syntax</h2><br><h2>@DateTime.Now.ToShortDateString()</h2><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 在单行表达式在表达式的末尾不需要分号。</p><h3 id="多行语句代码块"><a href="#多行语句代码块" class="headerlink" title="多行语句代码块"></a>多行语句代码块</h3><p>如果要写多行服务端代码，必须写在 @{…} 中，服务端代码每行的末尾以分号结束。在代码块中声明的变量，之后可以用 @variable 来使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">@&#123;<br>    <span class="hljs-keyword">var</span> date = DateTime.Now.ToShortDateString();<br>    <span class="hljs-keyword">var</span> msg = <span class="hljs-string"><code class="language-hljs csharp">@&#123;<br>    <span class="hljs-keyword">var</span> date = DateTime.Now.ToShortDateString();<br>    <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"Hello Razor!"</span>;<br>&#125;<br><br><h1>@msg</h1><br><h2>@date</h2><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="代码块中展示文本"><a href="#代码块中展示文本" class="headerlink" title="代码块中展示文本"></a>代码块中展示文本</h3><p>如果想在 @{…} 中展示文本，需要使用 @: 或者 &lt;text&gt;&lt;/text&gt; 标记: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">@&#123;<br>    <span class="hljs-keyword">var</span> date = DateTime.Now.ToShortDateString();<br>    <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;Hello Razor!&quot;</span>;<br>    @: Today <span class="hljs-keyword">is</span> @date. &lt;br&gt;<br>    @msg<br>&#125;<br><br>@&#123;<br>    <span class="hljs-keyword">var</span> date = DateTime.Now.ToShortDateString();<br>    <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;Hello Razor!&quot;</span>;<br>    &lt;text&gt;Today <span class="hljs-keyword"><code class="language-hljs csharp">@&#123;<br>    <span class="hljs-keyword">var</span> date = DateTime.Now.ToShortDateString();<br>    <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;Hello Razor!&quot;</span>;<br>    @: Today <span class="hljs-keyword">is</span> @date. &lt;br&gt;<br>    @msg<br>&#125;<br><br>@&#123;<br>    <span class="hljs-keyword">var</span> date = DateTime.Now.ToShortDateString();<br>    <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;Hello Razor!&quot;</span>;<br>    &lt;text&gt;Today <span class="hljs-keyword">is</span></text> @date.<br><br>    @msg<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 Razor 中可以使用条件语句 if-else，但是必须以 @ 开头，语句内容必须包裹在代码块{…}中: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">@if(DateTime.IsLeapYear(DateTime.Now.Year)) &#123;<br>    @DateTime.Now.Year @: <span class="hljs-keyword">is</span> leap year.<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    @DateTime.Now.Year @: <span class="hljs-keyword">is</span> <span class="hljs-keyword"><code class="language-hljs csharp">@if(DateTime.IsLeapYear(DateTime.Now.Year)) &#123;<br>    @DateTime.Now.Year @: <span class="hljs-keyword">is</span> leap year.<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    @DateTime.Now.Year @: <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> leap year.<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp">@for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number"><code class="language-hljs csharp">@for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    @i.ToString() <br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>我们可以使用 @model 在视图中使用模型对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class="line-numbers language-hljs csharp"><code class="language-hljs csharp">@model Student<br><h2>@Model.Age</h2><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们再来详细说说 ASP.Net MVC 中的 Razor 语法。&lt;/p&gt;
&lt;h3 id=&quot;什么是-Razor&quot;&gt;&lt;a href=&quot;#什么是-Razor&quot; class=&quot;headerlink&quot; title=&quot;什么是 Razor&quot;&gt;&lt;/a&gt;什么是 Razor&lt;/h3&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
