<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Sort Of A Blog</title>
  
  
  <link href="https://1ess.github.io/atom.xml" rel="self"/>
  
  <link href="https://1ess.github.io/"/>
  <updated>2021-07-14T12:57:47.824Z</updated>
  <id>https://1ess.github.io/</id>
  
  <author>
    <name>Stephen Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/LinQ%20%E6%9F%A5%E8%AF%A2%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://1ess.github.io/LinQ%20%E6%9F%A5%E8%AF%A2%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>最近的工作是对一个复杂数据库进行操作，模型类之间的关系很复杂。操作方式使用了 LINQ，之前一直对 LINQ 的查询语法不太喜欢，这次使用之后，感觉比方法语法更容易接受，因此详细总结一下查询表达式的语法。</p><p>数据查询历来都表示为简单的字符串，没有编译时类型检查。 此外，对于每种数据源，还需要学习不同的查询语言: SQL 数据库、XML 文档以及各种 Web 服务等。借助 LINQ，查询成为了最高级的语言构造，就像类、方法和事件一样。</p><p>LINQ 最明显的”语言集成”部分就是查询表达式。 使用相同的基本查询表达式模式来查询和转换 SQL 数据库、ADO .NET 数据集、XML 文档以及 .NET 集合中的数据。<br>从应用程序的角度来看，原始源数据的特定类型和结构并不重要。应用程序始终将源数据视为 IEnumerable<T> 或 IQueryable<T> 集合。 </p><p>对于源序列，查询可能会执行三种操作之一: </p><ul><li>检索元素的子集以生成新序列，而不修改各个元素</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">// scores 是 int[]</span><br>IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; highScoresQuery =<br>    <span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores<br>    <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span><br>    <span class="hljs-keyword">orderby</span> score <span class="hljs-keyword">descending</span><br>    <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment">// scores 是 int[]</span><br>IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; highScoresQuery =<br>    <span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores<br>    <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span><br>    <span class="hljs-keyword">orderby</span> score <span class="hljs-keyword">descending</span><br>    <span class="hljs-keyword">select</span> score;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>将序列转换为新类型的对象</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; highScoresQuery2 =<br>    <span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores<br>    <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span><br>    <span class="hljs-keyword">orderby</span> score <span class="hljs-keyword">descending</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-string">$&quot;The score is <span class="hljs-subst"><code class="language-hljs csharp">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; highScoresQuery2 =<br>    <span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores<br>    <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span><br>    <span class="hljs-keyword">orderby</span> score <span class="hljs-keyword">descending</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-string">$&quot;The score is <span class="hljs-subst">&#123;score&#125;</span>"</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>检索有关源数据的单独值</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">int</span> highScoreCount =<br>    (<span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores<br>     <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span><br>     <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-built_in">int</span> highScoreCount =<br>    (<span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores<br>     <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span><br>     <span class="hljs-keyword">select</span> score)<br>     .Count();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="查询表达式是什么"><a href="#查询表达式是什么" class="headerlink" title="查询表达式是什么"></a>查询表达式是什么</h3><p>查询表达式是以查询语法表示的查询。 </p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>查询表达式必须以 from 子句开头，且必须以 select 或 group 子句结尾。 在第一个 from 子句与最后一个 select 或 group 子句之间，可以包含以下这些可选子句中的一个或多个: where、orderby、join、let 甚至是其他 from 子句。 还可以使用 into 关键字，使 join 或 group 子句的结果可以充当相同查询表达式中的其他查询子句的源。</p><h3 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h3><p>在 LINQ 中，查询变量是存储查询而不是查询结果的任何变量。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">// Query Expression.</span><br>    IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; scoreQuery = <span class="hljs-comment">//query variable</span><br>        <span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores <span class="hljs-comment">//required</span><br>        <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span> <span class="hljs-comment">// optional</span><br>        <span class="hljs-keyword">orderby</span> score <span class="hljs-keyword">descending</span> <span class="hljs-comment">// optional</span><br>        <span class="hljs-keyword">select</span> score; <span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-comment">// Query Expression.</span><br>    IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; scoreQuery = <span class="hljs-comment">//query variable</span><br>        <span class="hljs-keyword">from</span> score <span class="hljs-keyword">in</span> scores <span class="hljs-comment">//required</span><br>        <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">80</span> <span class="hljs-comment">// optional</span><br>        <span class="hljs-keyword">orderby</span> score <span class="hljs-keyword">descending</span> <span class="hljs-comment">// optional</span><br>        <span class="hljs-keyword">select</span> score; <span class="hljs-comment">//must end with select or group</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>上面的示例中，scoreQuery 是查询变量，它有时仅仅称为查询。 </p><p>查询变量可以存储采用查询语法、方法语法或是两者的组合进行表示的查询。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">//Query syntax</span><br>IEnumerable&lt;City&gt; queryMajorCities =<br>    <span class="hljs-keyword">from</span> city <span class="hljs-keyword">in</span> cities<br>    <span class="hljs-keyword">where</span> city.Population &gt; <span class="hljs-number">100000</span><br>    <span class="hljs-keyword">select</span> city;<br><br><span class="hljs-comment">// Method-based syntax</span><br>IEnumerable&lt;City&gt; queryMajorCities2 = cities.Where(c =&gt; c.Population &gt; <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-comment">//Query syntax</span><br>IEnumerable&lt;City&gt; queryMajorCities =<br>    <span class="hljs-keyword">from</span> city <span class="hljs-keyword">in</span> cities<br>    <span class="hljs-keyword">where</span> city.Population &gt; <span class="hljs-number">100000</span><br>    <span class="hljs-keyword">select</span> city;<br><br><span class="hljs-comment">// Method-based syntax</span><br>IEnumerable&lt;City&gt; queryMajorCities2 = cities.Where(c =&gt; c.Population &gt; <span class="hljs-number">100000</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="开始查询表达式"><a href="#开始查询表达式" class="headerlink" title="开始查询表达式"></a>开始查询表达式</h3><p>查询表达式必须以 from 子句开头，它指定数据源以及范围变量，范围变量表示遍历源序列时，源序列中的每个连续元素。范围变量基于数据源中元素的类型进行强类型化。<br>因为范围变量是强类型，所以可以使用点运算符访问该类型的任何可用成员。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">IEnumerable&lt;Country&gt; countryAreaQuery =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">where</span> country.Area &gt; <span class="hljs-number">500000</span> <span class="hljs-comment">//sq km</span><br>    <span class="hljs-keyword"><code class="language-hljs csharp">IEnumerable&lt;Country&gt; countryAreaQuery =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">where</span> country.Area &gt; <span class="hljs-number">500000</span> <span class="hljs-comment">//sq km</span><br>    <span class="hljs-keyword">select</span> country;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>查询表达式可能会包含多个 from 子句。在源序列中的每个元素本身是集合或包含集合时，可使用其他 from 子句。 </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">IEnumerable&lt;City&gt; cityQuery =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">from</span> city <span class="hljs-keyword">in</span> country.Cities<br>    <span class="hljs-keyword">where</span> city.Population &gt; <span class="hljs-number">10000</span><br>    <span class="hljs-keyword"><code class="language-hljs csharp">IEnumerable&lt;City&gt; cityQuery =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">from</span> city <span class="hljs-keyword">in</span> country.Cities<br>    <span class="hljs-keyword">where</span> city.Population &gt; <span class="hljs-number">10000</span><br>    <span class="hljs-keyword">select</span> city;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="结束查询表达式"><a href="#结束查询表达式" class="headerlink" title="结束查询表达式"></a>结束查询表达式</h3><p>查询表达式必须以 group 子句或 select 子句结尾。</p><h4 id="group-子句"><a href="#group-子句" class="headerlink" title="group 子句"></a>group 子句</h4><p>使用 group 子句可生成按指定键组织的组的序列。键可以是任何数据类型。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">var</span> queryCountryGroups =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">group</span> country <span class="hljs-keyword">by</span> country.Name[<span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-keyword">var</span> queryCountryGroups =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">group</span> country <span class="hljs-keyword">by</span> country.Name[<span class="hljs-number">0</span>];<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="select-子句"><a href="#select-子句" class="headerlink" title="select 子句"></a>select 子句</h4><p>使用 select 子句可生成所有其他类型的序列。简单 select 子句只生成类型与数据源中包含的对象相同的对象的序列。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">IEnumerable&lt;Country&gt; sortedQuery =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">orderby</span> country.Area<br>    <span class="hljs-keyword"><code class="language-hljs csharp">IEnumerable&lt;Country&gt; sortedQuery =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">orderby</span> country.Area<br>    <span class="hljs-keyword">select</span> country;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>select 子句可以用于将源数据转换为新类型的序列，此转换也称为投影。<br>请注意，新对象使用对象初始值设定项进行初始化。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">// Here var is required because the query</span><br><span class="hljs-comment">// produces an anonymous type.</span><br><span class="hljs-keyword">var</span> queryNameAndPop =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment">// Here var is required because the query</span><br><span class="hljs-comment">// produces an anonymous type.</span><br><span class="hljs-keyword">var</span> queryNameAndPop =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span> &#123; Name = country.Name, Pop = country.Population &#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="使用-into-进行延续"><a href="#使用-into-进行延续" class="headerlink" title="使用 into 进行延续"></a>使用 into 进行延续</h3><p>可以在 select 或 group 子句中使用 into 关键字创建存储查询的临时标识符。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment">// percentileQuery is an IEnumerable&lt;IGrouping&lt;int, Country&gt;&gt;</span><br><span class="hljs-keyword">var</span> percentileQuery =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">let</span> percentile = (<span class="hljs-built_in">int</span>) country.Population / <span class="hljs-number">10</span>_000_000<br>    <span class="hljs-keyword">group</span> country <span class="hljs-keyword">by</span> percentile <span class="hljs-keyword">into</span> countryGroup<br>    <span class="hljs-keyword">where</span> countryGroup.Key &gt;= <span class="hljs-number">20</span><br>    <span class="hljs-keyword">orderby</span> countryGroup.Key<br>    <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment">// percentileQuery is an IEnumerable&lt;IGrouping&lt;int, Country&gt;&gt;</span><br><span class="hljs-keyword">var</span> percentileQuery =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">let</span> percentile = (<span class="hljs-built_in">int</span>) country.Population / <span class="hljs-number">10</span>_000_000<br>    <span class="hljs-keyword">group</span> country <span class="hljs-keyword">by</span> percentile <span class="hljs-keyword">into</span> countryGroup<br>    <span class="hljs-keyword">where</span> countryGroup.Key &gt;= <span class="hljs-number">20</span><br>    <span class="hljs-keyword">orderby</span> countryGroup.Key<br>    <span class="hljs-keyword">select</span> countryGroup;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="筛选、排序和联接"><a href="#筛选、排序和联接" class="headerlink" title="筛选、排序和联接"></a>筛选、排序和联接</h3><p>在开头 from 子句与结尾 select 或 group 子句之间，所有其他子句(where、join、orderby、from、let)都是可选的。任何可选子句都可以在查询正文中使用零次或多次。</p><h4 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h4><p>使用 where 子句可基于一个或多个谓词表达式，从源数据中筛选出元素。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">IEnumerable&lt;City&gt; queryCityPop =<br>    <span class="hljs-keyword">from</span> city <span class="hljs-keyword">in</span> cities<br>    <span class="hljs-keyword">where</span> city.Population &lt; <span class="hljs-number">200000</span> &amp;&amp; city.Population &gt; <span class="hljs-number">100000</span><br>    <span class="hljs-keyword"><code class="language-hljs csharp">IEnumerable&lt;City&gt; queryCityPop =<br>    <span class="hljs-keyword">from</span> city <span class="hljs-keyword">in</span> cities<br>    <span class="hljs-keyword">where</span> city.Population &lt; <span class="hljs-number">200000</span> &amp;&amp; city.Population &gt; <span class="hljs-number">100000</span><br>    <span class="hljs-keyword">select</span> city;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="orderby-子句"><a href="#orderby-子句" class="headerlink" title="orderby 子句"></a>orderby 子句</h4><p>使用 orderby 子句可按升序或降序对结果进行排序。还可以指定次要排序顺序。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">IEnumerable&lt;Country&gt; querySortedCountries =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">orderby</span> country.Area, country.Population <span class="hljs-keyword">descending</span><br>    <span class="hljs-keyword"><code class="language-hljs csharp">IEnumerable&lt;Country&gt; querySortedCountries =<br>    <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries<br>    <span class="hljs-keyword">orderby</span> country.Area, country.Population <span class="hljs-keyword">descending</span><br>    <span class="hljs-keyword">select</span> country;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: ascending 关键字是可选的，如果未指定任何顺序，则它是默认排序顺序。</p><h4 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h4><p>使用 join 子句可基于每个元素中指定的键之间的相等比较，将一个数据源中的元素与另一个数据源中的元素进行关联和/或合并。在 LINQ 中，联接操作是对元素属于不同类型的对象序列执行。联接了两个序列之后，必须使用 select 或 group 语句指定要存储在输出序列中的元素，还可以使用匿名类型将每组关联元素中的属性合并到输出序列的新类型中。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">var</span> categoryQuery =<br>    <span class="hljs-keyword">from</span> cat <span class="hljs-keyword">in</span> categories<br>    <span class="hljs-keyword">join</span> prod <span class="hljs-keyword">in</span> products <span class="hljs-keyword">on</span> cat <span class="hljs-keyword">equals</span> prod.Category<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">var</span> categoryQuery =<br>    <span class="hljs-keyword">from</span> cat <span class="hljs-keyword">in</span> categories<br>    <span class="hljs-keyword">join</span> prod <span class="hljs-keyword">in</span> products <span class="hljs-keyword">on</span> cat <span class="hljs-keyword">equals</span> prod.Category<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span> &#123; Category = cat, Name = prod.Name &#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>还可以通过使用 into 关键字将 join 操作的结果存储到临时变量中来执行分组联接。 </p><h4 id="let-子句"><a href="#let-子句" class="headerlink" title="let 子句"></a>let 子句</h4><p>使用 let 子句可将表达式(如方法调用)的结果存储在新范围变量中。 </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-built_in">string</span>[] names = &#123; <span class="hljs-string">&quot;Svetlana Omelchenko&quot;</span>, <span class="hljs-string">&quot;Claire O&#x27;Donnell&quot;</span>, <span class="hljs-string">&quot;Sven Mortensen&quot;</span>, <span class="hljs-string">&quot;Cesar Garcia&quot;</span> &#125;;<br>IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; queryFirstNames =<br>    <span class="hljs-keyword">from</span> name <span class="hljs-keyword">in</span> names<br>    <span class="hljs-keyword">let</span> firstName = name.Split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-built_in">string</span>[] names = &#123; <span class="hljs-string">&quot;Svetlana Omelchenko&quot;</span>, <span class="hljs-string">&quot;Claire O&#x27;Donnell&quot;</span>, <span class="hljs-string">&quot;Sven Mortensen&quot;</span>, <span class="hljs-string">&quot;Cesar Garcia&quot;</span> &#125;;<br>IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; queryFirstNames =<br>    <span class="hljs-keyword">from</span> name <span class="hljs-keyword">in</span> names<br>    <span class="hljs-keyword">let</span> firstName = name.Split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">select</span> firstName;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="查询表达式中的子查询"><a href="#查询表达式中的子查询" class="headerlink" title="查询表达式中的子查询"></a>查询表达式中的子查询</h3><p>查询子句本身可能包含查询表达式，这有时称为子查询。每个子查询都以自己的 from 子句开头，该子句不一定指向第一个 from 子句中的相同数据源。 </p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">var</span> queryGroupMax =<br>    <span class="hljs-keyword">from</span> student <span class="hljs-keyword">in</span> students<br>    <span class="hljs-keyword">group</span> student <span class="hljs-keyword">by</span> student.GradeLevel <span class="hljs-keyword">into</span> studentGroup<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span><br>    &#123;<br>        Level = studentGroup.Key,<br>        HighestScore =<br>            (<span class="hljs-keyword">from</span> student2 <span class="hljs-keyword">in</span> studentGroup<br>             <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">var</span> queryGroupMax =<br>    <span class="hljs-keyword">from</span> student <span class="hljs-keyword">in</span> students<br>    <span class="hljs-keyword">group</span> student <span class="hljs-keyword">by</span> student.GradeLevel <span class="hljs-keyword">into</span> studentGroup<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span><br>    &#123;<br>        Level = studentGroup.Key,<br>        HighestScore =<br>            (<span class="hljs-keyword">from</span> student2 <span class="hljs-keyword">in</span> studentGroup<br>             <span class="hljs-keyword">select</span> student2.Scores.Average())<br>             .Max()<br>    &#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的工作是对一个复杂数据库进行操作，模型类之间的关系很复杂。操作方式使用了 LINQ，之前一直对 LINQ 的查询语法不太喜欢，这次使用之后，感觉比方法语法更容易接受，因此详细总结一下查询表达式的语法。&lt;/p&gt;
&lt;p&gt;数据查询历来都表示为简单的字符串，没有编译时类型检查。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/"/>
    <id>https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构和算法是计算机软件相关专业的基础课程，要想从事编程工作，无论是否是科班出身，都不可能绕过这部分知识。<br>从本篇开始，我会详细的复习一遍数据结构以及算法。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><hr><p>数据结构: 是相互之间存在一种或多种特定关系的数据元素的集和。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>数据: 是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号的集和。<br>数据包括: 整型等数值类型，以及声音图片等非数值类型。</p><h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p>数据元素: 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p>数据项: 一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p>数据对象: 性质相同的数据元素的集和，是数据的子集。</p><h3 id="逻辑结构和物理结构"><a href="#逻辑结构和物理结构" class="headerlink" title="逻辑结构和物理结构"></a>逻辑结构和物理结构</h3><p>我们把数据结构划分为<strong>逻辑结构</strong>和<strong>物理结构</strong>。</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>逻辑结构: 是指数据对象中数据元素之间的相互关系。</p><p>逻辑结构可分为以下四种: </p><ol><li>集合结构: 集合结构中的数据元素除了同属于一个集合之外，他们之间没有其他关系</li><li>线性结构: 线性结构中的数据元素之间是一对一的关系</li><li>树形结构: 树形结构中的数据元素之间存在一种一对多的关系</li><li>图形结构: 图形结构的数据元素之间是多对多关系</li></ol><h4 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构(存储结构)"></a>物理结构(存储结构)</h4><p>物理结构: 是指数据的逻辑结构在计算机中的存储形式。<br>根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要针对内存而言，外部存储器的数据组织通常用文件结构来描述。</p><p>物理结构可分为以下两种: </p><ol><li>顺序存储: 是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</li><li>链式存储: 把数据元素放在任意的存储单元，这组存储单元可以是连续的，也可以是不连续的</li></ol><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型: 是指一组性质相同的值的集合以及在此集合上的一些操作的总称。<br>抽象是指抽取出事物具有的普遍性的本质。抽象是一种思考问题的方式，隐藏了繁杂的细节，只保留实现目标所必须的信息。</p><h4 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p>抽象数据类型(Abstruct Data Type，ADT): 指一个数学模型及定义在该模型上的一组操作。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><hr><p>算法: 是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p>算法具有五个基本特性: <strong>输入</strong>、<strong>输出</strong>、<strong>有穷性</strong>、<strong>确定性</strong>和<strong>可行性</strong>。</p><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>算法具有零个或多个输入，算法至少有一个或多个输出。</p><h4 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h4><p>有穷性: 指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成。</p><h4 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h4><p>确定性: 算法的每一步骤都具有确定的含义，不会出现二义性。</p><h4 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h4><p>可行性: 算法的每一步都必须是可行的。</p><h3 id="算法的设计要求"><a href="#算法的设计要求" class="headerlink" title="算法的设计要求"></a>算法的设计要求</h3><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>时间效率高和存储量低</li></ol><h3 id="函数的渐进增长"><a href="#函数的渐进增长" class="headerlink" title="函数的渐进增长"></a>函数的渐进增长</h3><p>函数的渐进增长: 给定两个函数 f(n) 和 g(n)，如果存在一个整数 N，使得对于所有的 n &gt; N，f(n) 总是比 g(n) 大，那么，我们就说 f(n) 的增长渐进快于 g(n)。</p><p>判断一个算法的效率时，函数中的常数和其他次要项可以忽略，而更应关注最高阶项的阶数。</p><h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间的度量，记作: T(n) = O(f(n))。他表示随问题规模 n 的增大，算法的执行时间的增长率和 f(n) 的增长率相同，称为算法的渐进时间复杂度，简称时间复杂度。</p><p>这样用大写 O 来体现算法时间复杂度的记法，称之为<strong>大 O 表示法</strong>。</p><p>一般情况，随着 n 增大，T(n) 增长最慢的算法为最优算法。</p><h4 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 O 阶方法"></a>推导大 O 阶方法</h4><ol><li>用常数 1 取代所有加法常数</li><li>只保留最高阶</li><li>如果最高阶存在且不是 1，则去除与这个项相乘的常数</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据结构和算法是计算机软件相关专业的基础课程，要想从事编程工作，无论是否是科班出身，都不可能绕过这部分知识。&lt;br&gt;从本篇开始，我会详细的复习一遍数据结构以及算法。&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)/"/>
    <id>https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们将会复习一下比较简单但是应用非常广泛的一种数据结构 —— 线性表。</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><hr><p>线性表(List): 零个或多个数据元素的有限序列。</p><p>如果用数学语言定义如下:<br>若将线性表记为(a<sub>1</sub>, …, a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>, …, a<sub>n</sub>)，则表中 a<sub>i-1</sub> 领先于 a<sub>i</sub>，a<sub>i</sub> 领先于 a<sub>i+1</sub>，称 a<sub>i-1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i+1</sub> 是 a<sub>i</sub> 的直接后继元素。当 i = 1, 2, …, n-1 时，a<sub>i</sub> 有且仅有一个直接后继，当 i = 2, …, n 时，a<sub>i</sub> 有且仅有一个直接前驱。</p><p>线性表元素的个数 n(n &gt;= 0) 称为线性表的长度，当 n = 0 时，称为空表。</p><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>线性表的顺序存储结构指的是，用一段地址连续的存储单元依次存储线性表的数据元素。<br>一般用一维数组来实现顺序存储结构。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SqList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> Maxsize = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> T[] Data = <span class="hljs-keyword">new</span> T[Maxsize];<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Length;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取第 i 位的元素</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;i&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> T e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Length == <span class="hljs-number">0</span> || i &lt; <span class="hljs-number">0</span> || i &gt;= Length)<br>        &#123;<br>            e = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        e = Data[i];<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 在第 i 位插入元素</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;i&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListInsert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, T e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Length == Maxsize)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; Length)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i != Length)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = Length - <span class="hljs-number">1</span>; j &gt;= i; j++)<br>            &#123;<br>                Data[j + <span class="hljs-number">1</span>] = Data[j];<br>            &#125;<br>        &#125;<br>        Data[i] = e;<br>        Length++;<br><br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 删除第 i 位元素</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;i&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListDelete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> T e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Length == <span class="hljs-number">0</span>)<br>        &#123;<br>            e = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; Length - <span class="hljs-number">1</span>)<br>        &#123;<br>            e = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        e = Data[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i; j &lt; Length; j++)<br>        &#123;<br>            Data[j] = Data[j + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        Length--;<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SqList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> Maxsize = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> T[] Data = <span class="hljs-keyword">new</span> T[Maxsize];<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Length;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取第 i 位的元素</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;i&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> T e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Length == <span class="hljs-number">0</span> || i &lt; <span class="hljs-number">0</span> || i &gt;= Length)<br>        &#123;<br>            e = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        e = Data[i];<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 在第 i 位插入元素</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;i&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListInsert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, T e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Length == Maxsize)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; Length)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i != Length)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = Length - <span class="hljs-number">1</span>; j &gt;= i; j++)<br>            &#123;<br>                Data[j + <span class="hljs-number">1</span>] = Data[j];<br>            &#125;<br>        &#125;<br>        Data[i] = e;<br>        Length++;<br><br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 删除第 i 位元素</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;i&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListDelete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> T e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Length == <span class="hljs-number">0</span>)<br>        &#123;<br>            e = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; Length - <span class="hljs-number">1</span>)<br>        &#123;<br>            e = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        e = Data[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i; j &lt; Length; j++)<br>        &#123;<br>            Data[j] = Data[j + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        Length--;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以快速存取表中任一位置元素</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>插入和删除操作需要移动大量元素</li><li>造成存储空间碎片化</li></ul><h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><p>线性表的链式存储结构的特点是，可以用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。</p><p>在顺序存储结构中，每个数据元素只需要存储数据元素信息就可以了，但是在链式存储结构中，除了要存储数据元素信息外，还要存储他的后继元素的地址。</p><p>因此，为了表示每个数据元素 a<sub>i</sub> 与其直接后继元素 a<sub>i+1</sub> 之间的逻辑关系，对于数据元素 a<sub>i</sub> 来说，除了存储本身信息之外，还需要存储一个指示其直接后继的信息。我们把存储数据元素信息的域称为数据域，把存储直接后继信息的域称为指针域(对于高级语言，我们可以把它理解成对象引用域)。把这两部分组成的数据元素称为节点(Node)。<br>n 个节点链接成一个链表，即线性表的链式存储结构。因为此链表每个节点只有一个指针域，因此称为单链表。</p><p>我们把第一个节点的指针域称为头指针。为了方便操作链表，会在单链表的第一个节点前设置一个节点，称为头节点。头节点的数据域不存储任何信息。<br>注意: 如果设置了头节点，那么头节点的指针域存储的就是头指针。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T Element;<br>    <span class="hljs-keyword">public</span> Node&lt;T&gt; NextNode;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        Element = t;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LinkList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-comment">//头节点(数据域无意义)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; HeadNode</span> = <span class="hljs-keyword">new</span> Node&lt;T&gt;(<span class="hljs-literal">default</span>(T));<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> temp = HeadNode;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span> &amp;&amp; j &lt; i + <span class="hljs-number">1</span>)<br>        &#123;<br>            temp = temp.NextNode;<br>            j++;<br>        &#125;<br><br>        node = temp;<br>        <span class="hljs-keyword">return</span> temp == <span class="hljs-literal">null</span> ? Status.Error : Status.Ok;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListInsert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> status = GetElement(i - <span class="hljs-number">1</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> prevNode);<br>        <span class="hljs-keyword">if</span> (status != Status.Ok) <span class="hljs-keyword">return</span> status;<br>        <br>        node.NextNode = prevNode.NextNode;<br>        prevNode.NextNode = node;<br>        <br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListDelete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        node = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">var</span> status = GetElement(i - <span class="hljs-number">1</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> prevNode);<br>        <span class="hljs-keyword">if</span> (status != Status.Ok) <span class="hljs-keyword">return</span> status;<br><br>        <span class="hljs-keyword">var</span> current = prevNode.NextNode;<br>        prevNode.NextNode = current.NextNode;<br>        node = current;<br>        <br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T Element;<br>    <span class="hljs-keyword">public</span> Node&lt;T&gt; NextNode;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        Element = t;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LinkList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-comment">//头节点(数据域无意义)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; HeadNode</span> = <span class="hljs-keyword">new</span> Node&lt;T&gt;(<span class="hljs-literal">default</span>(T));<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> temp = HeadNode;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span> &amp;&amp; j &lt; i + <span class="hljs-number">1</span>)<br>        &#123;<br>            temp = temp.NextNode;<br>            j++;<br>        &#125;<br><br>        node = temp;<br>        <span class="hljs-keyword">return</span> temp == <span class="hljs-literal">null</span> ? Status.Error : Status.Ok;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListInsert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> status = GetElement(i - <span class="hljs-number">1</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> prevNode);<br>        <span class="hljs-keyword">if</span> (status != Status.Ok) <span class="hljs-keyword">return</span> status;<br>        <br>        node.NextNode = prevNode.NextNode;<br>        prevNode.NextNode = node;<br>        <br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListDelete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        node = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">var</span> status = GetElement(i - <span class="hljs-number">1</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> prevNode);<br>        <span class="hljs-keyword">if</span> (status != Status.Ok) <span class="hljs-keyword">return</span> status;<br><br>        <span class="hljs-keyword">var</span> current = prevNode.NextNode;<br>        prevNode.NextNode = current.NextNode;<br>        node = current;<br>        <br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>将单链表中尾节点的指针域指向头节点，使链表形成一个环，这种头尾相接的链表称为单循环链表，简称为循环链表。</p><p>循环链表和单链表的主要差异就是判断结束条件由指针域是否为空变为指针域是否是头节点。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表是在单向链表的每个节点中，再设置一个指向前驱节点的指针。所以在双向链表中存在两个指针域，一个指向直接前驱，一个指向直接后继。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DoubleLinkList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-comment">//头节点(数据域无意义)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; HeadNode</span> = <span class="hljs-keyword">new</span> Node&lt;T&gt;(<span class="hljs-literal">default</span>(T));<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> temp = HeadNode;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span> &amp;&amp; j &lt; i + <span class="hljs-number">1</span>)<br>        &#123;<br>            temp = temp.NextNode;<br>            j++;<br>        &#125;<br><br>        node = temp;<br>        <span class="hljs-keyword">return</span> temp == <span class="hljs-literal">null</span> ? Status.Error : Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListInsert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> status = GetElement(i - <span class="hljs-number">1</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> prevNode);<br>        <span class="hljs-keyword">if</span> (status != Status.Ok) <span class="hljs-keyword">return</span> status;<br><br>        node.PrevNode = prevNode;<br>        node.NextNode = prevNode.NextNode;<br>        prevNode.NextNode.PrevNode = node;<br>        prevNode.NextNode = node;<br><br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListDelete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        node = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">var</span> status = GetElement(i - <span class="hljs-number">1</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> prevNode);<br>        <span class="hljs-keyword">if</span> (status != Status.Ok) <span class="hljs-keyword">return</span> status;<br>        <span class="hljs-keyword">var</span> current = prevNode.NextNode;<br>        current.NextNode.PrevNode = prevNode;<br>        prevNode.NextNode = current.NextNode;<br>        node = current;<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DoubleLinkList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-comment">//头节点(数据域无意义)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; HeadNode</span> = <span class="hljs-keyword">new</span> Node&lt;T&gt;(<span class="hljs-literal">default</span>(T));<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> temp = HeadNode;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span> &amp;&amp; j &lt; i + <span class="hljs-number">1</span>)<br>        &#123;<br>            temp = temp.NextNode;<br>            j++;<br>        &#125;<br><br>        node = temp;<br>        <span class="hljs-keyword">return</span> temp == <span class="hljs-literal">null</span> ? Status.Error : Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListInsert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> status = GetElement(i - <span class="hljs-number">1</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> prevNode);<br>        <span class="hljs-keyword">if</span> (status != Status.Ok) <span class="hljs-keyword">return</span> status;<br><br>        node.PrevNode = prevNode;<br>        node.NextNode = prevNode.NextNode;<br>        prevNode.NextNode.PrevNode = node;<br>        prevNode.NextNode = node;<br><br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">ListDelete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-keyword">out</span> Node&lt;T&gt; node</span>)</span><br>    &#123;<br>        node = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">var</span> status = GetElement(i - <span class="hljs-number">1</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> prevNode);<br>        <span class="hljs-keyword">if</span> (status != Status.Ok) <span class="hljs-keyword">return</span> status;<br>        <span class="hljs-keyword">var</span> current = prevNode.NextNode;<br>        current.NextNode.PrevNode = prevNode;<br>        prevNode.NextNode = current.NextNode;<br>        node = current;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>在对链表进行操作时要记住一个原则: 后继指针很重要，在使用完之前不要赋新值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们将会复习一下比较简单但是应用非常广泛的一种数据结构 —— 线性表。&lt;/p&gt;
&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;线性表(List): 零个或多</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/"/>
    <id>https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们将会复习一下基于线性表衍生出的两种数据结构 —— 栈和队列。</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><hr><p>在软件应用中，栈这种后进先出的数据结构的应用是非常普遍的。比如浏览器的前进后退、Word 和 PhotoShop 等编辑软件中的撤销操作，以及在 iOS 开发中的 push、pop controller 操作都是栈的应用。</p><p>栈本质是限定仅在表尾进行插入和删除操作的线性表。<br>我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。<br>栈又称为后进先出的线性表，简称为 LIFO 结构。</p><p>理解栈我们要注意: </p><ol><li>他是一个线性表</li><li>仅允许在表尾进行插入和删除操作，这里的表尾是指栈顶</li></ol><p>栈的插入操作，叫做进栈(push)，也称为压栈、入栈。<br>栈的删除操作，叫做出栈(pop)，也称为弹栈。</p><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><p>栈的顺序存储结构简称为顺序栈。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SqStack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> Maxsize = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> T[] Data = <span class="hljs-keyword">new</span> T[Maxsize];<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Top = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">Push</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Top &gt;= Maxsize)<br>        &#123;<br>            <span class="hljs-comment">//栈满</span><br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        Top++;<br>        Data[Top] = t;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">Pop</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Top == <span class="hljs-number">-1</span>)<br>        &#123;<br>            t = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        t = Data[Top];<br>        Top--;<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SqStack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> Maxsize = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> T[] Data = <span class="hljs-keyword">new</span> T[Maxsize];<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Top = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">Push</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Top &gt;= Maxsize)<br>        &#123;<br>            <span class="hljs-comment">//栈满</span><br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        Top++;<br>        Data[Top] = t;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">Pop</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Top == <span class="hljs-number">-1</span>)<br>        &#123;<br>            t = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        t = Data[Top];<br>        Top--;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>栈的链式存储结构简称为链栈。<br>对于链栈来说，是不需要头节点的。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkStack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> StackNode&lt;T&gt; Top;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">Push</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> stackNode = <span class="hljs-keyword">new</span> StackNode&lt;T&gt;(t) &#123;NextNode = Top&#125;;<br>        Top = stackNode;<br>        Count++;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">Pop</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Top == <span class="hljs-literal">null</span>)<br>        &#123;<br>            t = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        t = Top.Element;<br>        Top = Top.NextNode;<br>        Count--;<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkStack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> StackNode&lt;T&gt; Top;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">Push</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> stackNode = <span class="hljs-keyword">new</span> StackNode&lt;T&gt;(t) &#123;NextNode = Top&#125;;<br>        Top = stackNode;<br>        Count++;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">Pop</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Top == <span class="hljs-literal">null</span>)<br>        &#123;<br>            t = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        t = Top.Element;<br>        Top = Top.NextNode;<br>        Count--;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>我们把一个直接调用自己或者通过一系列调用语句间接地调用自己的函数，称为递归函数。<br>每个递归定义必须至少有一个条件，满足时递归不再进行，即不在引用自身而是返回值退出。<br>递归回退的顺序是他前进顺序的逆序。显然符合栈这种数据结构。因此编译器使用栈来实现递归。</p><h4 id="四则运算表达式求值"><a href="#四则运算表达式求值" class="headerlink" title="四则运算表达式求值"></a>四则运算表达式求值</h4><p>一种不需要括号的后缀表示法，也称为逆波兰表示(RPN)。是一种非常巧妙的将四则运算由常见的中缀表达式变为后缀表达式来简化运算复杂性。基本原理也是栈。这里就不详细说明了。</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><hr><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出的线性表，简称为 FIFO 结构。<br>允许插入操作的一端称为队尾，允许删除操作的一端称为队头。</p><p>队列在程序设计中使用非常频繁，如消息队列(MQ)所使用的数据结构等。</p><h3 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h3><p>如果我们只把队列当成普通的线性表操作也完全没有问题，入队操作时间复杂度为 O(1)，但是出队操作时间复杂度为 O(n)，为解决这个问题，我们可以使用循环队列。<br>我们把队列的这种头尾相接的顺序存储结构称为循环队列。<br>为了实现循环队列，我们需要引入两个变量，一个指向队头元素所在位置，一个指向队尾元素的下一个位置。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SqQueue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> Maxsize = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> T[] Data = <span class="hljs-keyword">new</span> T[Maxsize];<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _front;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _rear;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">EnQueue</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ((_rear + <span class="hljs-number">1</span>) % Maxsize == _front)<br>        &#123;<br>            <span class="hljs-comment">//队满</span><br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        Data[_rear] = t;<br>        _rear = (_rear + <span class="hljs-number">1</span>) % Maxsize;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">DeQueue</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (_rear == _front)<br>        &#123;<br>            <span class="hljs-comment">//队空</span><br>            t = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        t = Data[_front];<br>        _front = (_front + <span class="hljs-number">1</span>) % Maxsize;<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SqQueue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> Maxsize = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> T[] Data = <span class="hljs-keyword">new</span> T[Maxsize];<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _front;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _rear;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">EnQueue</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ((_rear + <span class="hljs-number">1</span>) % Maxsize == _front)<br>        &#123;<br>            <span class="hljs-comment">//队满</span><br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        Data[_rear] = t;<br>        _rear = (_rear + <span class="hljs-number">1</span>) % Maxsize;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">DeQueue</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (_rear == _front)<br>        &#123;<br>            <span class="hljs-comment">//队空</span><br>            t = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        t = Data[_front];<br>        _front = (_front + <span class="hljs-number">1</span>) % Maxsize;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueNode</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T Element;<br>    <span class="hljs-keyword">public</span> QueueNode&lt;T&gt; NextNode;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QueueNode</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        Element = t;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkQueue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> QueueNode&lt;T&gt; Front, Rear;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">EnQueue</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> QueueNode&lt;T&gt;(t);<br>        Front.NextNode = node;<br>        Rear = node;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">DeQueue</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Front == Rear)<br>        &#123;<br>            t = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        t = Front.Element;<br>        Front = Front.NextNode;<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueNode</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T Element;<br>    <span class="hljs-keyword">public</span> QueueNode&lt;T&gt; NextNode;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QueueNode</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        Element = t;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkQueue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> QueueNode&lt;T&gt; Front, Rear;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">EnQueue</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> QueueNode&lt;T&gt;(t);<br>        Front.NextNode = node;<br>        Rear = node;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">DeQueue</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T t</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (Front == Rear)<br>        &#123;<br>            t = <span class="hljs-literal">default</span>(T);<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        t = Front.Element;<br>        Front = Front.NextNode;<br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们将会复习一下基于线性表衍生出的两种数据结构 —— 栈和队列。&lt;/p&gt;
&lt;h2 id=&quot;栈-Stack&quot;&gt;&lt;a href=&quot;#栈-Stack&quot; class=&quot;headerlink&quot; title=&quot;栈(Stack)&quot;&gt;&lt;/a&gt;栈(Stack)&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%9B%9B)/"/>
    <id>https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%9B%9B)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们来讨论一种一对多的数据结构 —— 树。</p><h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h2><hr><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>树是 n(n &gt;= 0) 个节点的有限集。当 n = 0 时，称为空树。在任意一棵非空树中: </p><ol><li>有且仅有一个特定的称为根(root)的节点</li><li>当 n &gt;= 1 时，其余节点可分为 m(m &gt; 0)个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、…、T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)</li></ol><p>对于树，还需要注意两点: </p><ol><li>n &gt; 0 时根节点是唯一的，不可能存在多个根节点</li><li>m &gt; 0 时，子树的个数没有限制，但他们一定互不相交</li></ol><h3 id="节点分类"><a href="#节点分类" class="headerlink" title="节点分类"></a>节点分类</h3><p>树的节点包含一个数据元素以及若干个指向其子树的分支。节点拥有的子树的个数称为节点的度(Degree)。<br>度为 0 的节点成为叶节点(Leaf)。度不为 0 的节点称为分支节点。<br>除了根节点之外的分支节点又称为内部节点。</p><h3 id="节点间的关系"><a href="#节点间的关系" class="headerlink" title="节点间的关系"></a>节点间的关系</h3><p>节点的子树的根成为该节点的孩子(Child)，相应的该节点称为孩子的双亲(Parent)。同一双亲的孩子之间互称为兄弟(Sibling)。</p><h3 id="树的其他概念"><a href="#树的其他概念" class="headerlink" title="树的其他概念"></a>树的其他概念</h3><p>节点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。树中节点的最大层次称为树的深度(Depth)。<br>如果将树中节点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p><p>森林(Forest)是 m(m &gt;= 0)棵互不相交的树的集合。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><hr><p>二叉树(Binary Tree)是 n(n &gt;= 0)个节点的有限集合，该集合或为空集(空二叉树)，或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</p><h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><ul><li>每个节点最多有两棵子树，所以二叉树中不存在度大于 2 的节点。注意不是只有而是<strong>最多有</strong>，没有或者有一棵子树也是可以的</li><li>左子树和右子树是有顺序的</li><li>即使树中某节点只有一棵子树，也要区分他是左子树还是右子树</li></ul><p>二叉树具有五种基本形态: </p><ol><li>空二叉树</li><li>只有一个根节点</li><li>根节点只有左子树</li><li>根节点只有右子树</li><li>根节点既有左子树又有右子树</li></ol><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><h4 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h4><p>所有节点都只有左子树的二叉树叫做左斜树。所有节点都只有右子树的二叉树叫做右斜树。二者统称为斜树。<br>线性表结构就可以理解为是树的一种极其特殊的表现形式。</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>在一棵二叉树中，如果所有的分支节点都存在左子树和右子树，并且所有的叶子都在同一层上，这样的二叉树称为满二叉树。</p><p>满二叉树的特点: </p><ol><li>叶子只能出现在最下层</li><li>非叶子节点的度一定是 2</li><li>在同样深度的二叉树中，满二叉树的节点个数最多，叶子数最多</li></ol><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>对一棵具有 n(n &gt;= 0)个节点的二叉树按层序编号，如果编号为 i(1 &lt;= i &lt;= n)的节点与同样深度的满二叉树中编号为 i 的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。<br>注意: 满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。</p><p>完全二叉树的特点: </p><ol><li>叶子节点只能出现在最下两层</li><li>最下层的叶子一定集中在左部连续位置</li><li>倒数第二层，若有叶子节点，一定都在右部连续位置</li><li>如果节点度为 1，则该节点只有左孩子</li><li>同样节点数的二叉树，完全二叉树的深度最小</li></ol><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol><li>在二叉树的第 i 层上最多有 2<sup>i-1</sup> 个节点(i &gt;= 1)</li><li>深度为 k 的二叉树最多有 2<sup>k</sup> - 1 个节点</li><li>对任何一棵二叉树 T，如果其叶节点个数为 n<sub>0</sub>，度为 2 的节点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li></ol><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>对于二叉树使用顺序存储适用性不强，一般使用链式存储结构。二叉树每个节点最多有两个孩子所以为他设计一个数据域和两个指针域，我们称这样的链表为二叉链表。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BiTNode</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T Element;<br>    <span class="hljs-keyword">public</span> BiTNode&lt;T&gt; LChild;<br>    <span class="hljs-keyword">public</span> BiTNode&lt;T&gt; RChild;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiTNode</span>(<span class="hljs-params"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BiTNode</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T Element;<br>    <span class="hljs-keyword">public</span> BiTNode&lt;T&gt; LChild;<br>    <span class="hljs-keyword">public</span> BiTNode&lt;T&gt; RChild;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiTNode</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        Element = t;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="遍历二叉树-Traveing-Binary-Tree"><a href="#遍历二叉树-Traveing-Binary-Tree" class="headerlink" title="遍历二叉树(Traveing Binary Tree)"></a>遍历二叉树(Traveing Binary Tree)</h3><p>二叉树遍历是指从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。</p><p>这里有两个关键词: <strong>访问</strong>和<strong>次序</strong></p><h4 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h4><p>主要分为四种: </p><ol><li>前序遍历: 规则是若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树(根-左-右)</li><li>中序遍历: 规则是若二叉树为空，则空操作返回，否则从根节点开始(注意并不是先访问根节点)，中序遍历根节点左子树，然后访问根节点，最后中序遍历右子树(左-根-右)</li><li>后序遍历: 则是若二叉树为空，则空操作返回，否则从左到右先叶子后节点的方式遍历访问左右子树，最后是访问根节点(左-右-根)</li><li>层序遍历: 则是若二叉树为空，则空操作返回，否则从树的第一层开始，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按照从左到右的顺序对节点逐个访问</li></ol><p>注意: 前、中、后代表的是根节点位置。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraverse</span>(<span class="hljs-params">BiTNode&lt;T&gt; node</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>    &#123;<br>        Console.WriteLine(node.Element);<br>        PreOrderTraverse(node.LChild);<br>        PreOrderTraverse(node.RChild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraverse</span>(<span class="hljs-params">BiTNode&lt;T&gt; node</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>    &#123;<br>        InOrderTraverse(node.LChild);<br>        Console.WriteLine(node.Element);<br>        InOrderTraverse(node.RChild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraverse</span>(<span class="hljs-params">BiTNode&lt;T&gt; node</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>    &#123;<br>        PostOrderTraverse(node.LChild);<br>        PostOrderTraverse(node.RChild);<br>        Console.WriteLine(node.Element);<br>    &#125;<br>    <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraverse</span>(<span class="hljs-params">BiTNode&lt;T&gt; node</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>    &#123;<br>        Console.WriteLine(node.Element);<br>        PreOrderTraverse(node.LChild);<br>        PreOrderTraverse(node.RChild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraverse</span>(<span class="hljs-params">BiTNode&lt;T&gt; node</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>    &#123;<br>        InOrderTraverse(node.LChild);<br>        Console.WriteLine(node.Element);<br>        InOrderTraverse(node.RChild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraverse</span>(<span class="hljs-params">BiTNode&lt;T&gt; node</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>    &#123;<br>        PostOrderTraverse(node.LChild);<br>        PostOrderTraverse(node.RChild);<br>        Console.WriteLine(node.Element);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Data;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>二叉树遍历的性质: </p><ol><li>已知前序遍历和中序遍历，可以唯一确定一棵二叉树</li><li>已知后序遍历和中序遍历，可以唯一确定一棵二叉树</li><li>已知前序遍历和后序遍历，是不可以唯一确定一棵二叉树</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们来讨论一种一对多的数据结构 —— 树。&lt;/p&gt;
&lt;h2 id=&quot;树-Tree&quot;&gt;&lt;a href=&quot;#树-Tree&quot; class=&quot;headerlink&quot; title=&quot;树(Tree)&quot;&gt;&lt;/a&gt;树(Tree)&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%94)/"/>
    <id>https://1ess.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%94)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们来讨论一种多对多的数据结构 —— 图。</p><h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><hr><p>图(Graph)是由顶点有穷非空集合和顶点之间边的集合组成，通常表示为: G(V, E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p><p>对于图的定义，我们需要注意几个方面: </p><ul><li>线性表中我们把元素叫元素，树中将集合元素称为节点，在图中数据元素，我们则称为顶点(Vertex)</li><li>线性表中可以没有数据元素，称为空表。树中可以没有节点，称为空树。但是，在图中，不允许没有顶点</li></ul><h3 id="各种图定义"><a href="#各种图定义" class="headerlink" title="各种图定义"></a>各种图定义</h3><p>无向边: 若顶点 v<sub>i</sub> 到 v<sub>j</sub> 之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对 (v<sub>i</sub>, v<sub>j</sub>) 表示，如果图中的边都是无向边，则称该图为无向图(Undirected graphs)。</p><p>有向边: 若顶点 v<sub>i</sub> 到 v<sub>j</sub> 之间的边有方向，则称这条边为有向边，也称为弧(Arc)，用有序偶对 &lt;v<sub>i</sub>, v<sub>j</sub>&gt; 表示，v<sub>i</sub> 称为弧尾(Tail)，v<sub>j</sub> 称为弧头(Head)，如果图中的边都是有向边，则称该图为有向图(Directed graphs)。</p><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。我们在本篇要讨论的也都是简单图。</p><p>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图有 n*(n-1)/2 条边。</p><p>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有 n 个顶点的有向完全图有 n*(n-1) 条边。</p><p>有很少条边或弧的图称为稀疏图，反之称为稠密图。</p><p>有些图的边或弧具有与他相关的数字，这种与图的边或弧相关的数叫做权(Weight)。这种带权的图称为网(Network)。</p><h3 id="图的顶点与边间关系"><a href="#图的顶点与边间关系" class="headerlink" title="图的顶点与边间关系"></a>图的顶点与边间关系</h3><p>对于无向图 G=(V, {E})，如果边 (v, v<sub>i</sub>) ∈ E，则称顶点 v 和 v<sub>i</sub> 互为邻接点，即 v 和 v<sub>i</sub> 相邻接。边 (v, v<sub>i</sub>) 依附于顶点 v 和 v<sub>i</sub>，或者说 (v, v<sub>i</sub>) 与顶点 v 和 v<sub>i</sub> 相关联。<br>顶点 v 的度是和 v 相关联的边的数目，记为 TD(v)。</p><p>对于无向图 G=(V, {E})，如果弧 &lt;v, v<sub>i</sub>&gt; ∈ E，则称顶点 v 邻接到顶点 v<sub>i</sub>，顶点 v<sub>i</sub> 邻接自顶点 v。以顶点 v 为头的弧的数目称为 v 的入度，记为 ID(v)，以 v 为尾的弧的数目称为 v 的出度，记为 OD(v)，顶点 v 的度为 TD(v) = ID(v) + OD(v)。</p><p>无向图 G=(V, {E}) 中从顶点 v 到顶点 v<sub>i</sub> 的路径(Path)是一个顶点序列。<br>路径的长度是路径上的边或弧的数目。</p><p>第一个顶点到最后一个顶点相同的路径称为回路或环。</p><h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><p>在无向图 G 中，如果从顶点 v 到顶点 v<sub>i</sub> 有路径，则称 v 和 v<sub>i</sub> 是连通的，如果对于图中任意两个顶点都是连通的，则称 G 是连通图。</p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><hr><p>我们来看一下对于图的五种不同的存储结构: </p><ol><li>邻接矩阵</li><li>邻接表</li><li>十字链表</li><li>邻接多重表</li><li>边集数组</li></ol><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><hr><p>从图中某一顶点除法访遍图中其余顶点，且每一个顶点仅被访问一次，这一过程就称为图的遍历。</p><p>可分为: </p><ol><li>深度优先遍历(Depth First Search，DFS)</li><li>广度优先遍历(Breadth First Search，BFS)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们来讨论一种多对多的数据结构 —— 图。&lt;/p&gt;
&lt;h2 id=&quot;图的定义&quot;&gt;&lt;a href=&quot;#图的定义&quot; class=&quot;headerlink&quot; title=&quot;图的定义&quot;&gt;&lt;/a&gt;图的定义&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;图(Graph)是由顶点有穷非空集合和顶点之间边的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E7%AE%97%E6%B3%95(%E4%B8%80)/"/>
    <id>https://1ess.github.io/%E7%AE%97%E6%B3%95(%E4%B8%80)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇开始，我们来看看在工作中比较常用的两大算法之一的<strong>查找</strong>算法。</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><hr><p>查找表(Search Table): 是由同一类型的数据元素构成的集合。<br>关键字(Key): 是数据元素中某个数据项的值，又称为键值。<br>若此关键字可以唯一地标识某一记录，则称此关键字为主关键字(Primary Key)。</p><p>查找(Searching)就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。</p><h3 id="顺序查找表"><a href="#顺序查找表" class="headerlink" title="顺序查找表"></a>顺序查找表</h3><p>顺序查找(Sequential Search)又称为线性查找，是最基本的查找技术，他的查找过程是: 从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录，如果直到最后一个(或第一个)记录，其关键字和给定值都不相等时，则表中没有所查的记录，查找不成功。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SequentialSearch</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T[] Sequential;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SequentialSearch</span>(<span class="hljs-params">T[] sequential</span>)</span><br>    &#123;<br>        Sequential = sequential;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">SequentialSearching</span>(<span class="hljs-params">T key, <span class="hljs-keyword">out</span> T <span class="hljs-keyword">record</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> s <span class="hljs-keyword">in</span> Sequential)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!s.Equals(key)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">record</span> = s;<br>            <span class="hljs-keyword">return</span> Status.Ok;<br>        &#125;<br><br>        <span class="hljs-keyword">record</span> = <span class="hljs-literal">default</span>(T);<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SequentialSearch</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T[] Sequential;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SequentialSearch</span>(<span class="hljs-params">T[] sequential</span>)</span><br>    &#123;<br>        Sequential = sequential;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">SequentialSearching</span>(<span class="hljs-params">T key, <span class="hljs-keyword">out</span> T <span class="hljs-keyword">record</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> s <span class="hljs-keyword">in</span> Sequential)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!s.Equals(key)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">record</span> = s;<br>            <span class="hljs-keyword">return</span> Status.Ok;<br>        &#125;<br><br>        <span class="hljs-keyword">record</span> = <span class="hljs-literal">default</span>(T);<br>        <span class="hljs-keyword">return</span> Status.Error;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="有序查找表"><a href="#有序查找表" class="headerlink" title="有序查找表"></a>有序查找表</h3><p>最常用的有序查找就是折半查找。折半查找又称为二分查找(Binary Search)，他的前提是线性表中的记录必须是关键码有序，线性表必须采用顺序存储。折半查找的基本思想是: 在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功，若给定值小于中间记录的关键字，则在中间记录的左半区继续查找，若给定值大于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearching</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] Binary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinarySearching</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] binary</span>)</span><br>    &#123;<br>        Binary = binary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">BinarySearch</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> key, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">record</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> high = Binary.Length;<br>        <span class="hljs-keyword">while</span> (low &lt;= high)<br>        &#123;<br>            <span class="hljs-keyword">var</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (Binary[mid] &lt; key)<br>            &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Binary[mid] &gt; key)<br>            &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">record</span> = Binary[mid];<br>                <span class="hljs-keyword">return</span> Status.Ok;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">record</span> = <span class="hljs-literal">default</span>(<span class="hljs-built_in">int</span>);<br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearching</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] Binary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinarySearching</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] binary</span>)</span><br>    &#123;<br>        Binary = binary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">BinarySearch</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> key, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">record</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> high = Binary.Length;<br>        <span class="hljs-keyword">while</span> (low &lt;= high)<br>        &#123;<br>            <span class="hljs-keyword">var</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (Binary[mid] &lt; key)<br>            &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Binary[mid] &gt; key)<br>            &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">record</span> = Binary[mid];<br>                <span class="hljs-keyword">return</span> Status.Ok;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">record</span> = <span class="hljs-literal">default</span>(<span class="hljs-built_in">int</span>);<br>        <span class="hljs-keyword">return</span> Status.Error;<br>    &#125;<br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h3><p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与他对应的记录相关联的过程。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</p><p>索引按照结构可以分为<strong>线性索引</strong>、<strong>树形索引</strong>、<strong>多级索引</strong>。本篇只介绍线性索引。</p><p>所谓线性索引就是将索引项集合组织为线性结构，也称索引表。我们介绍三种线性索引: </p><ol><li>稠密索引</li><li>分块索引</li><li>倒排索引</li></ol><h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h4><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，索引项一定是按照关键码有序的排列。</p><h4 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h4><p>分块有序，是把数据集的记录分成若干块，并且这些块满足: </p><ol><li>块内无序</li><li>块间有序</li></ol><p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。<br>分块索引普遍用于数据库表查找等技术中。</p><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>用于最基础的搜索技术。本篇略过。</p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树(Binary Sort Tree)又称为二叉查找树。他或是一棵空树，或者是具有下列性质的二叉树: </p><ul><li>若他的左子树不空，则左子树上所有结点的值均小于他的根节点的值</li><li>若他的右子树不空，则右子树上所有结点的值均大于他的根节点的值</li><li>他的左右子树也分别为二叉排序树</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySortTree</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span> BiTree RootBiTree &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">//查找</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">SearchBst</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> key, BiTree rootBiTree</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> temp = rootBiTree;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (temp.Data == key)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Status.Ok;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (temp.Data &gt; key)<br>        &#123;<br>            temp = temp.LBiTree;<br>            <span class="hljs-keyword">return</span> SearchBst(key, temp);<br>        &#125;<br><br>        temp = temp.RBiTree;<br>        <span class="hljs-keyword">return</span> SearchBst(key, temp);<br><br>    &#125;<br><br>    <span class="hljs-comment">//插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">InsertBst</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">record</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> bt = <span class="hljs-keyword">new</span> BiTree<br>        &#123;<br>            Data = <span class="hljs-keyword">record</span><br>        &#125;;<br>        <span class="hljs-keyword">if</span> (RootBiTree == <span class="hljs-literal">null</span>)<br>        &#123;<br>            RootBiTree = bt;<br>            <span class="hljs-keyword">return</span> Status.Ok;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> current = RootBiTree;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">var</span> parent = current;<br>            <span class="hljs-keyword">if</span> (current.Data &lt;= bt.Data)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (current.Data &gt;= bt.Data) <span class="hljs-keyword">return</span> Status.Error;<br>                current = current.RBiTree;<br>                <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>                parent.RBiTree = bt;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            current = current.LBiTree;<br>            <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            parent.LBiTree = bt;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySortTree</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span> BiTree RootBiTree &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">//查找</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">SearchBst</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> key, BiTree rootBiTree</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> temp = rootBiTree;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Status.Error;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (temp.Data == key)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Status.Ok;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (temp.Data &gt; key)<br>        &#123;<br>            temp = temp.LBiTree;<br>            <span class="hljs-keyword">return</span> SearchBst(key, temp);<br>        &#125;<br><br>        temp = temp.RBiTree;<br>        <span class="hljs-keyword">return</span> SearchBst(key, temp);<br><br>    &#125;<br><br>    <span class="hljs-comment">//插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">InsertBst</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">record</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> bt = <span class="hljs-keyword">new</span> BiTree<br>        &#123;<br>            Data = <span class="hljs-keyword">record</span><br>        &#125;;<br>        <span class="hljs-keyword">if</span> (RootBiTree == <span class="hljs-literal">null</span>)<br>        &#123;<br>            RootBiTree = bt;<br>            <span class="hljs-keyword">return</span> Status.Ok;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> current = RootBiTree;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">var</span> parent = current;<br>            <span class="hljs-keyword">if</span> (current.Data &lt;= bt.Data)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (current.Data &gt;= bt.Data) <span class="hljs-keyword">return</span> Status.Error;<br>                current = current.RBiTree;<br>                <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>                parent.RBiTree = bt;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            current = current.LBiTree;<br>            <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            parent.LBiTree = bt;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Status.Ok;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h3><p>散列技术是在记录的存储位置和他的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)。<br>我们把这种对应关系 f 称为散列函数，又称为哈希函数(Hash)。采用散列技术将记录存储在一块连续的存储空间中，这块存储空间称为散列表或哈希表(Hash Table)。</p><p>两个关键字 key<sub>1</sub> 不等于 key<sub>2</sub>，但是 f(key<sub>1</sub>) = f(key<sub>2</sub>)，这种现象我们称为冲突。</p><h4 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h4><p>好的散列函数: </p><ol><li>计算简单</li><li>散列地址分布均匀</li></ol><p>散列函数构造方法可分为: </p><ol><li>直接定址法</li><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>除留余数法</li><li>随机数法</li></ol><h4 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h4><ol><li>开放定址法</li><li>再散列函数法</li><li>链地址法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇开始，我们来看看在工作中比较常用的两大算法之一的&lt;strong&gt;查找&lt;/strong&gt;算法。&lt;/p&gt;
&lt;h2 id=&quot;概论&quot;&gt;&lt;a href=&quot;#概论&quot; class=&quot;headerlink&quot; title=&quot;概论&quot;&gt;&lt;/a&gt;概论&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;查找表(Searc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E7%AE%97%E6%B3%95(%E4%BA%8C)/"/>
    <id>https://1ess.github.io/%E7%AE%97%E6%B3%95(%E4%BA%8C)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇开始，我们来看看在工作中比较常用的两大算法之一的<strong>排序</strong>算法。</p><h2 id="基本概念及分类"><a href="#基本概念及分类" class="headerlink" title="基本概念及分类"></a>基本概念及分类</h2><hr><p>假设含有 n 个记录的序列为 {r<sub>1</sub>, r<sub>2</sub>, …, r<sub>n</sub>}，其相应的关键字分别为 {k<sub>1</sub>, k<sub>2</sub>, …, k<sub>n</sub>}，需确定 1, 2, …, n 的一种排列 p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>，使其相应的关键字满足 k<sub>p1</sub> &lt;= k<sub>p2</sub> &lt;= … &lt;= k<sub>pn</sub> 非递减(或非递增)关系，即使得序列成为一个按关键字有序的序列 {r<sub>p1</sub>, r<sub>p2</sub>, …, r<sub>pn</sub>}，这样的操作就称为排序。</p><p>注意: 我们在排序问题中，通常将数据元素称为记录。</p><h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><p>假设 k<sub>i</sub> = k<sub>j</sub> (1 &lt;= i &lt;= n, 1 &lt;= j &lt;= n, i 不等于 j)，且在排序前的序列中 r<sub>i</sub> 领先于 r<sub>j</sub>(即 i &lt; j)。如果排序后 r<sub>i</sub> 仍领先于 r<sub>j</sub>，则称所用的排序方法时稳定的，反之，则称所用的排序方法时不稳定的。</p><h3 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h3><p>根据排序过程中待排序的记录是否全部放置于内存中，排序分为: 内排序和外排序。<br>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。<br>外排序是由于待排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><hr><p>冒泡排序(Bubble Sort): 一种交换排序，他的基本思想是，两两比较相邻记录的关键字，如果反序则交换，知道没有反序记录为止。</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SqList</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MaxSize = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] Data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[MaxSize];<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Length;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SqList</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> length = (data.Length &gt; MaxSize ? MaxSize : data.Length);<br>        Length = length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>        &#123;<br>            Data[i] = data[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> a, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> temp = a;<br>        a = b;<br>        b = temp;<br>    &#125;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 只能算是简单交换排序，经历一遍内存循环，将最小值置于第 i 位</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort0</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; Length; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (Data[i] &gt; Data[j])<br>                &#123;<br>                    Swap(<span class="hljs-keyword">ref</span> Data[i], <span class="hljs-keyword">ref</span> Data[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowDatas</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length; i++)<br>        &#123;<br>            data[i] = Data[i];<br>        &#125;<br>        Console.WriteLine(<span class="hljs-built_in">string</span>.Join(<span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">SqList</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MaxSize = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] Data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[MaxSize];<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Length;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SqList</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> length = (data.Length &gt; MaxSize ? MaxSize : data.Length);<br>        Length = length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>        &#123;<br>            Data[i] = data[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> a, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> temp = a;<br>        a = b;<br>        b = temp;<br>    &#125;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 只能算是简单交换排序，经历一遍内存循环，将最小值置于第 i 位</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort0</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; Length; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (Data[i] &gt; Data[j])<br>                &#123;<br>                    Swap(<span class="hljs-keyword">ref</span> Data[i], <span class="hljs-keyword">ref</span> Data[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowDatas</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length; i++)<br>        &#123;<br>            data[i] = Data[i];<br>        &#125;<br>        Console.WriteLine(<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">"->"</span>, data));<br>    &#125;<br><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="经典冒泡排序"><a href="#经典冒泡排序" class="headerlink" title="经典冒泡排序"></a>经典冒泡排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 经典冒泡排序，从后向前依次比较，较小值上浮</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort1</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = Length <span class="hljs-number">-1</span>; j &gt; i; j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (Data[j] &lt; Data[j<span class="hljs-number">-1</span>])<br>            &#123;<br>                Swap(<span class="hljs-keyword">ref</span> Data[j], <span class="hljs-keyword">ref</span> Data[j<span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 经典冒泡排序，从后向前依次比较，较小值上浮</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort1</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = Length <span class="hljs-number">-1</span>; j &gt; i; j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (Data[j] &lt; Data[j<span class="hljs-number">-1</span>])<br>            &#123;<br>                Swap(<span class="hljs-keyword">ref</span> Data[j], <span class="hljs-keyword">ref</span> Data[j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 优化冒泡排序，设置标记，当存在交换时，设置标记，否则退出循环</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort2</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length &amp;&amp; !flag; i++)<br>    &#123;<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = Length - <span class="hljs-number">1</span>; j &gt; i; j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (Data[j] &gt;= Data[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            Swap(<span class="hljs-keyword">ref</span> Data[j], <span class="hljs-keyword">ref</span> Data[j - <span class="hljs-number">1</span>]);<br>            flag = <span class="hljs-literal"><code class="language-hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 优化冒泡排序，设置标记，当存在交换时，设置标记，否则退出循环</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort2</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length &amp;&amp; !flag; i++)<br>    &#123;<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = Length - <span class="hljs-number">1</span>; j &gt; i; j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (Data[j] &gt;= Data[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            Swap(<span class="hljs-keyword">ref</span> Data[j], <span class="hljs-keyword">ref</span> Data[j - <span class="hljs-number">1</span>]);<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><hr><p>简单选择排序(Simple Selection Sort)就是通过 n - i 次关键字间的比较，从 n - i + 1 个记录中选出关键字最小的记录，并和第 i 个记录交换。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 简单选择排序，通过比较第 i 位与其之后的最小值，若存在，则交换</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">var</span> minIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (Data[minIndex] &gt; Data[j])<br>            &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (minIndex != i)<br>        &#123;<br>            Swap(<span class="hljs-keyword">ref</span> Data[i], <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 简单选择排序，通过比较第 i 位与其之后的最小值，若存在，则交换</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">var</span> minIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (Data[minIndex] &gt; Data[j])<br>            &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (minIndex != i)<br>        &#123;<br>            Swap(<span class="hljs-keyword">ref</span> Data[i], <span class="hljs-keyword">ref</span> Data[minIndex]);<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><hr><p>直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排序好的有序表中，从而得到一个新的、记录数加一的有序表。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 每次遍历将第 i 位记录取出，将之前的记录后移，再将第 i 位记录置于正确位置</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertionSort</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Data[i] &gt;= Data[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">var</span> temp = Data[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i<span class="hljs-number">-1</span>; j &gt;=<span class="hljs-number">0</span> &amp;&amp; Data[j] &gt; temp; j--)<br>        &#123;<br>            Swap(<span class="hljs-keyword">ref</span> Data[j+<span class="hljs-number">1</span>], <span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 每次遍历将第 i 位记录取出，将之前的记录后移，再将第 i 位记录置于正确位置</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertionSort</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Data[i] &gt;= Data[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">var</span> temp = Data[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i<span class="hljs-number">-1</span>; j &gt;=<span class="hljs-number">0</span> &amp;&amp; Data[j] &gt; temp; j--)<br>        &#123;<br>            Swap(<span class="hljs-keyword">ref</span> Data[j+<span class="hljs-number">1</span>], <span class="hljs-keyword">ref</span> Data[j]);<br>        &#125;<br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><hr><p>快速排序(Quick Sort)的基本思想是: 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分继续进行排序，以达到整个序列有序的目的。</p><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> low = left;<br>    <span class="hljs-keyword">var</span> high = right;<br>    <span class="hljs-keyword">var</span> temp = Data[left];<br><br>    <span class="hljs-keyword">if</span> (left &gt; right)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (low != high)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (Data[high] &gt;= temp &amp;&amp; low &lt; high)<br>        &#123;<br>            high--;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (Data[low] &lt;= temp &amp;&amp; low &lt; high)<br>        &#123;<br>            low++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (low &lt; high)<br>        &#123;<br>            Swap(<span class="hljs-keyword">ref</span> Data[low], <span class="hljs-keyword">ref</span> Data[high]);<br>        &#125;<br>    &#125;<br><br>    Swap(<span class="hljs-keyword">ref</span> Data[low], <span class="hljs-keyword">ref</span> Data[left]);<br>    QuickSort(left, low - <span class="hljs-number">1</span>);<br>    QuickSort(low + <span class="hljs-number"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> low = left;<br>    <span class="hljs-keyword">var</span> high = right;<br>    <span class="hljs-keyword">var</span> temp = Data[left];<br><br>    <span class="hljs-keyword">if</span> (left &gt; right)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (low != high)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (Data[high] &gt;= temp &amp;&amp; low &lt; high)<br>        &#123;<br>            high--;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (Data[low] &lt;= temp &amp;&amp; low &lt; high)<br>        &#123;<br>            low++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (low &lt; high)<br>        &#123;<br>            Swap(<span class="hljs-keyword">ref</span> Data[low], <span class="hljs-keyword">ref</span> Data[high]);<br>        &#125;<br>    &#125;<br><br>    Swap(<span class="hljs-keyword">ref</span> Data[low], <span class="hljs-keyword">ref</span> Data[left]);<br>    QuickSort(left, low - <span class="hljs-number">1</span>);<br>    QuickSort(low + <span class="hljs-number">1</span>, right);<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇开始，我们来看看在工作中比较常用的两大算法之一的&lt;strong&gt;排序&lt;/strong&gt;算法。&lt;/p&gt;
&lt;h2 id=&quot;基本概念及分类&quot;&gt;&lt;a href=&quot;#基本概念及分类&quot; class=&quot;headerlink&quot; title=&quot;基本概念及分类&quot;&gt;&lt;/a&gt;基本概念及分类&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E4%B8%80)/"/>
    <id>https://1ess.github.io/MySQL(%E4%B8%80)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>从本篇开始，我们来说说最流行的数据库 —— 关于 MySQL 的那些事儿。</p><h2 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h2><hr><p>数据库(Database)是按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库。</p><blockquote><p>人们通常用数据库这个术语来代表他们使用的数据库软件。这是不正确的，它是引起混淆的根源。确切地说，数据库软件应称为 DBMS(数据库管理系统)。数据库是通过 DBMS 创建和操纵的容器。数据库可以是保存在硬设备上的文件，但也可以不是。在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库; 你使用的是 DBMS，它替你访问数据库。</p></blockquote><h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><ul><li>关系数据库(Relational Database)</li><li>非关系数据库(NoSQL)</li></ul><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>关系型数据库是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。现如今虽然对此模型有一些批评意见，但它还是数据存储的传统标准。</p><p>关系模型由<strong>关系数据结构</strong>、<strong>关系操作集合</strong>、<strong>关系完整性约束</strong>三部分组成。</p><p>标准数据查询语言 SQL 就是一种基于关系数据库的语言，这种语言执行对关系数据库中数据的检索和操作。</p><p>典型的关系型数据库: </p><ul><li>MySQL</li><li>PostgreSQL</li><li>SQL Server</li><li>Oracle</li><li>Sqlite</li><li>DB2</li></ul><p>几乎所有的数据库管理系统都配备了一个开放式数据库连接(ODBC)驱动程序，令各个数据库之间得以互相集成。</p><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p>NoSQL 一词最早出现于1998年，是 Carlo Strozzi 开发的一个轻量、开源、不提供 SQL 功能的关系数据库。当代典型的关系数据库在一些数据敏感的应用中表现了糟糕的性能，例如为巨量文档创建索引、高流量网站的网页服务，以及发送流式媒体。关系型数据库的典型实现主要被调整用于执行规模小而读写频繁，或者大批量极少写访问的事务。</p><p>典型的非关系型数据库: </p><ol><li>Key/value 硬盘存储</li></ol><ul><li>LevelDB</li><li>MemcacheDB</li></ul><ol start="2"><li>Key/value RAM 存储</li></ol><ul><li>Redis</li><li>memcached</li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><hr><p>结构化查询语言(Structured Query Language)简称 SQL，是一种特殊的编程语言，是一种数据库查询和程序设计语言，用于存储、查询、更新数据和管理关系数据库系统，同时也是数据库脚本文件的扩展名。</p><h3 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h3><ol><li>数据查询语言(Data Query Language，DQL): 代表指令 SELECT/SHOW</li><li>数据操作语言(Data Manipulation Language，DML): 代表指令 INSERT/UPDATE/DELETE</li><li>事务处理语言(Transaction Process Language，TPL): 代表指令 BEGIN TRANSACTION/COMMIT/ROLLBACK</li><li>数据控制语言(Data Control Language，DCL): 代表指令 GRANT/REVOKE</li><li>数据定义语言(Data Definition Language，DDL): 代表指令 CREATE/DROP</li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><hr><p>MySQL 是一种关系型数据库管理系统，目前属于 Oracle 旗下产品。</p><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ol><li>直接去<a href="https://dev.mysql.com/downloads/installer/">官网</a>下载 MySQL，双击安装</li><li>配置环境变量，指向 mysql 的 bin 目录(默认路径: C:\Program Files\MySQL\MySQL Server 8.0\bin)</li><li>配置初始化的 my.ini 配置文件</li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre class="line-numbers language-hljs csharp">[<span class="hljs-meta">mysqld</span>]<br><span class="hljs-meta"># 设置3306端口</span><br>port=<span class="hljs-number">3306</span><br><span class="hljs-meta"># 设置mysql的安装目录</span><br>basedir=C:\Program Files\MySQL\MySQL Server <span class="hljs-number">8.0</span>\<br><span class="hljs-meta"># 设置mysql数据库的数据的存放目录</span><br>datadir=C:\Program Files\MySQL\MySQL Server <span class="hljs-number">8.0</span>\Data<br><span class="hljs-meta"># 允许最大连接数</span><br>max_connections=<span class="hljs-number">200</span><br><span class="hljs-meta"># 允许连接失败的次数。</span><br>max_connect_errors=<span class="hljs-number">10</span><br><span class="hljs-meta"># 服务端使用的字符集默认为UTF8</span><br>character-<span class="hljs-keyword">set</span>-server=utf8<br><span class="hljs-meta"># 创建新表时将使用的默认存储引擎</span><br><span class="hljs-literal">default</span>-storage-engine=INNODB<br><span class="hljs-meta"># 默认使用&quot;mysql_native_password&quot;插件认证</span><br><span class="hljs-meta">#mysql_native_password</span><br>default_authentication_plugin=mysql_native_password<br>[<span class="hljs-meta">mysql</span>]<br><span class="hljs-meta"># 设置mysql客户端默认字符集</span><br><span class="hljs-literal">default</span>-character-<span class="hljs-keyword">set</span>=utf8<br>[<span class="hljs-meta">client</span>]<br><span class="hljs-meta"># 设置mysql客户端连接服务端时默认使用的端口</span><br>port=<span class="hljs-number">3306</span><br><span class="hljs-literal">default</span>-character-<span class="hljs-keyword"><code class="language-hljs csharp">[<span class="hljs-meta">mysqld</span>]<br><span class="hljs-meta"># 设置3306端口</span><br>port=<span class="hljs-number">3306</span><br><span class="hljs-meta"># 设置mysql的安装目录</span><br>basedir=C:\Program Files\MySQL\MySQL Server <span class="hljs-number">8.0</span>\<br><span class="hljs-meta"># 设置mysql数据库的数据的存放目录</span><br>datadir=C:\Program Files\MySQL\MySQL Server <span class="hljs-number">8.0</span>\Data<br><span class="hljs-meta"># 允许最大连接数</span><br>max_connections=<span class="hljs-number">200</span><br><span class="hljs-meta"># 允许连接失败的次数。</span><br>max_connect_errors=<span class="hljs-number">10</span><br><span class="hljs-meta"># 服务端使用的字符集默认为UTF8</span><br>character-<span class="hljs-keyword">set</span>-server=utf8<br><span class="hljs-meta"># 创建新表时将使用的默认存储引擎</span><br><span class="hljs-literal">default</span>-storage-engine=INNODB<br><span class="hljs-meta"># 默认使用&quot;mysql_native_password&quot;插件认证</span><br><span class="hljs-meta">#mysql_native_password</span><br>default_authentication_plugin=mysql_native_password<br>[<span class="hljs-meta">mysql</span>]<br><span class="hljs-meta"># 设置mysql客户端默认字符集</span><br><span class="hljs-literal">default</span>-character-<span class="hljs-keyword">set</span>=utf8<br>[<span class="hljs-meta">client</span>]<br><span class="hljs-meta"># 设置mysql客户端连接服务端时默认使用的端口</span><br>port=<span class="hljs-number">3306</span><br><span class="hljs-literal">default</span>-character-<span class="hljs-keyword">set</span>=utf8<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="4"><li>在 MySQL 的安装目录的仓目录下执行命令: </li></ol><figure class="highlight sh"><table><tr><td class="code"><pre class="line-numbers language-hljs sh"><code class="language-hljs sh">mysqld --initialize --console<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="5"><li>在管理员权限下执行命令: </li></ol><figure class="highlight sh"><table><tr><td class="code"><pre class="line-numbers language-hljs sh"><code class="language-hljs sh">mysqld --install<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 如果提示服务已存在，则需要执行命令: </p><figure class="highlight sh"><table><tr><td class="code"><pre class="line-numbers language-hljs sh"><code class="language-hljs sh">sc delete mysql<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p>我们直接使用 homebrew 安装: </p><figure class="highlight sh"><table><tr><td class="code"><pre class="line-numbers language-hljs sh"><code class="language-hljs sh">brew install mysql<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>与 Windows 类似，我们还可以修改 Mysql 中配置文件，位于目录 /usr/bin/etc/my.cnf。</p><h3 id="启动和停止-MySQL-服务"><a href="#启动和停止-MySQL-服务" class="headerlink" title="启动和停止 MySQL 服务"></a>启动和停止 MySQL 服务</h3><p>MySQL 是一种 C/S 架构，包括客户端和服务端。<br>服务端对应的软件: mysqld.exe<br>客户端对应的软件: mysql.exe</p><h4 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h4><h5 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h5><figure class="highlight sh"><table><tr><td class="code"><pre class="line-numbers language-hljs sh"><span class="hljs-comment"># 启动 mysql 服务</span><br>net start mysql<br><br><span class="hljs-comment"><code class="language-hljs sh"><span class="hljs-comment"># 启动 mysql 服务</span><br>net start mysql<br><br><span class="hljs-comment"># 关闭 mysql 服务</span><br>net stop mysql<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h5 id="系统服务方式"><a href="#系统服务方式" class="headerlink" title="系统服务方式"></a>系统服务方式</h5><p>在计算机管理-服务(services.msc)中操作 mysql 服务。</p><h4 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a>Mac</h4><figure class="highlight sh"><table><tr><td class="code"><pre class="line-numbers language-hljs sh"><span class="hljs-comment"># 启动 mysql 服务</span><br>brew services start mysql<br><br><span class="hljs-comment"><code class="language-hljs sh"><span class="hljs-comment"># 启动 mysql 服务</span><br>brew services start mysql<br><br><span class="hljs-comment"># 关闭 mysql 服务</span><br>brew services stop mysql<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="登录和退出-MySQL-系统"><a href="#登录和退出-MySQL-系统" class="headerlink" title="登录和退出 MySQL 系统"></a>登录和退出 MySQL 系统</h3><p>通过客户端 mysql.exe 与服务器连接认证。</p><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>连接认证语法: </p><figure class="highlight sh"><table><tr><td class="code"><pre class="line-numbers language-hljs sh"><code class="language-hljs sh">mysql -h&#123;ip地址或域名&#125; -P&#123;mysql 监听端口，通常3306&#125; -u&#123;用户名&#125; -p<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>我们使用完 mysql 之后，由于连接数量有限，所以注意一定要断开连接。</p><figure class="highlight sh"><table><tr><td class="code"><pre class="line-numbers language-hljs sh">\q<br>\quit<br><span class="hljs-built_in"><code class="language-hljs sh">\q<br>\quit<br><span class="hljs-built_in">exit</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: Mysql 8.0 版本和 Mysql 5.7 版本的身份验证插件不同: </p><ul><li>Mysql 8.0 身份验证插件为 caching_sha2_password</li><li>Mysql 5.7 身份验证插件为 mysql_native_password</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从本篇开始，我们来说说最流行的数据库 —— 关于 MySQL 的那些事儿。&lt;/p&gt;
&lt;h2 id=&quot;数据库概念&quot;&gt;&lt;a href=&quot;#数据库概念&quot; class=&quot;headerlink&quot; title=&quot;数据库概念&quot;&gt;&lt;/a&gt;数据库概念&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;数据库(Data</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E4%BA%8C)/"/>
    <id>https://1ess.github.io/MySQL(%E4%BA%8C)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们来说说 SQL 的基本操作 —— 库操作、表操作以及数据操作。</p><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><hr><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>基本语法: create database {数据库名} [库选项];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 创建数据库</span><br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 创建数据库</span><br><span class="hljs-keyword">create</span> database mydatabase;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>库选项: </p><ul><li>字符集: charset {指定字符集}，不指定则采用安装时默认字符集</li><li>校对集: collate {指定校对集}</li></ul><h3 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h3><h4 id="显示全部"><a href="#显示全部" class="headerlink" title="显示全部"></a>显示全部</h4><p>基本语法: show databases;</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 显示全部数据库</span><br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 显示全部数据库</span><br><span class="hljs-keyword">show</span> databases;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="显示部分"><a href="#显示部分" class="headerlink" title="显示部分"></a>显示部分</h4><p>基本语法: show databases like ‘{模式匹配}’;</p><ul><li>_: 匹配当前位置单个字符</li><li>%: 匹配指定位置多个字符</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 显示部分数据库</span><br><span class="hljs-keyword">show</span> databases <span class="hljs-keyword">like</span> <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-comment">-- 显示部分数据库</span><br><span class="hljs-keyword">show</span> databases <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;my%&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="显示数据库创建语句"><a href="#显示数据库创建语句" class="headerlink" title="显示数据库创建语句"></a>显示数据库创建语句</h4><p>基本语法: show create database {数据库名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 显示数据库创建语句</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 显示数据库创建语句</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> database mydatabase;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p>基本语法: use {数据库名};<br>在命令行会出现: Database changed</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-comment">-- 选择数据库</span><br>use mydatabase;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>5.5 版本之后，只能修改库选项，不能再修改库名了。<br>基本语法: alter databse {数据库名} {库选项};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 修改库选项</span><br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 修改库选项</span><br><span class="hljs-keyword">alter</span> database mydatabase charset gbk;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>基本语法: drop database {数据库名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 删除数据库</span><br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 删除数据库</span><br><span class="hljs-keyword">drop</span> database mydatabase;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><hr><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><h4 id="普通创建表"><a href="#普通创建表" class="headerlink" title="普通创建表"></a>普通创建表</h4><p>基本语法: create table {表名}(字段 字段类型 [字段属性], …) [表选项];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 普通创建表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> mydatabase.class(name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-comment">-- 或者</span><br>use mydatabase;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> class(name <span class="hljs-type">varchar</span>(<span class="hljs-number"><code class="language-hljs sql"><span class="hljs-comment">-- 普通创建表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> mydatabase.class(name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-comment">-- 或者</span><br>use mydatabase;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> class(name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 表必须放在对应的数据库之下，有两种方式: </p><ol><li>在表名前加上数据库名，用”.”连接</li><li>在创建表之前，先选择数据库(即 use {数据库名};)</li></ol><p>表选项与库选项类似，包括: </p><ol><li>存储引擎: engine {引擎名}</li><li>字符集: charset {字符集}</li><li>校对集: collate {校对集}</li></ol><h4 id="复制已存在表结构"><a href="#复制已存在表结构" class="headerlink" title="复制已存在表结构"></a>复制已存在表结构</h4><p>基本语法: create table {表名} like {表名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 复制表结构</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> mydatabase.test <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 复制表结构</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> mydatabase.test <span class="hljs-keyword">like</span> mydatabase2.class;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="显示数据表"><a href="#显示数据表" class="headerlink" title="显示数据表"></a>显示数据表</h3><h4 id="显示全部-1"><a href="#显示全部-1" class="headerlink" title="显示全部"></a>显示全部</h4><p>基本语法: show tables;</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 显示全部数据表</span><br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 显示全部数据表</span><br><span class="hljs-keyword">show</span> tables;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="显示部分-1"><a href="#显示部分-1" class="headerlink" title="显示部分"></a>显示部分</h4><p>基本语法: show tables like ‘{模式匹配}’;</p><ul><li>_: 匹配当前位置单个字符</li><li>%: 匹配指定位置多个字符</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 显示部分数据表</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-comment">-- 显示部分数据表</span><br><span class="hljs-keyword">show</span> tables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;c%&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="显示表结构-字段名，字段类型，字段属性等"><a href="#显示表结构-字段名，字段类型，字段属性等" class="headerlink" title="显示表结构(字段名，字段类型，字段属性等)"></a>显示表结构(字段名，字段类型，字段属性等)</h4><p>基本语法: desc {表名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 显示表结构</span><br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 显示表结构</span><br><span class="hljs-keyword">desc</span> test;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h3><h4 id="修改表属性"><a href="#修改表属性" class="headerlink" title="修改表属性"></a>修改表属性</h4><p>基本语法: alter table {表名} {表选项};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 修改表选项</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 修改表选项</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test engine innodb;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><h5 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h5><p>基本语法: rename table {旧表名} to {新表名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 修改表名</span><br>rename <span class="hljs-keyword">table</span> test <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 修改表名</span><br>rename <span class="hljs-keyword">table</span> test <span class="hljs-keyword">to</span> test1;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h5 id="新增字段"><a href="#新增字段" class="headerlink" title="新增字段"></a>新增字段</h5><p>基本语法: alter table {表名} add {字段名} {字段类型} [字段属性];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 新增字段</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 <span class="hljs-keyword">add</span> age <span class="hljs-type"><code class="language-hljs sql"><span class="hljs-comment">-- 新增字段</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 <span class="hljs-keyword">add</span> age <span class="hljs-type">int</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h5 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h5><p>基本语法: alter table {表名} change {旧字段名} {新字段名} {字段类型} [字段属性];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 修改字段名</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 change age new_age <span class="hljs-type"><code class="language-hljs sql"><span class="hljs-comment">-- 修改字段名</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 change age new_age <span class="hljs-type">int</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h5 id="修改字段类型或属性"><a href="#修改字段类型或属性" class="headerlink" title="修改字段类型或属性"></a>修改字段类型或属性</h5><p>基本语法: alter table {表名} modify {字段名} {新字段类型} [新字段属性];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 修改字段类型或属性</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 modify name <span class="hljs-type">varchar</span>(<span class="hljs-number"><code class="language-hljs sql"><span class="hljs-comment">-- 修改字段类型或属性</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 modify name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><p>基本语法: alter table {表名} drop {字段名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 删除字段</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 删除字段</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 <span class="hljs-keyword">drop</span> new_age;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><p>基本语法: drop table {表名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 删除数据表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 删除数据表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> test1;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><hr><h3 id="插入数据操作"><a href="#插入数据操作" class="headerlink" title="插入数据操作"></a>插入数据操作</h3><p>基本语法: insert into {表名} [({字段1}, {字段2}, …)] values({字段值1}, {字段值2}, …); </p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test (name, age) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">-- 或者</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;Lisi&#x27;</span>, <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-comment">-- 插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test (name, age) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">-- 或者</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;Lisi&#x27;</span>, <span class="hljs-number">18</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="查询数据操作"><a href="#查询数据操作" class="headerlink" title="查询数据操作"></a>查询数据操作</h3><p>基本语法: select * from {表名} [where 字段名 =/like 字段值];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 查询数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test;<br><span class="hljs-comment">-- 或者</span><br><span class="hljs-keyword">select</span> name, age <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string"><code class="language-hljs sql"><span class="hljs-comment">-- 查询数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test;<br><span class="hljs-comment">-- 或者</span><br><span class="hljs-keyword">select</span> name, age <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Lisi&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="删除数据操作"><a href="#删除数据操作" class="headerlink" title="删除数据操作"></a>删除数据操作</h3><p>基本语法: delete from {表名} [where 字段名 =/like 字段值];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 删除数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> age<span class="hljs-operator">&gt;=</span><span class="hljs-number"><code class="language-hljs sql"><span class="hljs-comment">-- 删除数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> age<span class="hljs-operator">&gt;=</span><span class="hljs-number">20</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="更新数据操作"><a href="#更新数据操作" class="headerlink" title="更新数据操作"></a>更新数据操作</h3><p>基本语法: update {表名} set {字段名}={新值} [where 字段名 =/like 字段值];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 更新操作</span><br>update test <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">30</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string"><code class="language-hljs sql"><span class="hljs-comment">-- 更新操作</span><br>update test <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">30</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Lisi&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="其他常见命令"><a href="#其他常见命令" class="headerlink" title="其他常见命令"></a>其他常见命令</h2><h3 id="查看-MySQL-服务端版本"><a href="#查看-MySQL-服务端版本" class="headerlink" title="查看 MySQL 服务端版本"></a>查看 MySQL 服务端版本</h3><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> version();<br><span class="hljs-comment">--  +-----------+</span><br><span class="hljs-comment">--  | version() |</span><br><span class="hljs-comment">--  +-----------+</span><br><span class="hljs-comment">--  | 8.0.16    |</span><br><span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-keyword">select</span> version();<br><span class="hljs-comment">--  +-----------+</span><br><span class="hljs-comment">--  | version() |</span><br><span class="hljs-comment">--  +-----------+</span><br><span class="hljs-comment">--  | 8.0.16    |</span><br><span class="hljs-comment">--  +-----------+</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="查看当前选择的数据库"><a href="#查看当前选择的数据库" class="headerlink" title="查看当前选择的数据库"></a>查看当前选择的数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> database();<br><span class="hljs-comment">--  +------------+</span><br><span class="hljs-comment">--  | database() |</span><br><span class="hljs-comment">--  +------------+</span><br><span class="hljs-comment">--  | test       |</span><br><span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-keyword">select</span> database();<br><span class="hljs-comment">--  +------------+</span><br><span class="hljs-comment">--  | database() |</span><br><span class="hljs-comment">--  +------------+</span><br><span class="hljs-comment">--  | test       |</span><br><span class="hljs-comment">--  +------------+</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们来说说 SQL 的基本操作 —— 库操作、表操作以及数据操作。&lt;/p&gt;
&lt;h2 id=&quot;库操作&quot;&gt;&lt;a href=&quot;#库操作&quot; class=&quot;headerlink&quot; title=&quot;库操作&quot;&gt;&lt;/a&gt;库操作&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;创建数据库&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E4%B8%89)/"/>
    <id>https://1ess.github.io/MySQL(%E4%B8%89)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们再来说说 MySQL 中的列类型和列属性以及表间关系。</p><h2 id="列类型"><a href="#列类型" class="headerlink" title="列类型"></a>列类型</h2><hr><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ol><li>Tinyint: 迷你整型，采用 1 字节保存整型数据</li><li>Smallint: 小整型，采用 2 字节保存整型数据</li><li>Mediumint: 中整型，采用 3 字节保存整型数据</li><li>Int: 标准整型，采用 4 字节保存整型数据</li><li>Bigint: 大整型，采用 8 字节保存整型数据</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_int(<br>    int_1 tinyint,<br>    int_2 <span class="hljs-type">smallint</span>,<br>    int_3 mediumint,<br>    int_4 <span class="hljs-type">int</span>,<br>    int_5 <span class="hljs-type"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_int(<br>    int_1 tinyint,<br>    int_2 <span class="hljs-type">smallint</span>,<br>    int_3 mediumint,<br>    int_4 <span class="hljs-type">int</span>,<br>    int_5 <span class="hljs-type">bigint</span><br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="无符号设定"><a href="#无符号设定" class="headerlink" title="无符号设定"></a>无符号设定</h4><p>默认整型是有符号的，如果只想有正数，只需要使用 unsigned。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_int <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_int <span class="hljs-keyword">add</span> int_6 tinyint unsigned;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="显示长度"><a href="#显示长度" class="headerlink" title="显示长度"></a>显示长度</h4><p>指在数据显示的时候，最长可以显示的位数。<br>如果需要始终以最大长度显示，可以使用 zerofill 属性。<br>注意: 使用了 zerofill，一定是无符号整型。因为从左到右 0 填充。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_int <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_int <span class="hljs-keyword">add</span> int_7 tinyint zerofill;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>可以手动指定显示长度，但是不能改变该类型所能表示的最大大小，只是在 zerofill 时，不足位数时，以该位数填充。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_int <span class="hljs-keyword">add</span> int_7 tinyint(<span class="hljs-number">2</span>) zerofill;<br><span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_int <span class="hljs-keyword">add</span> int_7 tinyint(<span class="hljs-number">2</span>) zerofill;<br><span class="hljs-comment">-- 填充 1 时，显示 01，填充 100 时，显示 100</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><p>在 MySQL 中，小数类型分为: </p><ol><li>浮点型</li></ol><ul><li>Float: 单精度浮点型，采用 4 字节保存小数类型数据，精度大概在 7 位</li><li>Double: 双精度浮点型，采用 8 字节保存小数类型数据，精度大概在 15 位</li></ul><ol start="2"><li>定点型</li></ol><ul><li>Decimal</li></ul><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>基本语法: </p><ol><li>float(或 double): 不指定小数位</li><li>float(M, D)(或 double(M, D)): 表示一共存储 M 个有效数字，其中小数位占 D 位，即整数位数占 M-D 位，小数部分占 D 位</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_float(<br>    float_1 <span class="hljs-type">float</span>,<br>    float_2 <span class="hljs-type">float</span>(<span class="hljs-number">10</span>, <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_float(<br>    float_1 <span class="hljs-type">float</span>,<br>    float_2 <span class="hljs-type">float</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: float 或 double 用于不需要精确记录的小数。</p><h4 id="定点型"><a href="#定点型" class="headerlink" title="定点型"></a>定点型</h4><p>定点型可以保证数据精确的小数。小数和整数部分分开存储，<br>基本语法:<br>decimal(M, D): M 表示总长度，最大值不能超过 65，D 代表小数部分长度，最大值不能超过 30</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_decimal(<br>    decimal_1 <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br>    float_1 <span class="hljs-type">float</span>(<span class="hljs-number">10</span>, <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_decimal(<br>    decimal_1 <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br>    float_1 <span class="hljs-type">float</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ol><li>Date: 系统采用 3 个字节来存储数据，对应格式为: YYYY-mm-dd，初始值: 0000-00-00</li><li>Time: 系统采用 3 个字节来存储数据，对应格式为: HH:ii:ss，能表示的范围是: -838:59:59 ~ 838:59:59</li><li>Datetime: 就是将前面的 Date 类型和 Time 类型合并，系统采用 8 个字节来存储数据，对应格式为: YYYY-mm-dd HH:ii:ss</li><li>Timestamp: 表示从格林威治时间开始的时间戳，但是格式仍为: YYYY-mm-dd HH:ii:ss</li><li>Year: 系统采用 1 个字节来存储数据，能表示范围是 1900 ~ 2155</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_date(<br> date_1 <span class="hljs-type">date</span>,<br> date_2 <span class="hljs-type">time</span>,<br> date_3 datetime,<br> date_4 <span class="hljs-type">timestamp</span>,<br> date_5 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_date(<br> date_1 <span class="hljs-type">date</span>,<br> date_2 <span class="hljs-type">time</span>,<br> date_3 datetime,<br> date_4 <span class="hljs-type">timestamp</span>,<br> date_5 <span class="hljs-keyword">year</span><br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: timestamp 类型不能为 null，且存在默认值为当前时间戳的时间，当数据更新时，该字段自动更新。另外，通常我们也可以用整型来保存真正的时间戳。</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ol><li>Char: 定长字符，基本语法: char(L)，L 代表字符数，不论中英文，L 长度范围是 0 ~ 255</li><li>Varchar: 变长字符，基本语法: varchar(L)，L 代表字符数，不论中英文，L 长度范围是 0 ~ 65535</li><li>Text: 文本类型，存储普通字符文本</li></ol><ul><li>Tinytext: 系统使用 1 个字节来保存，实际能存储 2<sup>8</sup> + 1</li><li>Text: 系统使用 2 个字节来保存，实际能存储 2<sup>16</sup> + 2</li><li>Mediumtext: 系统使用 3 个字节来保存，实际能存储 2<sup>24</sup> + 3</li><li>Longtext: 系统使用 4 个字节来保存，实际能存储 2<sup>32</sup> + 4</li></ul><ol start="4"><li>Enum: 枚举类型，在存入之前，先预设几个项来限制可输入值，基本语法: enum({枚举值1}, {枚举值2}, …)</li><li>Set: 将多个数据项同时保存，本质是将指定的项按照对应的二进制位来控制，1 表示被选中，0 表示未被选中，基本语法: set({值1}, {值2}, …)</li></ol><p>注意: 如果数据长度超过 255 个字符，我们一般是使用 text，而不是 char 或 varchar。<br>对于 Text 类型，通常我们直接使用 Text 类型即可，系统会自动选择合适的文本类型。<br>我们还有 Blob 类型存储二进制文本，如图片，文件等，但是一般不使用，一般都是直接存储链接。<br>枚举类型在 MySQL 中实际存储的整型，注意是从 1 开始。</p><h2 id="列属性"><a href="#列属性" class="headerlink" title="列属性"></a>列属性</h2><hr><p>在 MySQL 中一共有 6 个列属性: </p><ol><li>null</li><li>默认值</li><li>列描述</li><li>主键</li><li>唯一键</li><li>自增长</li></ol><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>null 属性代表字段为空。如果为 YES，表示该字段可以为空，我们设计表时，尽量不要让数据为空。</p><h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><p>设计表时，在用户不进行数据输入时，那么会自动填充默认值。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_default(<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    age <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_default(<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    age <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span><br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>用于给开发人员进行维护的一个注释说明。<br>基本语法: comment ‘描述’</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_comment(<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;用户名，不能为空&#x27;</span>, <span class="hljs-comment">--用户名，不能为空</span><br>    pass <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码，不能为空&#x27;</span>, <span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_comment(<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;用户名，不能为空&#x27;</span>, <span class="hljs-comment">--用户名，不能为空</span><br>    pass <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码，不能为空&#x27;</span>, <span class="hljs-comment">--密码，不能为空</span><br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Primary-Key"><a href="#Primary-Key" class="headerlink" title="Primary Key"></a>Primary Key</h3><p>主键是指在一张表中，值具有唯一性的字段。</p><h4 id="创建主键"><a href="#创建主键" class="headerlink" title="创建主键"></a>创建主键</h4><h5 id="随表创建"><a href="#随表创建" class="headerlink" title="随表创建"></a>随表创建</h5><ol><li>直接在需要当作主键的字段之后，增加 primary key 属性来确定主键</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_pri1(<br>    username <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_pri1(<br>    username <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">primary</span> key<br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="2"><li>在所有字段之后增加 primary key 选项，基本语法: primary key({字段列表})</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_pri2(<br>    username <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_pri2(<br>    username <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">primary</span> key(username)<br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h5 id="表后创建"><a href="#表后创建" class="headerlink" title="表后创建"></a>表后创建</h5><p>基本语法: alter table {表名} add primary key({字段});</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_pri3 <span class="hljs-keyword">add</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_pri3 <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(username);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h4><p>基本语法: alter table {表名} drop primary key;</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_pri3 <span class="hljs-keyword">drop</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_pri3 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="复合主键"><a href="#复合主键" class="headerlink" title="复合主键"></a>复合主键</h4><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_score(<br>    student_id <span class="hljs-type">char</span>(<span class="hljs-number">10</span>),<br>    course_id <span class="hljs-type">char</span>(<span class="hljs-number">10</span>),<br>    score tinyint <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_score(<br>    student_id <span class="hljs-type">char</span>(<span class="hljs-number">10</span>),<br>    course_id <span class="hljs-type">char</span>(<span class="hljs-number">10</span>),<br>    score tinyint <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-keyword">primary</span> key(student_id, course_id)<br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ol><li>字段值不能为空</li><li>字段值不能重复</li></ol><h4 id="主键分类"><a href="#主键分类" class="headerlink" title="主键分类"></a>主键分类</h4><ol><li>业务主键</li><li>逻辑主键</li></ol><h3 id="Auto-Increment"><a href="#Auto-Increment" class="headerlink" title="Auto_Increment"></a>Auto_Increment</h3><p>给定字段该属性之后，该列数据在未被提供确定数据时，系统会根据已存在数据进行自动增长后，填充数据。通常用于逻辑主键。<br>自动增长只用于数值类型。<br>基本语法: {字段} {字段类型} auto_increment;</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_increment(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_increment(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;用户名不为空&#x27;</span>,<br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="修改自增长当前值"><a href="#修改自增长当前值" class="headerlink" title="修改自增长当前值"></a>修改自增长当前值</h4><p>一个表最多只能有一个自增长。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_increment auto_increment <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_increment auto_increment <span class="hljs-number">10</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="删除自增长"><a href="#删除自增长" class="headerlink" title="删除自增长"></a>删除自增长</h4><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_increment modify id <span class="hljs-type"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_increment modify id <span class="hljs-type">int</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="查看自增长初始变量"><a href="#查看自增长初始变量" class="headerlink" title="查看自增长初始变量"></a>查看自增长初始变量</h4><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;auto_increment%&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>auto_increment_increment 指步长，auto_increment_offset 指初始值。</p><h3 id="Unique-Key"><a href="#Unique-Key" class="headerlink" title="Unique Key"></a>Unique Key</h3><p>唯一键与主键一样，都是保证字段的数据唯一性的。不同的是: </p><ol><li>一张表只能有一个主键，但可以有多个唯一键</li><li>唯一键允许为 null，且可以有多个</li></ol><h4 id="创建唯一键"><a href="#创建唯一键" class="headerlink" title="创建唯一键"></a>创建唯一键</h4><ol><li>直接在需要当作唯一键的字段之后，增加 unique [key] 属性来确定</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_unique1(<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_unique1(<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">unique</span><br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="2"><li>在所有字段之后，增加 unique key unique key({字段列表})</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_unique2(<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_unique2(<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">unique</span> key(name)<br>) charset utf8;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="3"><li>在创建完表后，也可以创建唯一键，alter table {表名} add unique key({字段列表});</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_unique3 <span class="hljs-keyword">add</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_unique3 <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> key(name);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="删除唯一键"><a href="#删除唯一键" class="headerlink" title="删除唯一键"></a>删除唯一键</h4><p>基本语法: alter table {表名} drop index {唯一键名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_unique1 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> my_unique1 <span class="hljs-keyword">drop</span> index name;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="表间关系"><a href="#表间关系" class="headerlink" title="表间关系"></a>表间关系</h2><hr><h3 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h3><p>一张表中的一条记录与另一张表中最多只有一条记录有明确关系。通常，此方案设计为两张表中使用同样主键即可。</p><h3 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h3><p>通常一对多的关系设计方案，再多关系的表中维护一个字段，通常是一关系的主键。</p><h3 id="多对多关系"><a href="#多对多关系" class="headerlink" title="多对多关系"></a>多对多关系</h3><p>通常多对多的关系设计方案，需要再增加一张关系表来维护该关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们再来说说 MySQL 中的列类型和列属性以及表间关系。&lt;/p&gt;
&lt;h2 id=&quot;列类型&quot;&gt;&lt;a href=&quot;#列类型&quot; class=&quot;headerlink&quot; title=&quot;列类型&quot;&gt;&lt;/a&gt;列类型&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;整数类型&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E5%9B%9B)/"/>
    <id>https://1ess.github.io/MySQL(%E5%9B%9B)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们说说 MySQL 对于数据的增删改查操作以及运算符。</p><h2 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h2><hr><h3 id="多数据插入"><a href="#多数据插入" class="headerlink" title="多数据插入"></a>多数据插入</h3><p>基本语法: insert into {表名}({字段列表}) values({值列表1}), ({值列表2}), …</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_advance_insert(name, age) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">15</span>), (<span class="hljs-string">&#x27;Lisi&#x27;</span>, <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_advance_insert(name, age) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">15</span>), (<span class="hljs-string">&#x27;Lisi&#x27;</span>, <span class="hljs-number">20</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h3><p>在有的表中，使用的是业务主键，但是往往在进行数据插入时，又不确定数据表中是否存在对应的主键。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_stud (<br>    stud_id <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">primary</span> key comment <span class="hljs-string">&#x27;主键，学生ID&#x27;</span>,<br>    name <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>) charset utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;stu0001&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-string">&#x27;stu0002&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-string">&#x27;stu0003&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br><br><span class="hljs-comment">-- 主键冲突</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;stu0003&#x27;</span>, <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_stud (<br>    stud_id <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">primary</span> key comment <span class="hljs-string">&#x27;主键，学生ID&#x27;</span>,<br>    name <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>) charset utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;stu0001&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-string">&#x27;stu0002&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-string">&#x27;stu0003&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br><br><span class="hljs-comment">-- 主键冲突</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;stu0003&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>解决方案: </p><ol><li>主键冲突更新，类似插入语法，如果插入过程主键冲突，采用更新方法。基本语法: insert into {表名}({字段列表}) values({值列表1}) on duplicate key update {字段}={新值};</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 主键冲突更新</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;stu0003&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>) <span class="hljs-keyword">on</span> duplicate key update name<span class="hljs-operator">=</span><span class="hljs-string"><code class="language-hljs sql"><span class="hljs-comment">-- 主键冲突更新</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;stu0003&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>) <span class="hljs-keyword">on</span> duplicate key update name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;d&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="2"><li>主键冲突替换，先删除，再重新插入。基本语法: replace into {表名}({字段列表}) values({值列表1});</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql">replace <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;stu0001&#x27;</span>, <span class="hljs-string"><code class="language-hljs sql">replace <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;stu0001&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h3><p>基本语法: insert into {表名}({字段列表}) select * from {其他表名或本身表};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_stud2 (<br>    stud_id <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">primary</span> key comment <span class="hljs-string">&#x27;主键，学生ID&#x27;</span>,<br>    name <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>) charset utf8;<br><br><span class="hljs-comment">-- 复制到本身</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud;<br><br><span class="hljs-comment">-- 复制到新表</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud2 <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_stud2 (<br>    stud_id <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">primary</span> key comment <span class="hljs-string">&#x27;主键，学生ID&#x27;</span>,<br>    name <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>) charset utf8;<br><br><span class="hljs-comment">-- 复制到本身</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud;<br><br><span class="hljs-comment">-- 复制到新表</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_stud2 <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: </p><ol><li>蠕虫复制可以在短期快速增加数据量，从而测试表压力，测试索引效率</li><li>注意主键冲突</li></ol><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><hr><p>在更新数据时，要特别注意，通常一定要跟随条件进行更新。而且还可以使用 limit 来限制更新数量。<br>基本语法: update {表名} set {字段名}={字段值} [where 条件] [limit {数量}];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql">update my_stud <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;c&#x27;</span> limit <span class="hljs-number"><code class="language-hljs sql">update my_stud <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;c&#x27;</span> limit <span class="hljs-number">4</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><hr><p>删除数据时，也要特别注意，通常一定要跟随条件进行删除。而且也可以使用 limit 来限制删除数量。<br>基本语法: delete from {表名} [where 条件] [limit {数量}];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql">update my_stud <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;c&#x27;</span> limit <span class="hljs-number"><code class="language-hljs sql">update my_stud <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;c&#x27;</span> limit <span class="hljs-number">4</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>要注意: delete 删除数据时，无法重置 auto_increment。要解决这个问题，我们可以使用: truncate {表名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">truncate</span> my_stud; <span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-keyword">truncate</span> my_stud; <span class="hljs-comment">-- 相当于先 drop，再 create</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><hr><p>完整的查询指令: select [select 选项] {字段列表/*} from {数据源} [where 条件] [group by 分组] [having 条件] [order by 排序] [limit 数量];</p><h3 id="Select-选项"><a href="#Select-选项" class="headerlink" title="Select 选项"></a>Select 选项</h3><p>select 选项用来确定如何对待查询返回的结果。<br>可取值为: </p><ol><li>all，默认的，保存所有返回结果</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="2"><li>distinct，去重，只保留不重复的结果(所有字段值都相同才算重复)</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-operator">*</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="字段列表"><a href="#字段列表" class="headerlink" title="字段列表"></a>字段列表</h3><p>字段我们可以取别名。<br>基本语法: {字段名} [as] {别名}</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">as</span> name1, name <span class="hljs-keyword">as</span> name2 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">as</span> name1, name <span class="hljs-keyword">as</span> name2 <span class="hljs-keyword">from</span> my_stud;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="From-数据源"><a href="#From-数据源" class="headerlink" title="From 数据源"></a>From 数据源</h3><p>数据源只要是复合二位表结构的数据即可。</p><h4 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h4><p>单表数据源就是表名。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h4><p>基本语法: from {表名1}, {表名2}, …<br>结果为: 两表记录相乘，字段数拼接。<br>从前一张表的每条记录，去拼凑第二张表的所有记录。这种操作在数学上定义就是笛卡尔积，在实际中要避免笛卡尔积。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_int, my_set;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h4><p>数据源不是一个实体表，而是从表中查询出来的二维结果表，也称为子查询。<br>基本语法: from (select [select 选项] {字段列表/*} from {数据源}) as {别名};<br>注意: 子查询必须使用括号和别名。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> int_1, int_3 <span class="hljs-keyword">from</span> my_int) <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> int_1, int_3 <span class="hljs-keyword">from</span> my_int) <span class="hljs-keyword">as</span> int_alias;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Where-子句"><a href="#Where-子句" class="headerlink" title="Where 子句"></a>Where 子句</h3><p>用来从数据表获取数据时，进行条件筛选。</p><h3 id="Group-By-子句"><a href="#Group-By-子句" class="headerlink" title="Group By 子句"></a>Group By 子句</h3><p>根据指定字段，将数据进行分组。分组的目的就是用于统计。<br>基本语法: group by {字段名}<br>注意: MySQL 5.7 之后，默认开启 ONLY_FULL_GROUP_BY 选项提供对 group by 合法性的检查。一条 select 语句，MySQL 允许 target list 中输出的表达式是除聚集函数或 group by column 以外的表达式。否则就是非法的。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: group by 分组之后，只会取出每组的第一条记录。</p><p>有一些聚合函数可以使用: </p><ul><li>Count(): 统计每组数量，如果统计目标是字段，那么不会统计为 null 字段。如果是 *，则统计记录。</li><li>Avg(): 取平均值</li><li>Sum(): 求和</li><li>Max(): 求最大值</li><li>Min(): 求最小值</li><li>Group_concat(): 分组之后拼接字段</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> class_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>), <span class="hljs-built_in">max</span>(age), <span class="hljs-built_in">min</span>(height), <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">from</span> my_stu <span class="hljs-keyword">group</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> class_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>), <span class="hljs-built_in">max</span>(age), <span class="hljs-built_in">min</span>(height), <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">from</span> my_stu <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="多分组"><a href="#多分组" class="headerlink" title="多分组"></a>多分组</h4><p>按某个字段分组之后，对已分组数据再进行分组。</p><p>基本语法: group by {字段1}, {字段2}, …</p><p>先使用字段1 进行分组，分组之后再使用字段2 进行分组。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> id, gender, group_concat(name) <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> id, gender, group_concat(name) <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id, gender;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h4><p>按分组字段排序，注意: MySQL 8.0 不再进行隐式排序。必须使用 Order by 进行排序。<br>基本语法: </p><ul><li>Mysql 8.0之前: group by {字段1} [asc/desc], {字段2} [asc/desc];</li><li>Mysql 8.0之后: group by {字段1}, {字段2}, … order by {字段a} [asc/desc], {字段b} [asc/desc], … ;</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 8.0 之前</span><br><span class="hljs-keyword">select</span> id, gender, group_concat(name) <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id, gender <span class="hljs-keyword">desc</span>;<br><br><span class="hljs-comment">-- 8.0 之后</span><br><span class="hljs-keyword">select</span> id, gender, group_concat(name) <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id, gender <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> class_id <span class="hljs-keyword">asc</span>, gender <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 8.0 之前</span><br><span class="hljs-keyword">select</span> id, gender, group_concat(name) <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id, gender <span class="hljs-keyword">desc</span>;<br><br><span class="hljs-comment">-- 8.0 之后</span><br><span class="hljs-keyword">select</span> id, gender, group_concat(name) <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id, gender <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> class_id <span class="hljs-keyword">asc</span>, gender <span class="hljs-keyword">desc</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Having-子句"><a href="#Having-子句" class="headerlink" title="Having 子句"></a>Having 子句</h3><p>having 与 where 类似，都是进行条件筛选，但是也有不同点，having 用于 group by 子句之后，用于分组数据进行筛选。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> class_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> number <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id <span class="hljs-keyword">having</span> number <span class="hljs-operator">&gt;=</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">select</span> class_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> number <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id <span class="hljs-keyword">having</span> number <span class="hljs-operator">&gt;=</span> <span class="hljs-number">4</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Order-By-子句"><a href="#Order-By-子句" class="headerlink" title="Order By 子句"></a>Order By 子句</h3><p>根据字段对数据进行排序。<br>基本语法: order by {字段1} [asc/desc], {字段2} [asc/desc], …</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword">desc</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Limit-子句"><a href="#Limit-子句" class="headerlink" title="Limit 子句"></a>Limit 子句</h3><p>用来限制记录数量。</p><h4 id="记录数量限制"><a href="#记录数量限制" class="headerlink" title="记录数量限制"></a>记录数量限制</h4><p>基本语法: limit {数量};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height limit <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height limit <span class="hljs-number">1</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>利用 limit 限制获取指定区间的数量。<br>基本语法: limit {offset, length};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword">desc</span> limit <span class="hljs-number">0</span>, <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword">desc</span> limit <span class="hljs-number">0</span>, <span class="hljs-number">2</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: limit 表示最多获取数量，如果不够，就只显示真实数量。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算数运算符包括: +, -, *, /, %<br>算数运算符通常用于运算结果(select 字段中)。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> int_1 <span class="hljs-operator">+</span> int_2 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> int_1 <span class="hljs-operator">+</span> int_2 <span class="hljs-keyword">from</span> my_operator;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>需要注意: </p><ul><li>在 MySQL 中，除法运算结果是浮点数表示</li><li>除法中如果除数如果为 0，结果为 null</li><li>null 进行算术运算，结果都为 null</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符包括: &gt;, &gt;=, &lt;, &lt;=, =, &lt;&gt;<br>常用于在条件中进行结果限定。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: </p><ul><li>MySQL 中数据会自动转换成相同类型，在进行比较</li><li>MySQL 中没有布尔类型，0 表示 false，1 表示 true</li></ul><p>在关系运算符中还可以使用: between and。<br>基本语法: between {条件1} and {条件2};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">30</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: between and 中条件1 必须小于条件2，否则结果为空。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符包括: and, or, not</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">30</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="In-运算符"><a href="#In-运算符" class="headerlink" title="In 运算符"></a>In 运算符</h3><p>基本语法: in (结果1, 结果2, …);</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> age <span class="hljs-keyword">in</span> (<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> age <span class="hljs-keyword">in</span> (<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Is-运算符"><a href="#Is-运算符" class="headerlink" title="Is 运算符"></a>Is 运算符</h3><p>is 专门用来判断字段值是否为 null。<br>基本语法: is null/is not null</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> name <span class="hljs-keyword">is</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> name <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Like-运算符"><a href="#Like-运算符" class="headerlink" title="Like 运算符"></a>Like 运算符</h3><p>用来进行模糊匹配。<br>基本语法: like ‘模式匹配’;</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%a%&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们说说 MySQL 对于数据的增删改查操作以及运算符。&lt;/p&gt;
&lt;h2 id=&quot;新增数据&quot;&gt;&lt;a href=&quot;#新增数据&quot; class=&quot;headerlink&quot; title=&quot;新增数据&quot;&gt;&lt;/a&gt;新增数据&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;多数据插入&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E4%BA%94)/"/>
    <id>https://1ess.github.io/MySQL(%E4%BA%94)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们说说 MySQL 中的联合查询、连接查询以及子查询。</p><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><hr><p>基本概念: 可合并多个相似的选择查询结果的结果集，等同于将一个表追加到另一个表，从而实现将两个表的查询结果组合到一起，使用 Union 或 Union all。<br>注意: 这个合并是纵向合并，字段数不变，多个查询的结果合并。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>同一张表的不同结果，合并到一起展示</li><li>在大数据量情况，会分表操作，会使用联合查询将数据存放到一起显示</li></ol><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>select 语句 union [all/distinct(默认)] select 语句;</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql">(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword">asc</span>)<br><span class="hljs-keyword">union</span> <br>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword"><code class="language-hljs sql">(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword">asc</span>)<br><span class="hljs-keyword">union</span> <br>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword">desc</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 如果联合查询中使用 order by，必须把该 select 语句使用括号包裹。并且 MySQL 8.0 之前，为了使 order by 生效，还必须使用 limit {大数量}</p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><hr><p>基本概念: 将多张表连接到一起进行查询，会导致记录的行数和字段列数发生改变。</p><p>连接查询分类: </p><ol><li>交叉连接</li><li>内连接</li><li>外连接</li></ol><ul><li>左连接</li><li>右连接</li></ul><ol start="4"><li>自然连接</li></ol><h3 id="交叉连接-Cross-Join"><a href="#交叉连接-Cross-Join" class="headerlink" title="交叉连接(Cross Join)"></a>交叉连接(Cross Join)</h3><p>之前咱们说过多表查询时，就说过交叉查询的概念，只是语法不同。<br>基本语法: {表1} cross join {表2};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">cross</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> my_operator;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="内连接-Inner-Join"><a href="#内连接-Inner-Join" class="headerlink" title="内连接(Inner Join)"></a>内连接(Inner Join)</h3><p>从一张表中取出所有的记录，去另一张表中匹配，利用匹配条件进行匹配，成功保留，失败舍去。<br>基本语法: {表1} [inner] join {表2} on {匹配条件};<br>注意: 如果内连接没有条件，则与交叉连接返回结果一样。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">on</span> my_stud.class_id <span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">on</span> my_stud.class_id <span class="hljs-operator">=</span> my_class.id;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>由于表名可能很长，我们通常也使用表别名简化操作。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">as</span> a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> b <span class="hljs-keyword">on</span> a.class_id <span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">as</span> a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> b <span class="hljs-keyword">on</span> a.class_id <span class="hljs-operator">=</span> b.id;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 内连接只有匹配到的记录才会保留。</p><h3 id="外连接-Outer-Join"><a href="#外连接-Outer-Join" class="headerlink" title="外连接(Outer Join)"></a>外连接(Outer Join)</h3><p>一张表作为主表(表中记录都会保留)，根据条件去匹配另一张从表中的记录，从而得到目标数据。<br>外连接分为: </p><ul><li>左外连接(left join)，左表作为主表</li><li>右外连接(right join)，右表作为主表</li></ul><p>左连接基本语法: {主表} left join {从表} on {匹配条件};<br>右连接基本语法: {从表} right join {主表} on {匹配条件};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">on</span> s.class_id <span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">on</span> s.class_id <span class="hljs-operator">=</span> c.id; <br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 如果从表数据都不匹配，则返回结果该条记录从表字段值都为 null。</p><h3 id="Using-关键字"><a href="#Using-关键字" class="headerlink" title="Using 关键字"></a>Using 关键字</h3><p>是在连接查询中替代 on 关键字的。<br>使用前提是两张表连接的字段是同名的，并且最终在结果只保留一个字段。</p><p>基本语法: {表1} [inner/left/right join] {表2} using({同名字段列表});</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">using</span>(class_id);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><hr><p>当一个查询是另一个查询的条件时，称之为子查询(Sub Query)。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>按功能来分: </p><ul><li>标量子查询: 子查询返回结果是一个数据</li><li>列子查询: 返回结果是一列</li><li>行子查询: 返回结果时一行</li><li>表子查询: 返回结果是多行多列</li><li>Exists 子查询: 返回结果是 1 或 0</li></ul><p>按位置来分: </p><ul><li>Where 子查询: 子查询语句出现在 Where 子句中</li><li>From 子查询: 子查询语句出现在 From 子句中，作为数据源</li></ul><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p>标量子查询 where 子句常使用 = 或 &lt;&gt; 操作符。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">where</span> c.id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> class_id <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">as</span> s <span class="hljs-keyword">where</span> s.name <span class="hljs-operator">=</span> <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">where</span> c.id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> class_id <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">as</span> s <span class="hljs-keyword">where</span> s.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><p>列子查询 where 子句常使用 in 操作符。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">where</span> c.id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> class_id <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">where</span> c.id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> class_id <span class="hljs-keyword">from</span> my_stud);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><p>行子查询 where 子句 = 左值要是一个构造的行元素。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_class <span class="hljs-keyword">where</span> (age, height) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(age), <span class="hljs-built_in">max</span>(height) <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_class <span class="hljs-keyword">where</span> (age, height) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(age), <span class="hljs-built_in">max</span>(height) <span class="hljs-keyword">from</span> my_stud);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><p>表子查询用于 from 数据源，之前在动态查询时已经说过。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> order_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> height <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> order_stud <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_id;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="Exists-子查询"><a href="#Exists-子查询" class="headerlink" title="Exists 子查询"></a>Exists 子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">as</span> s <span class="hljs-keyword">where</span> s.class_id <span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_stud <span class="hljs-keyword">as</span> s <span class="hljs-keyword">where</span> s.class_id <span class="hljs-operator">=</span> c.id);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们说说 MySQL 中的联合查询、连接查询以及子查询。&lt;/p&gt;
&lt;h2 id=&quot;联合查询&quot;&gt;&lt;a href=&quot;#联合查询&quot; class=&quot;headerlink&quot; title=&quot;联合查询&quot;&gt;&lt;/a&gt;联合查询&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;基本概念: 可合并多个相似的选择查询</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E5%85%AD)/"/>
    <id>https://1ess.github.io/MySQL(%E5%85%AD)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇，我们说说 MySQL 中的外键、视图以及事务安全等问题。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><hr><p>如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。<br>以另一个关系的外键作为主关键字的表称为主表，具有此外键的表称为主表的从表，外键又称为外关键字。</p><h3 id="外键操作"><a href="#外键操作" class="headerlink" title="外键操作"></a>外键操作</h3><h4 id="增加外键"><a href="#增加外键" class="headerlink" title="增加外键"></a>增加外键</h4><p>MySQL 中提供两种方式增加外键: </p><ol><li><p>在创建表时，直接新增外键<br>基本语法: [constraint {外键名}] foregin key({外键字段}) references {主表}(主键);</p></li><li><p>在创建表后，再新增外键<br>基本语法: alter table {从表名} add [constraint {外键名}] foregin key({外键字段}) references {主表}(主键);</p></li></ol><h4 id="外键基本要求"><a href="#外键基本要求" class="headerlink" title="外键基本要求"></a>外键基本要求</h4><ol><li>外键字段需要保证与关联的主表的主键字段类型一致</li><li>基本属性也要相同</li><li>如果在表后增加外键，对数据有一定要求</li><li>外键只能使用 innodb 引擎</li></ol><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键约束: 通过建立外键关系之后，对主表和从表都会有一定数据约束。</p><h4 id="约束的基本概念"><a href="#约束的基本概念" class="headerlink" title="约束的基本概念"></a>约束的基本概念</h4><ol><li>当一个外键产生时，从表会受制于主表数据的存在从而导致数据不能进行某些不符合规范的操作(不能插入主表不存在的数据)</li><li>如果一个表被其他表外键引入，那么该表的数据操作就不能随意，必须保证从表数据的有效性(不能删除从表存在的数据)</li></ol><h4 id="外键约束的概念"><a href="#外键约束的概念" class="headerlink" title="外键约束的概念"></a>外键约束的概念</h4><p>可以在创建外键时，对外键约束进行选择性的操作。</p><p>基本语法: add foregin key({外键字段}) references {主表名}(主键) on {约束模式};</p><p>约束模式有三种: </p><ol><li>district，严格模式，默认，不允许操作</li><li>cascade，级联模式，一起操作变化</li><li>set null，置空模式，主表变化，从表字段置空，前提是从表该外键字段允许为空</li></ol><p>常用约束: on update cascade on delete set null;</p><h4 id="约束的作用"><a href="#约束的作用" class="headerlink" title="约束的作用"></a>约束的作用</h4><p>保证数据的完整性: 主表数据与从表数据一致。<br>但是外键很强大，但是很少使用，因为其可能会导致业务无法把握。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><hr><h3 id="视图基本操作"><a href="#视图基本操作" class="headerlink" title="视图基本操作"></a>视图基本操作</h3><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p>视图的本质是 SQL 指令(select 语句)。<br>基本语法: create view {视图名} as select 指令</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 两表具有同名字段会有问题</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> student_v <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_student <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">on</span> s.class_id <span class="hljs-operator">=</span> c.class_id;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> student_v <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> s.<span class="hljs-operator">*</span>, c.name <span class="hljs-keyword">from</span> my_student <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">on</span> s.class_id <span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-comment">-- 两表具有同名字段会有问题</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> student_v <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_student <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">on</span> s.class_id <span class="hljs-operator">=</span> c.class_id;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> student_v <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> s.<span class="hljs-operator">*</span>, c.name <span class="hljs-keyword">from</span> my_student <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">on</span> s.class_id <span class="hljs-operator">=</span> c.class_id;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h4><p>视图是一张虚拟表，可以把视图当作”表”来操作，但是视图本身没有数据，是临时执行 select 语句得到对应的结果。<br>基本语法: select 字段列表 from {视图名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student_v;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h4><p>本质是修改视图对应的查询语句。<br>基本语法: alter view {视图名} as 新 select 指令</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">view</span> student_v <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_student <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">view</span> student_v <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_student <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> my_class <span class="hljs-keyword">as</span> c <span class="hljs-keyword">using</span>(class_id);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p>基本语法: drop view {视图名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> student_v;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><hr><p>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言书写的用户程序的执行所引起的。<br>事务由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。</p><h3 id="事务的基本原理"><a href="#事务的基本原理" class="headerlink" title="事务的基本原理"></a>事务的基本原理</h3><p>MySQL(Innodb) 允许将事务统一进行管理，将用户操作暂存，不直接操作数据表，等用户确认结果之后再进行操作。<br>事务在 MySQL 中通常是<strong>自动提交</strong>，也可以<strong>手动事务</strong>。</p><h3 id="自动事务"><a href="#自动事务" class="headerlink" title="自动事务"></a>自动事务</h3><p>自动事务(autocommit): 当客户端发送一条 SQL 指令(写操作)，给服务器时，服务器在执行之后，不用等待用户反馈结果，自动将结果同步到数据表。<br>关闭自动事务: set autocommit = off;<br>一旦关闭自动事务，就需要用户来提供是否同步的指令: </p><ol><li>Commit;: 提交(同步到数据表并清空该事务)</li><li>Rollback;: 回滚(清空该事务)</li></ol><p>执行事务端的客户端，在提供是否同步指令之前，该客户端仍可以根据日志对数据加工，返回同步之后的结果。</p><p>通常我们不关闭自动事务。</p><h3 id="手动事务"><a href="#手动事务" class="headerlink" title="手动事务"></a>手动事务</h3><h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><p>从该语句开始，之后的语句都不会直接写入数据库，而是保存在事务日志中。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 开启事务</span><br><span class="hljs-keyword">start</span> transaction; <br><span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-comment">-- 开启事务</span><br><span class="hljs-keyword">start</span> transaction; <br><span class="hljs-comment">-- 有的数据库使用 begin transaction;</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><p>执行需要在事务中执行的 SQL 指令。</p><h4 id="提交事务或回滚"><a href="#提交事务或回滚" class="headerlink" title="提交事务或回滚"></a>提交事务或回滚</h4><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 提交</span><br><span class="hljs-keyword">commit</span>;<br><span class="hljs-comment">-- 回滚</span><br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 提交</span><br><span class="hljs-keyword">commit</span>;<br><span class="hljs-comment">-- 回滚</span><br><span class="hljs-keyword">rollback</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="回滚点-savepoint"><a href="#回滚点-savepoint" class="headerlink" title="回滚点(savepoint)"></a>回滚点(savepoint)</h4><p>当有一系列事务操作，可以设置回滚点，使得当有事务操作失败时，可以回到该位置重新开始执行。<br>基本语法: savepoint {回滚点名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-comment">-- 设置回滚点</span><br><span class="hljs-keyword">savepoint</span> sp1;<br><br><span class="hljs-comment">-- 回到回滚点</span><br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 设置回滚点</span><br><span class="hljs-keyword">savepoint</span> sp1;<br><br><span class="hljs-comment">-- 回到回滚点</span><br><span class="hljs-keyword">rollback</span> sp1;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="事务特点"><a href="#事务特点" class="headerlink" title="事务特点"></a>事务特点</h3><p>事务具有四个特性(ACID): </p><ol><li>原子性(Atomicity): 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚</li><li>一致性(Consistency): 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的</li><li>隔离性(Isolation): 一个事务所做的修改在最终提交以前，对其它事务是不可见的</li><li>持久性(Durability): 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失</li></ol><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/mysql/mysql1.jpg"></p><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系: </p><ul><li>只有满足一致性，事务的执行结果才是正确的</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性</li><li>事务满足持久化是为了能应对数据库崩溃的情况</li></ul><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><p>MySQL 中提供了两种封锁粒度: </p><ul><li>行级锁</li><li>表级锁</li></ul><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h4 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h4><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul><li>排它锁(Exclusive)，简写为 X 锁，又称写锁</li><li>共享锁(Shared)，简写为 S 锁，又称读锁</li></ul><p>有以下两个规定: </p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</li></ul><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。<br>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定: </p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><ol><li>一级封锁协议: 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖</li><li>二级封锁协议: 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据</li><li>三级封锁协议: 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇，我们说说 MySQL 中的外键、视图以及事务安全等问题。&lt;/p&gt;
&lt;h2 id=&quot;外键&quot;&gt;&lt;a href=&quot;#外键&quot; class=&quot;headerlink&quot; title=&quot;外键&quot;&gt;&lt;/a&gt;外键&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;如果公共关键字在一个关系中是主关键字，那么这个公共关</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/MySQL(%E4%B8%83)/"/>
    <id>https://1ess.github.io/MySQL(%E4%B8%83)/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是 MySQL 的最后一篇，我们最后讲讲变量、函数、存储过程和触发器。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr><p>MySQL 需要很多变量来保存数据。</p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>系统内部定义的变量，系统变量针对所有用户有效。</p><h4 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h4><p>基本语法: show variables [{模式匹配}];</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="查看系统变量实际值"><a href="#查看系统变量实际值" class="headerlink" title="查看系统变量实际值"></a>查看系统变量实际值</h4><p>基本语法: select @@{变量名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable"><code class="language-hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable">@autocommit</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="修改系统变量"><a href="#修改系统变量" class="headerlink" title="修改系统变量"></a>修改系统变量</h4><h5 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h5><p>只针对当前客户端的本次连接。<br>基本语法: set {变量名} = {新变量值};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h5 id="全局修改"><a href="#全局修改" class="headerlink" title="全局修改"></a>全局修改</h5><p>针对”所有”客户端”所有”时刻。<br>基本语法: set global {变量名} = {新变量值}; 或者 set @@global.{变量名} = {新变量值};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 或者</span><br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@global</span>.autocommit <span class="hljs-operator">=</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 或者</span><br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@global</span>.autocommit <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 全局修改只针对新客户端有效。</p><h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><p>会话变量又称为用户变量，只针对当前用户使用的当前客户端有效。</p><h4 id="定义用户变量"><a href="#定义用户变量" class="headerlink" title="定义用户变量"></a>定义用户变量</h4><p>基本语法: set @{变量名} = {变量值};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@name</span> :<span class="hljs-operator">=</span> <span class="hljs-string"><code class="language-hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@name</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Hello world&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>注意: 使用 := 是因为 MySQL 中 = 还有比较的含义，为了避免搞混，可以使用 := 来进行赋值操作。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量使用 declare 关键字声明，并且出现在 begin 和 end 语句之间。<br>基本语法: declare {变量名} {数据类型};</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><hr><p>所有函数都是使用: select 函数名(参数列表);</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>char_length(): 判断字符数</li><li>length(): 判断字节数(与字符集有关)</li><li>concat(): 连接字符串</li><li>instr(): 判断字符在目标字符串中是否存在，存在返回位置(从 1 开始)，不存在返回 0</li><li>lcase(): 全部小写</li><li>left(): 从左侧开始截取到指定位置字符串</li><li>ltrim(): 清除左侧空格</li><li>mid(): 从指定位置开始截取字符串到最后</li></ul><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>now(): 返回当前时间，日期和时间</li><li>curdate(): 返回当前日期</li><li>curtime(): 返回当前时间</li><li>datediff(): 判断两日期天数差距</li><li>date_add(): 进行时间增加</li><li>unix_timestamp(): 获取时间戳(10 位)</li><li>from_unixtime(): 从时间戳转为日期时间</li></ul><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><ul><li>abs(): 绝对值</li><li>ceiling(): 向上取整</li><li>floor(): 向下取整</li><li>pow(): 求指数</li><li>rand(): 取随机数</li><li>round(): 四舍五入</li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>简称过程(procedure)，是一组为了完成特定功能的 SQL 语句集。并且在一次编译之后无需再次编译，效率较高。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>基本语法:<br>create procedure {过程名}([参数列表])<br> begin<br>  {过程体}<br> end<br>{结束符};</p><p>如果过程体中只有一条语句，可以省略 begin 和 end。</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> my_proc()<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_student;<br><br>delimiter $$<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> my_proc()<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> i <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">set</span> <span class="hljs-variable">@sum</span> :<span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    while i <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100</span> do<br>     <span class="hljs-keyword">set</span> <span class="hljs-variable">@sum</span> <span class="hljs-operator">=</span> <span class="hljs-variable">@sum</span> <span class="hljs-operator">+</span> i;<br>     <span class="hljs-keyword">set</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">end</span> while;<br>     <span class="hljs-keyword">select</span> <span class="hljs-variable">@sum</span>;<br><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> my_proc()<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> my_student;<br><br>delimiter $$<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> my_proc()<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> i <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">set</span> <span class="hljs-variable">@sum</span> :<span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    while i <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100</span> do<br>     <span class="hljs-keyword">set</span> <span class="hljs-variable">@sum</span> <span class="hljs-operator">=</span> <span class="hljs-variable">@sum</span> <span class="hljs-operator">+</span> i;<br>     <span class="hljs-keyword">set</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">end</span> while;<br>     <span class="hljs-keyword">select</span> <span class="hljs-variable">@sum</span>;<br><span class="hljs-keyword">end</span><br>$$<br>delimiter;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="查看过程"><a href="#查看过程" class="headerlink" title="查看过程"></a>查看过程</h4><p>基本语法: show procedure stutas;</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">procedure</span> stutas;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>基本语法: call {过程名}([参数列表]);</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">call</span> my_proc();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h4><p>基本语法: drop procedure {过程名};</p><figure class="highlight sql"><table><tr><td class="code"><pre class="line-numbers language-hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">procedure</span> my_proc;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><hr><p>触发器(trigger)是一种特殊类型的存储过程。触发器通过事件触发而被执行。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>在写入数据表之前，强制检验或转换数据</li><li>触发器发生错误，异动的结果会被撤销</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><ol><li>可以实现表的级联更改</li></ol><ul><li>缺点</li></ul><ol><li>对触发器过分依赖，会影响数据库结构，增加维护的复杂程度</li><li>造成数据在程序层面不可控</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇是 MySQL 的最后一篇，我们最后讲讲变量、函数、存储过程和触发器。&lt;/p&gt;
&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;MySQL 需要很多变量来保存数据。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E4%B9%9D%E4%B9%9D%E5%BD%92%E4%B8%80/"/>
    <id>https://1ess.github.io/%E4%B9%9D%E4%B9%9D%E5%BD%92%E4%B8%80/</id>
    <published>2021-07-14T12:57:47.824Z</published>
    <updated>2021-07-14T12:57:47.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Two things are infinite: the universe and human stupidity; and I’m not sure about the universe.</p></blockquote><p>最近离职了，说不上为什么，就是有一种感觉不能再这样下去了，我不想单纯的经历”吃饭-上班-吃饭-睡觉”这样浑浑噩噩的日子。我希望可以做些什么，我希望可以用我的技术、经验来为这个世界做些什么。</p><p>我一直信奉一句话，种一棵树最好的时间是十年前，其次是现在。很多人劝我年后离职等等，但是我不想也不愿意等，想做的事情我希望立马去做。也正好可以趁这段时间多想想多看看。</p><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/other/other4.jpg"></p><p><sub>在辞职之后的三天零五小时八分钟，我又路过了景江西路，只是这一次，没有下车。</sub></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Two things are infinite: the universe and human stupidity; and I’m not sure about the universe.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近离职了，说</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/JavaScript(%E5%8D%81%E4%B8%89)/"/>
    <id>https://1ess.github.io/JavaScript(%E5%8D%81%E4%B8%89)/</id>
    <published>2021-07-14T12:57:47.820Z</published>
    <updated>2021-07-14T12:57:47.820Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们说说表单。<br>JavaScript 最初的一个应用，就是分担服务器处理表单的责任。</p><h2 id="表单的基础知识"><a href="#表单的基础知识" class="headerlink" title="表单的基础知识"></a>表单的基础知识</h2><hr><p>在 HTML 中，表单是由 form 元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。<br>独有的属性和方法包括: </p><ul><li>acceptCharset: 服务器能够处理的字符集，等价于 HTML 中的 accept-charset 特性</li><li>action: 接受请求的 URL，等价于 HTML 中的 action 特性</li><li>elements: 表单中所有控件的集合。</li><li>enctype: 请求的编码类型，等价于 HTML 中的 enctype 特性</li><li>length: 表单中控件的数量</li><li>method: 要发送的 HTTP 请求类型，通常是 “get” 或 “post”，等价于 HTML 的 method 特性</li><li>submit(): 提交表单</li><li>reset(): 将所有表单域重置为默认值</li></ul><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><p>使用 input 或 button 都可以定义提交按钮，只要将其 type 特性的值设置为 “submit” 即可: </p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-comment">&lt;!-- 通用提交按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit Form&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 自定义提交按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit Form<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs HTML"><span class="hljs-comment">&lt;!-- 通用提交按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit Form&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 自定义提交按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit Form<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>只要表单中存在上面列出的任何一种按钮，那么在相应表单控件拥有焦点的情况下，按回车键就可以提交该表单。<br>提交表单时可能出现的最大问题，就是重复提交表单。解决这一问题的办法有两个: </p><ol><li>在第一次提交表单后就禁用提交按钮</li><li>利用 onsubmit 事件处理程序取消后续的表单提交操作。</li></ol><h3 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h3><p>在用户单击重置按钮时，表单会被重置。使用 type 特性值为 “reset” 的 input 或 button 都可以创建重置按钮，如下: </p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-comment">&lt;!-- 通用重置按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Reset Form&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 自定义重置按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>Reset Form<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs HTML"><span class="hljs-comment">&lt;!-- 通用重置按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Reset Form&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 自定义重置按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>Reset Form<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>这两个按钮都可以用来重置表单。在重置表单时，所有表单字段都会恢复到页面刚加载完毕时的初始值。如果某个字段的初始值为空，就会恢复为空; 而带有默认值的字段，也会恢复为默认值。<br>用户单击重置按钮重置表单时，会触发 reset 事件，利用这个机会，我们可以在必要时取消重置操作。</p><h3 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h3><p>可以像访问页面中的其他元素一样，使用原生 DOM 方法访问表单元素。此外，每个表单都有 elements 属性，该属性是表单中所有元素的集合。这个 elements 集合是一个有序列表，其中包含着表单中的所有字段，每个表单字段在 elements 集合中的顺序，与它们出现在标记中的顺序相同，可以按照位置和 name 特性来访问它们。</p><h4 id="共有的表单字段属性"><a href="#共有的表单字段属性" class="headerlink" title="共有的表单字段属性"></a>共有的表单字段属性</h4><p>表单字段共有的属性和方法如下: </p><ul><li>disabled: 布尔值，表示当前字段是否被禁用</li><li>form: 指向当前字段所属表单的指针，只读</li><li>name: 当前字段的名称</li><li>readOnly: 布尔值，表示当前字段是否只读</li><li>type: 当前字段的类型，如 “checkbox”、”radio” 等等</li><li>value: 当前字段将被提交给服务器的值</li></ul><h4 id="共有的表单字段方法"><a href="#共有的表单字段方法" class="headerlink" title="共有的表单字段方法"></a>共有的表单字段方法</h4><p>每个表单字段都有两个方法: </p><ul><li>focus()</li><li>blur()</li></ul><p>HTML5 为表单字段新增了一个 autofocus 属性。在支持这个属性的浏览器中，只要设置这个属性，不用 JavaScript 就能自动把焦点移动到相应字段。</p><h4 id="共有的表单字段事件"><a href="#共有的表单字段事件" class="headerlink" title="共有的表单字段事件"></a>共有的表单字段事件</h4><p>所有表单字段都支持下列 3 个事件: </p><ul><li>blur: 当前字段失去焦点时触发</li><li>focus: 当前字段获得焦点时触发</li><li>change: 对于 input 和 textarea 元素，在它们失去焦点且 value 值改变时触发，对于 select 元素，在其选项改变时触发</li></ul><h2 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h2><hr><p>在 HTML中，有两种方式来表现文本框: </p><ul><li>使用 input 元素的单行文本框</li><li>使用 textarea 元素的多行文本框</li></ul><p>要表现文本框，必须将 input 元素的 type 特性设置为 “text”。而通过设置 size 特性，可以指定文本框中能够显示的字符数。通过 value 特性，可以设置文本框的初始值，而 maxlength 特性则用于指定文本框可以接受的最大字符数。</p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;25&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;25&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"initial value"</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>相对而言，textarea 元素则始终会呈现为一个多行文本框。要指定文本框的大小，可以使用 rows 和 cols 特性。其中，rows 特性指定的是文本框的字符行数，而 cols 特性指定的是文本框的字符列数。与 input 元素不同，textarea 的初始值必须要放在 textarea 开始和结束标签之间: </p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;25&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>initial value<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;25&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>initial value<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>另一个与 input 的区别在于，不能在 HTML 中给 textarea 指定最大字符数。</p><p>不要使用 setAttribute() 设置 input 元素的 value 特性，也不要去修改 textarea 元素的第一个子节点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">var</span> textbox = <span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].elements[<span class="hljs-string">&quot;textbox1&quot;</span>];<br>alert(textbox.value);<br><br>textbox.value = <span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-keyword">var</span> textbox = <span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].elements[<span class="hljs-string">&quot;textbox1&quot;</span>];<br>alert(textbox.value);<br><br>textbox.value = <span class="hljs-string">"Some new value"</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="HTML5-约束验证-API"><a href="#HTML5-约束验证-API" class="headerlink" title="HTML5 约束验证 API"></a>HTML5 约束验证 API</h2><hr><p>为了在将表单提交到服务器之前验证数据，HTML5 新增了一些功能。浏览器自己会根据标记中的规则执行验证，然后自己显示适当的错误消息(完全不用 JavaScript 插手)。<br>只有在某些情况下表单字段才能进行自动验证。具体来说，就是要在 HTML 标记中为特定的字段指定一些约束，然后浏览器才会自动执行表单验证。</p><h3 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h3><p>第一种情况是在表单字段中指定了 required 属性，如下面的例子所示: </p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">required</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>任何标注有 required 的字段，在提交表单时都不能空着。</p><h3 id="其他输入类型"><a href="#其他输入类型" class="headerlink" title="其他输入类型"></a>其他输入类型</h3><p>HTML5 为 input 元素的 type 属性又增加了几个值。这些新的类型不仅能反映数据类型的信息，而且还能提供一些默认的验证功能。例如: </p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span> =<span class="hljs-string">&quot;email&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span> =<span class="hljs-string">&quot;email&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"homepage"</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>“email” 类型要求输入的文本必须符合电子邮件地址的模式，而 “url” 类型要求输入的文本必须符合 URL 的模式。</p><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>HTML5 还定义了另外几个输入元素。这几个元素都要求填写某种基于数字的值: “number”、”range”、”datetime”、”datetime-local”、”date”、”month”、”week”，还有 “time”。<br>对所有这些数值类型的输入元素，可以指定 min 属性(最小的可能值)、max 属性(最大的可能值)和 step 属性(从 min 到 max 的两个刻度间的差值)。</p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"count"</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>HTML5 为文本字段新增了 pattern 属性。这个属性的值是一个正则表达式，用于匹配文本框中的值。</p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;\d+&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;\d+&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"count"</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="检测有效性"><a href="#检测有效性" class="headerlink" title="检测有效性"></a>检测有效性</h3><p>使用 checkValidity() 方法可以检测表单中的某个字段是否有效。所有表单字段都有个方法，如果字段的值有效，这个方法返回 true，否则返回 false。</p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].elements[<span class="hljs-number">0</span>].checkValidity()) &#123;<br>    <span class="hljs-comment">//字段有效，继续 </span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].elements[<span class="hljs-number">0</span>].checkValidity()) &#123;<br>    <span class="hljs-comment">//字段有效，继续 </span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//字段无效</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>要检测整个表单是否有效，可以在表单自身调用 checkValidity() 方法。如果所有表单字段都有效，这个方法返回 true，即使有一个字段无效，这个方法也会返回 false。</p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].checkValidity()) &#123;<br>    <span class="hljs-comment">//表单有效，继续</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].checkValidity()) &#123;<br>    <span class="hljs-comment">//表单有效，继续</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//表单无效</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="禁用验证"><a href="#禁用验证" class="headerlink" title="禁用验证"></a>禁用验证</h3><p>通过设置 novalidate 属性，可以告诉表单不进行验证。</p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;signup.php&quot;</span> <span class="hljs-attr">novalidate</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这里插入表单元素--&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;signup.php&quot;</span> <span class="hljs-attr">novalidate</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这里插入表单元素--&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>为了指定点击某个提交按钮不必验证表单，可以在相应的按钮上添加 formnovalidate 属性: </p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;foo.php&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这里插入表单元素--&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Regular Submit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">formnovalidate</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;btnNoValidate&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Non-validating Submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;foo.php&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这里插入表单元素--&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Regular Submit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">formnovalidate</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;btnNoValidate&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Non-validating Submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h2><hr><p>选择框是通过 select 元素和 option 元素创建的。<br>HTMLSelectElement 类型提供了下列属性和方法: </p><ul><li>add(newOption, relOption): 向控件中插入新 option 元素，其位置在相关项(relOption)之前</li><li>multiple: 布尔值，表示是否允许多项选择，等价于 HTML 中的 multiple 特性</li><li>options: 控件中所有 option 元素的 HTMLCollection</li><li>remove(index): 移除给定位置的选项</li><li>selectedIndex: 基于 0 的选中项的索引，如果没有选中项，则值为 -1</li><li>size: 选择框中可见的行数，等价于 HTML 中的 size 特性</li></ul><p>选择框的 value 属性由当前选中项决定，相应规则如下: </p><ul><li>如果没有选中的项，则选择框的 value 属性保存空字符串</li><li>如果有一个选中项，而且该项的 value 特性已经在 HTML 中指定，则选择框的 value 属性等于选中项的 value 特性。即使 value 特性的值是空字符串，也同样遵循此条规则</li><li>如果有一个选中项，但该项的 value 特性在 HTML 中未指定，则选择框的 value 属性等于该项的文本</li><li>如果有多个选中项，则选择框的 value 属性将依据前两条规则取得第一个选中项的值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们说说表单。&lt;br&gt;JavaScript 最初的一个应用，就是分担服务器处理表单的责任。&lt;/p&gt;
&lt;h2 id=&quot;表单的基础知识&quot;&gt;&lt;a href=&quot;#表单的基础知识&quot; class=&quot;headerlink&quot; title=&quot;表单的基础知识&quot;&gt;&lt;/a&gt;表单的基础知识&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/JavaScript(%E5%8D%81%E5%9B%9B)/"/>
    <id>https://1ess.github.io/JavaScript(%E5%8D%81%E5%9B%9B)/</id>
    <published>2021-07-14T12:57:47.820Z</published>
    <updated>2021-07-14T12:57:47.820Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇，我们讲讲 ES6 的新特性。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr><h3 id="var-的缺点"><a href="#var-的缺点" class="headerlink" title="var 的缺点"></a>var 的缺点</h3><ol><li>可以重复声明</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;<br>alert(a);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;<br>alert(a);  <span class="hljs-comment">//5</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="2"><li>无法限制修改</li><li>没有块级作用域</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number"><code class="language-hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">12</span>;<br>&#125;<br><br>alert(a);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><p>let 和 const 解决了之前 var 的问题。首先，let 和 const 声明的变量不能重复声明。其次，使用 let 声明的变量是可以修改的，而使用 const 声明的变量是不能修改的(也就是其他语言的常量)。最后，使用 let 和 const 声明的变量有块级作用域。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><hr><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol><li>如果只有一个参数，圆括号可以省略</li><li>如果只有一个 return 语句，花括号和 return 关键字可以省略</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> addOne = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e + <span class="hljs-number">1</span>;<br>addOne(<span class="hljs-number">5</span>);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> addOne = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e + <span class="hljs-number">1</span>;<br>addOne(<span class="hljs-number">5</span>);  <span class="hljs-comment">//6</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ol><li>剩余参数(必须放在最后)</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> show = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, ...args</span>) </span>&#123;<br>    alert(a);<br>    alert(b);<br>    alert(args);<br>&#125;<br><br>show(<span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// [8, 23, 2]</span><br><br><span class="hljs-keyword">const</span> say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;name, ...rest&#125;</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(rest);<br>&#125;<br><br>say(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> show = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, ...args</span>) </span>&#123;<br>    alert(a);<br>    alert(b);<br>    alert(args);<br>&#125;<br><br>show(<span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// [8, 23, 2]</span><br><br><span class="hljs-keyword">const</span> say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;name, ...rest&#125;</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(rest);<br>&#125;<br><br>say(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;);  <span class="hljs-comment">// &#123;age: 18&#125;</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果参数不是对象，则剩余参数 rest 是数组，否则，rest 是对象。</p><ol start="2"><li>默认参数</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> show = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b = <span class="hljs-number">10</span>, c = <span class="hljs-number">20</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>    <span class="hljs-built_in">console</span>.log(b);<br>    <span class="hljs-built_in">console</span>.log(c);<br> &#125;<br>        <br>show(<span class="hljs-number"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> show = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b = <span class="hljs-number">10</span>, c = <span class="hljs-number">20</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>    <span class="hljs-built_in">console</span>.log(b);<br>    <span class="hljs-built_in">console</span>.log(c);<br> &#125;<br>        <br>show(<span class="hljs-number">99</span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="3"><li>展开运算符</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><br><span class="hljs-keyword">let</span> arr = [...arr1, ...arr2];  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><br><span class="hljs-keyword">let</span> arr = [...arr1, ...arr2];  <span class="hljs-comment">//1, 2, 3, 4, 5, 6</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p><strong>ES7 也允许对象使用展开运算符，相当于复制一个新对象</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> a = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;;<br><span class="hljs-keyword">const</span> b = &#123;...a&#125;;<br><span class="hljs-built_in"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> a = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;;<br><span class="hljs-keyword">const</span> b = &#123;...a&#125;;<br><span class="hljs-built_in">console</span>.log(b);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><hr><ol><li>左右两侧结构必须一样</li><li>声明的同时必须初始化</li><li>解构赋值也可以使用剩余参数</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(a, b, c);  <span class="hljs-comment">//1, 2, 3</span><br><br><span class="hljs-keyword">let</span> &#123;a, c, d&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">16</span>&#125;;<br><span class="hljs-built_in">console</span>.log(a, c, d);  <span class="hljs-comment">//12, 5, 16</span><br><br><span class="hljs-keyword">let</span> [&#123;a, b&#125;, [n1, n2, n3], c, d] = [&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span> : <span class="hljs-number">20</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(a, b, c, d, n1, n2, n3);  <span class="hljs-comment">//10, 20, 4, c, 1, 2, 3</span><br><br><span class="hljs-comment">//粒度控制</span><br><span class="hljs-keyword">let</span> [json, [n1, n2, n3], c, d] = [&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span> : <span class="hljs-number">20</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(json, c, d, n1, n2, n3);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(a, b, c);  <span class="hljs-comment">//1, 2, 3</span><br><br><span class="hljs-keyword">let</span> &#123;a, c, d&#125; = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">16</span>&#125;;<br><span class="hljs-built_in">console</span>.log(a, c, d);  <span class="hljs-comment">//12, 5, 16</span><br><br><span class="hljs-keyword">let</span> [&#123;a, b&#125;, [n1, n2, n3], c, d] = [&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span> : <span class="hljs-number">20</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(a, b, c, d, n1, n2, n3);  <span class="hljs-comment">//10, 20, 4, c, 1, 2, 3</span><br><br><span class="hljs-comment">//粒度控制</span><br><span class="hljs-keyword">let</span> [json, [n1, n2, n3], c, d] = [&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span> : <span class="hljs-number">20</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(json, c, d, n1, n2, n3);  <span class="hljs-comment">//object, 4, c, 1, 2, 3</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p><strong>数组和对象都可以使用解构赋值。</strong></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><hr><ol><li>includes() 方法判断元素是否存在于该数组</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(arr.includes(<span class="hljs-number">2</span>));  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(arr.includes(<span class="hljs-number">2</span>));  <span class="hljs-comment">//true</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="2"><li>for … of 循环迭代器</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> iterator <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-built_in">console</span>.log(iterator);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> iterator <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-built_in">console</span>.log(iterator);  <span class="hljs-comment">//10, 20, 30</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>由于对象不可迭代，因此无法使用 for … of 遍历对象。注意与 for … in 的区别。</p><ol start="3"><li>keys()、values()、entries() 方法</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> arr.keys()) &#123;<br>    <span class="hljs-built_in">console</span>.log(key);  <span class="hljs-comment">//0, 1, 2</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> arr.values()) &#123;<br>    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">//10, 20, 30</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> arr.entries()) &#123;<br>    <span class="hljs-built_in">console</span>.log(key);  <span class="hljs-comment">//0, 1, 2</span><br>    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> arr.keys()) &#123;<br>    <span class="hljs-built_in">console</span>.log(key);  <span class="hljs-comment">//0, 1, 2</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> arr.values()) &#123;<br>    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">//10, 20, 30</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> arr.entries()) &#123;<br>    <span class="hljs-built_in">console</span>.log(key);  <span class="hljs-comment">//0, 1, 2</span><br>    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">//10, 20, 30</span><br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><hr><ol><li>startsWith 和 endsWith</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello ES6!&#x27;</span>;<br>alert(str.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>));  <span class="hljs-comment">//true</span><br>alert(str.endsWith(<span class="hljs-number">6</span>));  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello ES6!&#x27;</span>;<br>alert(str.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>));  <span class="hljs-comment">//true</span><br>alert(str.endsWith(<span class="hljs-number">6</span>));  <span class="hljs-comment">//false</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="2"><li>字符串模板</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">`&lt;div&gt;<span class="hljs-subst">$&#123;result&#125;</span>&lt;/div&gt;`</span>;<br>alert(str);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">`&lt;div&gt;<span class="hljs-subst">$&#123;result&#125;</span>&lt;/div&gt;`</span>;<br>alert(str);  <span class="hljs-comment">//<div>10</div></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在 ES6 之前，JS 对于面向对象的支持不好，想要实现一个类，如下: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, pwd</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.pwd = pwd;<br>&#125;<br><br>User.prototype.showName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br>User.prototype.showPwd= <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.pwd);<br>&#125;;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, pwd</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.pwd = pwd;<br>&#125;<br><br>User.prototype.showName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br>User.prototype.showPwd= <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.pwd);<br>&#125;;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>);<br>user.showName();<br>user.showPwd();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>感觉很分散、别扭、不清晰，在 ES6 之后，JS 终于支持 class 关键字，可以很常规的定义一个对象了: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, pwd</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.pwd = pwd;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        alert(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">showPwd</span>(<span class="hljs-params"></span>)</span> &#123;<br>        alert(<span class="hljs-built_in">this</span>.pwd);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, pwd</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.pwd = pwd;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        alert(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">showPwd</span>(<span class="hljs-params"></span>)</span> &#123;<br>        alert(<span class="hljs-built_in">this</span>.pwd);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>);<br>user.showName();<br>user.showPwd();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 ES6 之前实现继承，也是很别扭: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VipUser</span>(<span class="hljs-params">name, pwd, level</span>) </span>&#123;<br>        User.call(<span class="hljs-built_in">this</span>, name, pwd);<br>        <span class="hljs-built_in">this</span>.level = level;<br>&#125;<br><br>VipUser.prototype = <span class="hljs-keyword">new</span> User();<br>VipUser.prototype.constructor = VipUser;<br>VipUser.prototype.showLevel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        alert(<span class="hljs-built_in">this</span>.level);<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> VipUser(<span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-number"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VipUser</span>(<span class="hljs-params">name, pwd, level</span>) </span>&#123;<br>        User.call(<span class="hljs-built_in">this</span>, name, pwd);<br>        <span class="hljs-built_in">this</span>.level = level;<br>&#125;<br><br>VipUser.prototype = <span class="hljs-keyword">new</span> User();<br>VipUser.prototype.constructor = VipUser;<br>VipUser.prototype.showLevel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        alert(<span class="hljs-built_in">this</span>.level);<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> VipUser(<span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-number">10</span>);<br>user.showName();<br>user.showPwd();<br>user.showLevel();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>在 ES6 之后，JS 支持 extends 和 super 关键字，可以很常规的继承一个对象了: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VipUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, pwd, level</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, pwd);<br>        <span class="hljs-built_in">this</span>.level = level;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">showLevel</span>(<span class="hljs-params"></span>)</span> &#123;<br>        alert(<span class="hljs-built_in">this</span>.level);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> VipUser(<span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-number"><code class="language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VipUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, pwd, level</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, pwd);<br>        <span class="hljs-built_in">this</span>.level = level;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">showLevel</span>(<span class="hljs-params"></span>)</span> &#123;<br>        alert(<span class="hljs-built_in">this</span>.level);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> VipUser(<span class="hljs-string">&#x27;1ess&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-number">10</span>);<br>user.showName();<br>user.showPwd();<br>user.showLevel();<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="set-和-get"><a href="#set-和-get" class="headerlink" title="set 和 get"></a>set 和 get</h3><p>ES6 使用 set 和 get 定义属性: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title">age</span>(<span class="hljs-params">val</span>) &#123;<br>        <span class="hljs-built_in">this</span>._age = val;<br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">age</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;1ess&#x27;</span>);<br>p.age = <span class="hljs-number">26</span>;<br><span class="hljs-built_in">console</span>.log(p.age);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title">age</span>(<span class="hljs-params">val</span>) &#123;<br>        <span class="hljs-built_in">this</span>._age = val;<br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">age</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;1ess&#x27;</span>);<br>p.age = <span class="hljs-number">26</span>;<br><span class="hljs-built_in">console</span>.log(p.age);  <span class="hljs-comment">//26</span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><hr><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol><li>必须使用双引号</li><li>所有的 key 必须使用引号包裹</li></ol><p>当我们想把 JSON 对象变为字符串时，使用 JSON.stringify() 方法。当我们想把 JSON 字符串转为对象时，使用 JSON.parse() 方法。</p><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><ol><li>当 key 与 value 同名时，可以简写: </li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> json = &#123;a, b&#125;;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ol start="2"><li>如果有方法，也可以使用简写: </li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> json = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;<br>        alert(a);  <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> json = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;<br>        alert(a);  <span class="hljs-comment">//10</span><br>    &#125;<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><hr><p>用同步一样的方式，来书写异步代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-built_in">Promise</span>.all([<br>    $.ajax(url: <span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>),<br>    $.ajax(url: <span class="hljs-string">&#x27;/b&#x27;</span>, <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>),<br>]).then(<span class="hljs-function"><span class="hljs-params">results</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> [res1, res2] = results;<br>   <span class="hljs-comment">//res1</span><br>   <span class="hljs-comment">//res2</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>    <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-built_in">Promise</span>.all([<br>    $.ajax(url: <span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>),<br>    $.ajax(url: <span class="hljs-string">&#x27;/b&#x27;</span>, <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>),<br>]).then(<span class="hljs-function"><span class="hljs-params">results</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> [res1, res2] = results;<br>   <span class="hljs-comment">//res1</span><br>   <span class="hljs-comment">//res2</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">//error</span><br>&#125;);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><hr><p>ES6 引用其他库文件的语法变化。在 ES6 之前，我们一般都是通过 require 方法把库文件导出的方法保存在一个变量中。在 ES6 当中引入了一组个新的关键字 import/export。一般我们都会在文件的开头引入我们需要使用的模块或方法。<br>我们在一个文件中导入的模块或方法是从另一个文件中导出的。如果是使用 export default 语句导出的方法，我们直接定义其变量名称，这样的方法每个文件只能导出一个: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-comment">// other.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;export default function&quot;</span>);<br>&#125;<br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> defaultFunc <span class="hljs-keyword">from</span> <span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-comment">// other.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;export default function&quot;</span>);<br>&#125;<br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> defaultFunc <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;other&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>仅用 export 导出的方法，在使用时，则需要把它们包含在大括号里: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-comment">// another.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;bar function&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123;foo, bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string"><code class="language-hljs javascript"><span class="hljs-comment">// another.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;bar function&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123;foo, bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;another&#x27;</span>;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇，我们讲讲 ES6 的新特性。&lt;/p&gt;
&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;var-的缺点&quot;&gt;&lt;a href=&quot;#var-的缺点&quot; class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/"/>
    <id>https://1ess.github.io/%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/</id>
    <published>2021-07-14T12:57:47.820Z</published>
    <updated>2021-07-14T12:57:47.820Z</updated>
    
    <content type="html"><![CDATA[<p>今天翻看照片，突然发现自己已经毕业 3 年多了，真让人感叹时光飞逝。<br>回想在学校的日子，也真是悠闲自得，没有忧愁地只想快点长大，进入社会来展示自己的才华，想起跟伙伴吹过的牛逼，也就像发生在昨天。<br>与那时的自己相比，经历了社会的染缸，变化的有很多，但是希望依靠自己的双手创造更好的生活的初心始终没变。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/1ess/cdn/contentImg/other/graduation.jpg"></p><hr><p>说一下近期计划吧，最近把前端三大基础技术都复习了一下，接下来可能是 React 学习，或者是数据库的学习，还要再想想哪方面更急迫些。</p><blockquote><p>谁终将声震人间,必长久深自缄默。<br>谁终将点燃闪电,必长久如云飘泊。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天翻看照片，突然发现自己已经毕业 3 年多了，真让人感叹时光飞逝。&lt;br&gt;回想在学校的日子，也真是悠闲自得，没有忧愁地只想快点长大，进入社会来展示自己的才华，想起跟伙伴吹过的牛逼，也就像发生在昨天。&lt;br&gt;与那时的自己相比，经历了社会的染缸，变化的有很多，但是希望依靠自己</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://1ess.github.io/React(%E4%B8%80)/"/>
    <id>https://1ess.github.io/React(%E4%B8%80)/</id>
    <published>2021-07-14T12:57:47.820Z</published>
    <updated>2021-07-14T12:57:47.820Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周工作太忙了，用 C# 写了 API、建了数据库、部署了服务器(从 Docker 迁移回了 IIS，API 在 Docker 中的访问速度不稳定，出现随机访问超时问题，应该是 Windows 下，Docker 性能有问题或 SELinux 的问题？)、写了一个钉钉的 E 应用接入公司的系统。由于一直写前台，这一段时间确实认识到了对后台的了解不够深入，但路还是得一步一步来走。</p><hr><p>言归正传，这一篇开始，我们就开始学习 React 的知识，我们首先介绍一下 React。<br>React 是由 Facebook 公司开源的一个 JS Library，官方说法是: </p><blockquote><p>A declarative, efficient, and flexible JavaScript library for building user interfaces. </p></blockquote><p>从中可以看出 React 不是一个框架，它只是一个库。它只提供 UI 层面的解决方案。在实际的项目当中，它并不能解决我们所有的问题，需要结合其它的库，例如 Redux、React-router 等来协助提供完整的解决方法。<br>我们在开发过程中常常听到组件化这个词，在前端开发中，组件化可以帮助我们解决前端结构的复用性问题，整个页面可以由这样的不同的组件组合、嵌套构成。</p><p>一个组件有自己的显示形态和行为，组件的显示形态和行为可以由数据状态(state)和配置参数(props)共同决定。数据状态和配置参数的改变都会影响到这个组件的显示形态。</p><p>当数据变化的时候，组件的显示需要更新。所以如果组件化的模式能提供一种高效的方式自动化地帮助我们更新页面，那也就可以大大地降低我们代码的复杂度，带来更好的可维护性。</p><h2 id="React-基本环境安装"><a href="#React-基本环境安装" class="headerlink" title="React 基本环境安装"></a>React 基本环境安装</h2><hr><p>想要在生产环境使用 React ，需要一堆的库以及工具来辅助: 编译阶段需要 babel、帮助管理状态需要 Redux、构建单页面应用需要 React-router 等等，这也就是所谓的 React 全家桶。</p><h3 id="npm-的安装配置"><a href="#npm-的安装配置" class="headerlink" title="npm 的安装配置"></a>npm 的安装配置</h3><p>在正式学习 React 技术栈之前，我们先来介绍一下之后经常要使用到的 npm。<br>npm 是一个基于 nodejs 的 JavaScript 包管理工具，全称叫做 node package manager。(类似于 iOS 开发中的 Cocoapods，C# 中的 NuGet)。<br>所谓的包呢，其实就是可复用的代码，每个人都可以把自己编写的代码库发布到 npm 的源(registry)上面进行管理，你也可以下载别人开发好的包，在你自己的应用当中使用。通过使用 npm 作为项目的包管理工具，我们可以很方便地在我们的开发项目中引入以及管理第三方的框架或者库，而不需要像以前，手动下载复制粘贴代码文件。</p><p>npm 的安装非常简单，不管你是用的是什么操作系统，我们只需要打开 nodejs 官网，网站会自动匹配你的系统显示相应的安装包，点击 LTS 版本的下载按钮，等待安装包下载完成。安装完成 nodejs 之后，npm 也已经自动安装到系统中了。</p><p>安装完成之后，我们可以通过: </p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash"><code class="language-hljs bash">node -v //检查 node 版本<br>npm -v //检查 npm 版本<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>由于 npm 官方的服务器在国外，在国内使用可能会遇到很多网络问题，为了方便我们的开发，你可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm。国内最稳定的镜像源是<a href="https://npm.taobao.org/">淘宝</a>提供的。</p><p>首先，以管理员身份打开命令行，输入: </p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash"><code class="language-hljs bash">npm install -g cnpm --registry=https://registry.npm.taobao.org<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>从 registry.npm.taobao.org 安装所有模块，当安装的时候发现安装的模块还没有同步过来，淘宝 NPM 会自动在后台进行同步，并且会让你从官方 NPM registry.npmjs.org 进行安装，下次你再安装这个模块的时候, 就会直接从淘宝 NPM 安装了。</p><p>然后，我们通过: </p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash"><code class="language-hljs bash">cnpm install react react-dom --save<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>来安装 React，并添加到项目依赖里。</p><h3 id="yarn-的安装配置"><a href="#yarn-的安装配置" class="headerlink" title="yarn 的安装配置"></a>yarn 的安装配置</h3><p>相比于 npm，新的包管理工具 yarn 具有极其快速、特别安全以及超级可靠的优点。我们根据<a href="https://yarnpkg.com/en/">官方文档</a>进行安装。</p><h4 id="最常用的命令如下"><a href="#最常用的命令如下" class="headerlink" title="最常用的命令如下:"></a>最常用的命令如下:</h4><ul><li>初始化新项目</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn init<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>添加依赖包</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn add [package]<br>yarn add [package]@[version]<br>yarn add [package]@[tag]<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>将依赖项添加到不同依赖项类别，分别添加到 devDependencies、peerDependencies 和 optionalDependencies</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn add [package] --dev<br>yarn add [package] --peer<br>yarn add [package] --optional<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>升级依赖包</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn upgrade [package]<br>yarn upgrade [package]@[version]<br>yarn upgrade [package]@[tag]<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>移除依赖包</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell"><code class="language-hljs shell">yarn remove [package]<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><ul><li>安装项目的全部依赖</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre class="line-numbers language-hljs shell">yarn<br><span class="hljs-meta">#</span><span class="bash"><code class="language-hljs shell">yarn<br><span class="hljs-meta">#</span><span class="bash"> 或者</span><br>yarn install<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h3 id="使用-create-react-app-命令行工具"><a href="#使用-create-react-app-命令行工具" class="headerlink" title="使用 create-react-app 命令行工具"></a>使用 create-react-app 命令行工具</h3><p>通过 cnpm，我们可以安装许多命令行工具。 React 官方专门为我们准备了专用的 React 项目生成工具 create-react-app，只需要简单几行代码即可生成 React 项目，并且在开发时还支持实时更新、自动重载等功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash">create-react-app my-app<br><span class="hljs-built_in"><code class="language-hljs bash">create-react-app my-app<br><span class="hljs-built_in">cd</span> my-app<br>cnpm start<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>或者使用 yarn 来操作: </p><figure class="highlight bash"><table><tr><td class="code"><pre class="line-numbers language-hljs bash">yarn create react-app my-app<br><span class="hljs-built_in"><code class="language-hljs bash">yarn create react-app my-app<br><span class="hljs-built_in">cd</span> my-app<br>yarn start<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><hr><p>JSX 其是一个语法扩展，它既不是单纯的字符串，也不是 HTML，虽然长得和 HTML 很像甚至基本上看起来一样。但事实上它是 React 内部实现的一种，允许我们直接在 JS 里书写 UI 的方式: </p><figure class="highlight html"><table><tr><td class="code"><pre class="line-numbers language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;box&#x27;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;content&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;title&#x27;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;box&#x27;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;content&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;title&#x27;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>上面的 DOM 可以表示成如下 JavaScript 中的对象: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript">&#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;box&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;content&#x27;</span>&#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>      <span class="hljs-attr">arrts</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>      <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Hello&#x27;</span>]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;button&#x27;</span>,<br>      <span class="hljs-attr">attrs</span>: <span class="hljs-literal">null</span>,<br>      <span class="hljs-attr">children</span>: [<span class="hljs-string"><code class="language-hljs javascript">&#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;box&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;content&#x27;</span>&#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>      <span class="hljs-attr">arrts</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>      <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Hello&#x27;</span>]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;button&#x27;</span>,<br>      <span class="hljs-attr">attrs</span>: <span class="hljs-literal">null</span>,<br>      <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Click&#x27;</span>]<br>    &#125;<br>  ]<br>&#125;<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们发现，HTML 的信息和 JavaScript 所包含的结构和信息其实是一样的，我们可以用 JavaScript 对象来描述所有能用 HTML 表示的 UI 信息。但是用 JavaScript 写起来太长了，结构看起来又不清晰，用 HTML 的方式写起来就方便很多了。<br>于是 React 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构。</p><h3 id="JSX-原理"><a href="#JSX-原理" class="headerlink" title="JSX 原理"></a>JSX 原理</h3><p>我们想要在浏览器里直接运行采用 JSX 语法的 JavaScript 显然暂时是不可能实现的，在实际的生产过程中，我们需要利用 Babel 一类的转译器来将我们的 JSX 语法或者 ES6 语法转译成浏览器可以直接运行的 JavaScript，事实上 JSX 在经过转译之后，会变成一个方法调用: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript">ReactDOM.render(<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello React!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript">ReactDOM.render(<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello React!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>转译之后就会变成下面这样: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript">ReactDOM.render(<br>    React.createElement(<span class="hljs-string">&#x27;p,&#x27;</span> <span class="hljs-literal">null</span>, <span class="hljs-string">`Hello React!`</span>),<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs javascript">ReactDOM.render(<br>    React.createElement(<span class="hljs-string">&#x27;p,&#x27;</span> <span class="hljs-literal">null</span>, <span class="hljs-string">`Hello React!`</span>),<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);<br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>React.createElement() 函数会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、还有子元素等。这样的代码就是合法的 JavaScript 代码了。所以使用 React 和 JSX 的时候一定要经过编译的过程。<br>所谓的 JSX 其实就是 JavaScript 对象。每当在 JavaScript 代码中看到这种 JSX 结构的时候，要在我们的脑海中进行自动转化，这样对理解 React 的组件写法很有好处。可以理解为: JSX 本质是一种语法糖。</p><h3 id="JSX-基本语法"><a href="#JSX-基本语法" class="headerlink" title="JSX 基本语法"></a>JSX 基本语法</h3><h4 id="JSX-元素"><a href="#JSX-元素" class="headerlink" title="JSX 元素"></a>JSX 元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span></span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>我们用 JSX 创建的元素对象一般来说是不变的，所以通过 const 关键字来声明一个 React 元素。</p><h4 id="JSX-属性"><a href="#JSX-属性" class="headerlink" title="JSX 属性"></a>JSX 属性</h4><p>JSX 的标签同样可以拥有自己的属性: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span></span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>但它和 HTML 又不是完全相同的，因为他们本质上是 JS 对象，所以 class、for 等 JS 中的关键字不可以使用，例如我们想要为 JSX 标签添加 class 的时候需要使用 className，for 需要使用 htmlFor: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-comment">// 注意使用 className 而不是 class</span><br><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-comment">// 注意使用 className 而不是 class</span><br><span class="hljs-keyword">const</span> title = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span></span>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="JSX-嵌套"><a href="#JSX-嵌套" class="headerlink" title="JSX 嵌套"></a>JSX 嵌套</h4><p>JSX 的标签也可以像 HTML 一样相互嵌套，一般有嵌套结构的 JSX 元素外面，我们习惯于为它加上一个小括号: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>需要注意的是，JSX 在嵌套时，最外层有且只能有一个标签，否则就会出错: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-comment">// 错误！</span><br><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-comment">// 错误！</span><br><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><p>如果希望渲染完成之后，DOM 中没有新增节点，我们可以使用 Fragment 组件包裹: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">const</span> title = (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> title = (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>React Learning!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure><h4 id="JSX-表达式"><a href="#JSX-表达式" class="headerlink" title="JSX 表达式"></a>JSX 表达式</h4><p>在 JSX 元素中，我们同样可以使用 JavaScript 表达式，在 JSX 当中的表达式需要用一个大括号括起来: </p><figure class="highlight javascript"><table><tr><td class="code"><pre class="line-numbers language-hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;1ess&quot;</span>;<br><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React now, &#123;name&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;1ess&quot;</span>;<br><span class="hljs-keyword">const</span> title = (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let`s learn React now, &#123;name&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span></span><br>);<br><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一周工作太忙了，用 C# 写了 API、建了数据库、部署了服务器(从 Docker 迁移回了 IIS，API 在 Docker 中的访问速度不稳定，出现随机访问超时问题，应该是 Windows 下，Docker 性能有问题或 SELinux 的问题？)、写了一个钉钉的 </summary>
      
    
    
    
    
  </entry>
  
</feed>
