

<!DOCTYPE html>
<html lang="zh-tw" xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head>
    <title>JavaScript(六) - A Sort Of A Blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Stephen Chang">
<meta name="description" content="本篇，我们讲一讲 JavaScript 中的重要对象以及常用方法。
Function 类型概述
ECMAScript 中的函数实际上是对象，每个函数都是 ...">
<meta name="keywords" content="">

<link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml">

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?2450540">

<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons"/>
</noscript>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="https://1ess.github.io">
                ホーム
            </a>
            
            <a class="a-block drawer-menu-item false" href="/archives">
                記事一覧
            </a>
            

            
            

            
            <a class="a-block drawer-menu-item" href="/atom.xml">
                RSS
            </a>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            A Sort Of A Blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">A Sort Of A Blog</div>
        <div class="single-column-header-subtitle">旧游无处不堪寻，无寻处，惟有少年心</div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            A Sort Of A Blog
        </div>
        <div class="nav-subtitle">
            旧游无处不堪寻，无寻处，惟有少年心
        </div>
    </a>

    <div class="nav-link-list">
        
        <a class="a-block no-tint nav-link-item false" href="/archives">
            記事一覧
        </a>
        

        
        

        
        <a class="a-block no-tint nav-link-item" href="/atom.xml">
            RSS
        </a>
        
    </div>

    
    <div class="nav-footer">
        &copy; 2022 <a href="https://1ess.github.io">A Sort Of A Blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>



<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper"
                 style="background-image: url('https://cdn.jsdelivr.net/gh/1ess/cdn/blogImg/Blog33.jpg')">
                <div class="post-title">
                    JavaScript(六)
                    <div class="post-meta">
                        <time datetime="2018-08-16T00:00:00.000Z" itemprop="datePublished">
                            2018-08-16
                        </time>&nbsp;
                        
    
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <p>本篇，我们讲一讲 JavaScript 中的重要对象以及常用方法。</p>
<h2 id="Function-类型概述"><a href="#Function-类型概述" class="headerlink" title="Function 类型概述"></a>Function 类型概述</h2><hr>
<p>ECMAScript 中的函数实际上是对象，每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。函数通常是使用函数声明语法定义的，如下: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这与下面使用函数表达式定义函数的方式几乎相差无几: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>以上代码定义了变量 sum 并将其初始化为一个函数。<br>注意: function 关键字后面没有函数名，这是因为在使用函数表达式定义函数时，没有必要使用函数名，我们是通过变量 sum 来引用该函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。<br>最后一种定义函数的方式是使用 Function 构造函数。Function 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。如下: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&quot;num1&quot;</span>, <span class="hljs-string">&quot;num2&quot;</span>, <span class="hljs-string">&quot;return num1 + num2&quot;</span>);  <span class="hljs-comment">// 不推荐</span><br></code></pre></td></tr></table></figure>

<p>这种语法会导致解析两次代码(第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串)，从而影响性能。</p>
<p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字，如下: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br>alert(sum(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>));        <span class="hljs-comment">//20</span><br><br><span class="hljs-keyword">var</span> anotherSum = sum;<br>alert(anotherSum(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">//20</span><br><br>sum = <span class="hljs-literal">null</span>;<br>alert(anotherSum(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">//20</span><br></code></pre></td></tr></table></figure>

<h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><hr>
<p>之前我们说过 ECMAScript 没有重载，因为函数也是对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSomeNumber</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num + <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSomeNumber</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num + <span class="hljs-number">200</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> result = addSomeNumber(<span class="hljs-number">100</span>); <span class="hljs-comment">//300</span><br></code></pre></td></tr></table></figure>

<p>这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addSomeNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num + <span class="hljs-number">100</span>;<br>&#125;;<br><br>addSomeNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num + <span class="hljs-number">200</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> result = addSomeNumber(<span class="hljs-number">100</span>); <span class="hljs-comment">//300</span><br></code></pre></td></tr></table></figure>

<h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><hr>
<p>实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式是区别对待的。解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问); 至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">alert(sum(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>));<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码完全可以正常运行。在代码开始执行之前，解析器就已经通过一个名为函数声明提升(function declaration hoisting)的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。<br>把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">alert(sum(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>));<br><span class="hljs-keyword">var</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用。</p>
<h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><hr>
<p>因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callSomeFunction</span>(<span class="hljs-params">someFunction, someArgument</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> someFunction(someArgument);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add10</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num + <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> result1 = callSomeFunction(add10, <span class="hljs-number">10</span>);<br>alert(result1);   <span class="hljs-comment">//20</span><br></code></pre></td></tr></table></figure>

<h2 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h2><hr>
<p>在函数内部，有两个特殊的对象: arguments 和 this。其中，arguments 之前说过，它是一个类数组对象，包含着传入函数中的所有参数。这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &lt;=<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> num * factorial(num-<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以使用 callee 消除与函数名的耦合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &lt;=<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> num * <span class="hljs-built_in">arguments</span>.callee(num-<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> trueFactorial = factorial;<br><br>factorial = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br><br>alert(trueFactorial(<span class="hljs-number">5</span>));     <span class="hljs-comment">//120</span><br>alert(factorial(<span class="hljs-number">5</span>));         <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>

<p>函数内部的另一个特殊对象是 this，其行为与 Java 和 C# 中的 this 大致类似。换句话说，this 引用的是函数据以执行的环境对象——或者也可以说是 this 值(当在网页的全局作用域中调用函数时，this 对象引用的就是 window)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.color = <span class="hljs-string">&quot;red&quot;</span>;<br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.color);<br>&#125;<br><br>sayColor();     <span class="hljs-comment">//&quot;red&quot;</span><br><br>o.sayColor = sayColor;<br>o.sayColor();   <span class="hljs-comment">//&quot;blue&quot;</span><br></code></pre></td></tr></table></figure>

<p>上面这个函数 sayColor() 是在全局作用域中定义的，它引用了 this 对象。由于在调用函数之前，this 的值并不确定，因此 this 可能会在代码执行过程中引用不同的对象。当在全局作用域中调用 sayColor() 时，this 引用的是全局对象 window，换句话说，对 this.color 求值会转换成对 window.color 求值，于是结果就返回了 “red”。而当把这个函数赋给对象 o 并调用 o.sayColor() 时，this 引用的是对象 o，因此对 this.color 求值会转换成对 o.color 求值，结果就返回了 “blue”。<br>注意: 函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的 sayColor() 函数与 o.sayColor() 指向的仍然是同一个函数。</p>
<p>ECMAScript 5 也规范化了另一个函数对象的属性: caller。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>    inner(); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(inner.caller);<br>&#125;<br><br>outer();<br></code></pre></td></tr></table></figure>

<p>以上代码会导致警告框中显示 outer() 函数的源代码。因为 outer() 调用了 inter()，所以 inner.caller 就指向 outer()。<br>当函数在严格模式下运行时，访问 arguments.callee 会导致错误。ECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。</p>
<h2 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h2><hr>
<p>ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性: length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayName</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    alert(name);<br>&#125;      <br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;<br><br>alert(sayName.length);      <span class="hljs-comment">//1</span><br>alert(sum.length);          <span class="hljs-comment">//2</span><br>alert(sayHi.length);        <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>

<p>对于 ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString() 和 valueOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的。在 ECMAScript 5中， prototype 属性是不可枚举的，因此使用 for-in 无法发现。<br>每个函数都包含两个非继承而来的方法: apply() 和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。<br>首先，apply() 方法接收两个参数: 一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callSum1</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> sum.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);        <span class="hljs-comment">// 传入arguments对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callSum2</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> sum.apply(<span class="hljs-built_in">this</span>, [num1, num2]);    <span class="hljs-comment">// 传入数组</span><br>&#125;<br><br>alert(callSum1(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>));   <span class="hljs-comment">//20</span><br>alert(callSum2(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>));   <span class="hljs-comment">//20</span><br></code></pre></td></tr></table></figure>

<p>在严格模式下，未指定环境对象而调用函数，则 this 值不会转型为 window。除非明确把函数添加到某个对象或者调用 apply() 或 call()，否则 this 值将是 undefined。<br>call() 方法与 apply() 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call() 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callSum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> sum.call(<span class="hljs-built_in">this</span>, num1, num2);<br>&#125;<br><br>alert(callSum(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>));   <span class="hljs-comment">//20</span><br></code></pre></td></tr></table></figure>

<p>决定使用 apply() 还是 call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply() 肯定更方便，否则，选择 call() 可能更合适。</p>
<p>事实上，传递参数并非 apply() 和 call() 真正的用武之地，它们真正强大的地方是能够扩充函数赖以运行的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.color = <span class="hljs-string">&quot;red&quot;</span>;<br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.color);<br>&#125;<br><br>sayColor();                <span class="hljs-comment">//red</span><br><br>sayColor.call(<span class="hljs-built_in">this</span>);       <span class="hljs-comment">//red</span><br>sayColor.call(<span class="hljs-built_in">window</span>);     <span class="hljs-comment">//red</span><br>sayColor.call(o);          <span class="hljs-comment">//blue</span><br></code></pre></td></tr></table></figure>

<p>使用 call()(或 apply())来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将 sayColor() 函数放到了对象 o 中，然后再通过 o 来调用它的，而在这里重写的例子中，就不需要先前那个多余的步骤了。<br>ECMAScript 5 还定义了一个方法: bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.color = <span class="hljs-string">&quot;red&quot;</span>;<br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.color);<br>&#125; <br><span class="hljs-keyword">var</span> objectSayColor = sayColor.bind(o);<br>objectSayColor();    <span class="hljs-comment">//blue</span><br></code></pre></td></tr></table></figure>

<p>每个函数继承的 toLocaleString()、toString() 和 valueOf() 方法始终都返回函数的代码，返回代码的格式则因浏览器而异。</p>
<h2 id="基本包装类型概述"><a href="#基本包装类型概述" class="headerlink" title="基本包装类型概述"></a>基本包装类型概述</h2><hr>
<p>为了便于操作基本类型值，ECMAScript 还提供了3个特殊的引用类型: Boolean、Number 和 String。<br>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。如: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&quot;some text&quot;</span>;<br><span class="hljs-keyword">var</span> s2 = s1.substring(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法。<br>其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>
<ol>
<li>创建 String 类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例</li>
</ol>
<p>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;some text&quot;</span>);<br><span class="hljs-keyword">var</span> s2 = s1.substring(<span class="hljs-number">2</span>);<br>s1 = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p>上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。<br>引用类型与基本包装类型的主要区别就是<strong>对象的生存期。</strong></p>
<ul>
<li>使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中</li>
<li>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁</li>
</ul>
<p>这意味着我们不能在运行时为基本类型值添加属性和方法。</p>
<p>可以显式地调用 Boolean、Number 和 String 来创建基本包装类型的对象。但一般不这么做。<br>对基本包装类型的实例调用 typeof 会返回 “object”，而且所有基本包装类型的对象都会被转换为布尔值 true。</p>
<p>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-string">&quot;some text&quot;</span>);<br>alert(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>);   <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> value = <span class="hljs-string">&quot;25&quot;</span>;<br><span class="hljs-keyword">var</span> number = <span class="hljs-built_in">Number</span>(value);  <span class="hljs-comment">//转型函数</span><br>alert(<span class="hljs-keyword">typeof</span> number);        <span class="hljs-comment">//&quot;number&quot;</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(value); <span class="hljs-comment">//构造函数</span><br>alert(<span class="hljs-keyword">typeof</span> obj);           <span class="hljs-comment">//&quot;object&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>Boolean 类型是与布尔值对应的引用类型。要创建 Boolean 对象，可以像下面这样调用 Boolean 构造函数并传入 true 或 false 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> booleanObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<p>Boolean 类型的实例重写了 valueOf() 方法，返回基本类型值 true 或 false，重写了 toString() 方法，返回字符串 “true” 和 “false”。<br><strong>注意: 布尔表达式中的所有对象都会被转换为 true。</strong></p>
<p>基本类型与引用类型的布尔值还有两个区别: </p>
<ul>
<li>typeof 操作符对基本类型返回 “boolean”，而对引用类型返回 “object”。</li>
<li>由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof 操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。</li>
</ul>
<p><strong>建议: 永远不要使用 Boolean 对象。</strong></p>
<h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其中传递相应的数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numberObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<p>Number 类型也重写了 valueOf()、toLocaleString() 和 toString() 方法。重写后的 valueOf() 方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值，并且，toString() 方法可以传递一个表示基数的参数，告诉它返回几进制数值的字符串形式: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>alert(num.toString());      <span class="hljs-comment">//&quot;10&quot;</span><br>alert(num.toString(<span class="hljs-number">2</span>));     <span class="hljs-comment">//&quot;1010&quot;</span><br>alert(num.toString(<span class="hljs-number">8</span>));     <span class="hljs-comment">//&quot;12&quot;</span><br>alert(num.toString(<span class="hljs-number">10</span>));    <span class="hljs-comment">//&quot;10&quot;</span><br>alert(num.toString(<span class="hljs-number">16</span>));    <span class="hljs-comment">//&quot;a&quot;</span><br></code></pre></td></tr></table></figure>

<p>Number 类型还提供了一些用于将数值格式化为字符串的方法。</p>
<ul>
<li>toFixed() 方法会按照指定的小数位返回数值的字符串表示: </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>alert(num.toFixed(<span class="hljs-number">2</span>));     <span class="hljs-comment">//&quot;10.00&quot;</span><br></code></pre></td></tr></table></figure>

<p>如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值 4 舍 5 入: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">10.005</span>;<br>alert(num1.toFixed(<span class="hljs-number">2</span>));     <span class="hljs-comment">//&quot;10.01&quot;</span><br><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">10.004</span>;<br>alert(num2.toFixed(<span class="hljs-number">2</span>));    <span class="hljs-comment">//&quot;10.00&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>toExponential() 方法返回以指数表示法表示的数值的字符串形式，toExponential() 也接收一个参数，用于指定输出结果中的小数位数: </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>alert(num.toExponential(<span class="hljs-number">1</span>));     <span class="hljs-comment">//&quot;1.0e+1&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>toPrecision() 方法可能会返回固定大小(fixed)格式，也可能返回指数(exponential)格式，具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数: </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">99</span>;<br>alert(num.toPrecision(<span class="hljs-number">1</span>));     <span class="hljs-comment">//&quot;1e+2&quot;</span><br>alert(num.toPrecision(<span class="hljs-number">2</span>));     <span class="hljs-comment">//&quot;99&quot;</span><br>alert(num.toPrecision(<span class="hljs-number">3</span>));     <span class="hljs-comment">//&quot;99.0&quot;</span><br></code></pre></td></tr></table></figure>

<p>以上代码首先完成的任务是以一位数来表示 99，结果是 “1e+2”，即 100。因为一位数无法准确地表示 99，因此 toPrecision() 就将它向上舍入为 100，这样就可以使用一位数来表示它了。而接下来的用两位数表示 99，当然还是 “99”。最后，在想以三位数表示 99 时，toPrecision() 方法返回了 “99.0”。实际上，toPrecision() 会根据要处理的数值决定到底是调用 toFixed() 还是调用 toExponential()。</p>
<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><hr>
<p>String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。<br>String 类型的每个实例都有一个 length 属性，表示字符串中包含字符个数。<br>注意: 使字符串中包含双字节字符(不是占一个字节的 ASCII 字符)，每个字符也仍然算一个字符。</p>
<p>String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。</p>
<h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>两个用于访问字符串中特定字符的方法是: </p>
<ul>
<li>charAt()</li>
<li>charCodeAt()</li>
</ul>
<p>这两个方法都接收一个参数，即基于 0 的字符位置。<br>其中，charAt() 方法以单字符字符串的形式返回给定位置的那个字符(<strong>ECMAScript 中没有字符类型</strong>): </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br>alert(stringValue.charAt(<span class="hljs-number">1</span>));   <span class="hljs-comment">//&quot;e&quot;</span><br></code></pre></td></tr></table></figure>

<p>如果你想得到的不是字符而是字符编码，那么就要使用 charCodeAt(): </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br>alert(stringValue.charCodeAt(<span class="hljs-number">1</span>));   <span class="hljs-comment">//输出&quot;101&quot;</span><br></code></pre></td></tr></table></figure>

<p>ECMAScript 5还定义了另一个访问个别字符的方法，使用方括号加数字索引来访问字符串中的特定字符: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br>alert(stringValue[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//&quot;e&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><ul>
<li>concat() 用于将一或多个字符串拼接起来，返回拼接得到的新字符串: </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello &quot;</span>;<br><span class="hljs-keyword">var</span> result = stringValue.concat(<span class="hljs-string">&quot;world&quot;</span>);<br>alert(result);             <span class="hljs-comment">//&quot;hello world&quot;</span><br>alert(stringValue);        <span class="hljs-comment">//&quot;hello&quot;</span><br></code></pre></td></tr></table></figure>

<p>concat() 方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。<br>虽然 concat() 是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符。</p>
<ul>
<li>slice() 方法会返回被操作字符串的一个子字符串，接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。<strong>第二个参数指定的是子字符串最后一个字符后面的位置</strong>: </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br>alert(stringValue.slice(<span class="hljs-number">3</span>));            <span class="hljs-comment">//&quot;lo world&quot;</span><br>alert(stringValue.slice(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>));         <span class="hljs-comment">//&quot;lo w&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>substring() 方法与 slice() 方法一样: </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br>alert(stringValue.substring(<span class="hljs-number">3</span>));        <span class="hljs-comment">//&quot;lo world&quot;</span><br>alert(stringValue.substring(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>));      <span class="hljs-comment">//&quot;lo w&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>substr() 方法会返回被操作字符串的一个子字符串，接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数指定的则是返回的字符个数: </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br>alert(stringValue.substr(<span class="hljs-number">3</span>));           <span class="hljs-comment">//&quot;lo world&quot;</span><br>alert(stringValue.substr(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>));        <span class="hljs-comment">//&quot;lo worl&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h3><p>有两个可以从字符串中查找子字符串的方法: indexOf() 和 lastIndexOf()。这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置(如果没有找到该子字符串，则返回 -1)。<br>这两个方法的区别在于: indexOf() 方法从字符串的开头向后搜索子字符串，而 lastIndexOf() 方法是从字符串的末尾向前搜索子字符串: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br>alert(stringValue.indexOf(<span class="hljs-string">&quot;o&quot;</span>));             <span class="hljs-comment">//4</span><br>alert(stringValue.lastIndexOf(<span class="hljs-string">&quot;o&quot;</span>));         <span class="hljs-comment">//7</span><br></code></pre></td></tr></table></figure>

<p>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。</p>
<h3 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h3><p>ECMAScript 5 为所有字符串定义了 trim() 方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;   hello world   &quot;</span>;<br><span class="hljs-keyword">var</span> trimmedStringValue = stringValue.trim();<br>alert(stringValue);            <span class="hljs-comment">//&quot;   hello world   &quot;</span><br>alert(trimmedStringValue);     <span class="hljs-comment">//&quot;hello world&quot; </span><br></code></pre></td></tr></table></figure>

<h3 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h3><p>ECMAScript 中涉及字符串大小写转换的方法有 4 个: </p>
<ul>
<li>toLowerCase()</li>
<li>toLocaleLowerCase()</li>
<li>toUpperCase()</li>
<li>toLocaleUpperCase()</li>
</ul>
<p>其中，toLowerCase() 和 toUpperCase() 是两个经典的方法，借鉴自 java.lang.String 中的同名方法。而 toLocaleLowerCase() 和 toLocaleUpperCase() 方法则是针对特定地区的实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br>alert(stringValue.toLocaleUpperCase());  <span class="hljs-comment">//&quot;HELLO WORLD&quot;</span><br>alert(stringValue.toUpperCase());        <span class="hljs-comment">//&quot;HELLO WORLD&quot;</span><br>alert(stringValue.toLocaleLowerCase());  <span class="hljs-comment">//&quot;hello world&quot;</span><br>alert(stringValue.toLowerCase());        <span class="hljs-comment">//&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h3><p>这个方法比较两个字符串，并返回下列值中的一个: </p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数(大多数情况下是 -1，具体的值要视实现而定)</li>
<li>如果字符串等于字符串参数，则返回 0</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数(大多数情况下是 1，具体的值同样要视实现而定)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">&quot;yellow&quot;</span>;       <br>alert(stringValue.localeCompare(<span class="hljs-string">&quot;brick&quot;</span>));         <span class="hljs-comment">//1</span><br>alert(stringValue.localeCompare(<span class="hljs-string">&quot;yellow&quot;</span>));        <span class="hljs-comment">//0</span><br>alert(stringValue.localeCompare(<span class="hljs-string">&quot;zoo&quot;</span>));           <span class="hljs-comment">//-1</span><br></code></pre></td></tr></table></figure>

<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><hr>
<p>单体内置对象是由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。<br>意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。<br>前面我们说的 Object、Array 和 String 都是内置对象。<br>ECMA-262 还定义了两个单体内置对象: Global 和 Math。</p>
<h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h2><hr>
<p>Global(全局)对象可以说是 ECMAScript 中最特别的一个对象了。不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数，所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。本书前面介绍过的那些函数，诸如 isNaN()、isFinite()、parseInt() 以及 parseFloat()，实际上全都是 Global 对象的方法。</p>
<h3 id="URI-编码方法"><a href="#URI-编码方法" class="headerlink" title="URI 编码方法"></a>URI 编码方法</h3><p>Global 对象的 encodeURI() 和 encodeURIComponent() 方法可以对 URI 进行编码，以便发送给浏览器。<br><strong>这两个 URI 编码方法可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。</strong></p>
<ul>
<li>encodeURI() 主要用于整个 URI</li>
<li>encodeURIComponent() 主要用于对 URI 中的某一段</li>
</ul>
<p>它们的主要区别在于: </p>
<ul>
<li>encodeURI() 不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号</li>
<li>encodeURIComponent() 则会对它发现的任何非标准字符进行编码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> uri = <span class="hljs-string">&quot;http://www.wrox.com/illegal value.htm#start&quot;</span>;<br><br><span class="hljs-comment">//&quot;http://www.wrox.com/illegal%20value.htm#start&quot;</span><br>alert(<span class="hljs-built_in">encodeURI</span>(uri));<br><br><span class="hljs-comment">//&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</span><br>alert(<span class="hljs-built_in">encodeURIComponent</span>(uri));<br></code></pre></td></tr></table></figure>

<p><strong>一般来说，我们使用 encodeURIComponent() 方法的时候要比使用 encodeURI() 更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。</strong></p>
<p>与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 decodeURI() 和 decodeURIComponent(): </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> uri = <span class="hljs-string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</span>;<br><br><span class="hljs-comment">//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start</span><br>alert(<span class="hljs-built_in">decodeURI</span>(uri));<br><br><span class="hljs-comment">//http://www.wrox.com/illegal value.htm#start</span><br>alert(<span class="hljs-built_in">decodeURIComponent</span>(uri));<br></code></pre></td></tr></table></figure>

<h3 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval() 方法"></a>eval() 方法</h3><p>eval() 方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript(或 JavaScript)字符串: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;alert(&#x27;hi&#x27;)&quot;</span>);<br><span class="hljs-comment">//等价于</span><br>alert(<span class="hljs-string">&quot;hi&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>当解析器发现代码中调用 eval() 方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置。</p>
<h3 id="Global-对象的属性"><a href="#Global-对象的属性" class="headerlink" title="Global 对象的属性"></a>Global 对象的属性</h3><p>Global 对象还包含一些属性，例如，特殊的值 undefined、NaN 以及 Infinity 都是 Global 对象的属性。此外，所有原生引用类型的构造函数，像 Object 和 Function，也都是Global对象的属性。<br>ECMAScript 5 明确禁止给 undefined、NaN 和 Infinity 赋值，这样做即使在非严格模式下也会导致错误。</p>
<h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><hr>
<p>ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&quot;red&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-built_in">window</span>.color);<br>&#125;<br><br><span class="hljs-built_in">window</span>.sayColor();  <span class="hljs-comment">//&quot;red&quot;</span><br></code></pre></td></tr></table></figure>

<p>另一种取得 Global 对象的方法是使用以下代码: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">global</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; <br>&#125;();<br></code></pre></td></tr></table></figure>

<p>在没有给函数明确指定 this 值的情况下(无论是通过将函数添加为对象的方法，还是通过调用 call() 或 apply())，this 值等于 Global 对象。</p>
<h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><hr>
<p>ECMAScript 还为保存数学公式和信息提供了一个公共位置，即 Math 对象。</p>
<h3 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min() 和 max() 方法"></a>min() 和 max() 方法</h3><p>min() 和 max() 方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">3</span>, <span class="hljs-number">54</span>, <span class="hljs-number">32</span>, <span class="hljs-number">16</span>);<br>alert(max);    <span class="hljs-comment">//54</span><br><br><span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">3</span>, <span class="hljs-number">54</span>, <span class="hljs-number">32</span>, <span class="hljs-number">16</span>);<br>alert(min);    <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure>

<p>要找到数组中的最大或最小值，可以像下面这样使用 apply() 方法: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>];<br><span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, values);<br></code></pre></td></tr></table></figure>

<h3 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h3><p>Math.ceil()、Math.floor() 和 Math.round()。这三个方法分别遵循下列舍入规则: </p>
<ul>
<li>Math.ceil() 执行向上舍入，即它总是将数值向上舍入为最接近的整数</li>
<li>Math.floor() 执行向下舍入，即它总是将数值向下舍入为最接近的整数</li>
<li>Math.round() 执行标准舍入，即它总是将数值四舍五入为最接近的整数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">alert(<span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">25.9</span>));     <span class="hljs-comment">//26</span><br>alert(<span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">25.5</span>));     <span class="hljs-comment">//26</span><br>alert(<span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">25.1</span>));     <span class="hljs-comment">//26</span><br><br>alert(<span class="hljs-built_in">Math</span>.round(<span class="hljs-number">25.9</span>));    <span class="hljs-comment">//26</span><br>alert(<span class="hljs-built_in">Math</span>.round(<span class="hljs-number">25.5</span>));    <span class="hljs-comment">//26</span><br>alert(<span class="hljs-built_in">Math</span>.round(<span class="hljs-number">25.1</span>));    <span class="hljs-comment">//25</span><br><br>alert(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">25.9</span>));    <span class="hljs-comment">//25</span><br>alert(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">25.5</span>));    <span class="hljs-comment">//25</span><br>alert(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">25.1</span>));    <span class="hljs-comment">//25</span><br></code></pre></td></tr></table></figure>

<h3 id="random-方法"><a href="#random-方法" class="headerlink" title="random() 方法"></a>random() 方法</h3><p>Math.random() 方法返回介于 0 和 1 之间一个随机数，不包括 0 和 1。<br>套用下面的公式，就可以利用 Math.random() 从某个整数范围内随机选择一个值: </p>
<blockquote>
<p>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</p>
</blockquote>
<p>如果你想选择一个 1 到 10 之间的数值，可以像下面这样编写代码: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10</span> + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/JavaScript(%E4%B8%83)/">
        前の記事<br>JavaScript(七)
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/JavaScript(%E4%BA%94)/">
        次の記事<br>JavaScript(五)
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    &copy; 2022 <a href="https://1ess.github.io">A Sort Of A Blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js"
        integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js"
        integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"
        integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js"
        integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?79178678"></script>



</body>
</html>
